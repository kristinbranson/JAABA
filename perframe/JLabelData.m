classdef JLabelData < matlab.mixin.Copyable
  % This is the class that is essentially the JLabel "model" in MVC terms 
  % --- it holds all of the critical data that JLabel allows a user to
  % manipulate, but doesn't deal with visual or presentational issues.
  % (OK, in a few places it does, but those should probably be changed.)
  
  % About everythingParams and basicParams: these are typically instances
  % of class Macguffin.  Macguffins represent all of the stuff that gets 
  % saved to the .jab file.  A variable named basicParams is typically a
  % Macguffin that has no experiments, or labels, or classifier set.  They
  % typically arise when creating a new .jab file.  A variable named
  % everythingParams is generally the contents of a .jab file, which may
  % well have experiments, labels, and/or a classifier.
  
  % About lexicons, sublexicons, dialects, subdialects, vocabularies, and 
  % all that: 
  %   The feature lexicon is the set of all possible features, not 
  %   including the score features (a.k.a. scores-as-inputs).
  %
  %   The feature dialect is the feature lexicon plus the score features.
  %   (In this analogy, the score features are like region-specific words,
  %   or jargon.)
  % 
  %   The feature sublexicon is the subset of the feature lexicon that
  %   actually gets calculated for a particular .jab file.
  % 
  %   The feature subdialect is the sublexicon plus the score features.
  % 
  %   The feature vocabulary is the enabled features of the sublexicon, plus
  %   the enabled score features.  (The idea is that the classifier only "speaks"
  %   this vocabulary.)
  %
  %   Note that in all of the above, "features" can mean "per-frame
  %   features" or "window features", depending on the context.
  
  % -----------------------------------------------------------------------
  properties (SetAccess=private, GetAccess=public)
    expi  % currently selected experiment
    flies  % currently selected flies
  end  % properties which are read-only to outsiders
  
  
  % -----------------------------------------------------------------------
  properties (Access=public) 
    % type of target (mainly used for plotting)
    % this should be a type of animal, and should be singular, not plural
    targettype
        
    % last-used trajectories (one experiment, all flies)
    trx

    % last-used per-frame data (one fly)
    % This seems to generally be a cell array with as many elements as
    % allperframefns.  (I.e. as many features as are in the subdialect.)
    % Each element contains a double array with approximately as many
    % elements as there are frames in the current track, which gives the
    % value of that per-frame feature for that frame, for the current
    % experiment and target.  --ALT, Apr 10 2013
    perframedata
    
    % A feature lexicon is the universe of possible features available.
    % The features used when training a classifier for a particular
    % behavior are a subset of the feature lexicon, and the features
    % used by a particular trained classifier will be a further subset.
    % Each possible feature lexicon has a name, such as 'flies', or
    % 'vivek_mice'
    featureLexiconName
    
    % The actual feature lexicon itself.  Note that we should not assume
    % the feature lexicon exactly matches the feature lexicon named
    % featureLexiconName in the global config files.  That's because the
    % user may have modified the featureLexicon for this everything file.
    % (Granted, there's no way to do this in the UI as of Apr 2, 2013, but
    % that may change in the future.  Plus we want to at least make it
    % possible for the user to hack the everything file in this way.)
    featureLexicon
    
    % Logical scalar, true for ST mode
    isST
    
    % windowdata holds computed and cached window features
    % windowdata(iCls).X
    % ...
    windowdata

    % predictdata stores predictions.  It is cell array, with as many
    % elements as there are experiments.  Each element holds another cell
    % array, with as many elements as there are targets in that experiment.
    % Each element of _that_ cell array is a struct array, with fields:
    %
    %   t           - startframe:endframe for exp, target. ALTODO: This state is duplicated identically across multiple classifiers
    %   cur
    %   cur_valid
    %   cur_pp
    %   old
    %   old_valid
    %   old_pp
    %   loaded
    %   loaded_valid
    %   loaded_pp
    %   timestamp
    %
    % I think the bottom-level structs are either empty or scalar, and are
    % only empty if the predictions have not been calculated for that
    % experiment and animal.
    %
    % In the scalar case, all these fields hold row vectors of length equal
    % to the trajectory length in frames. cur holds the scores generated by
    % the current classifier, old holds the scores generated by the old
    % classifier, loaded holds scores that were loaded from a file. _pp
    % fields hold post-processed scores, _valid fields hold whether that
    % score for that experiment, target, and frame is valid, and fields
    % without a suffix hold the raw scores (I think).  t gives the frame
    % number for each element, and timestamp gives the timestamp of the
    % classifier that generated the score.
    %
    % AL: predictdata{expi}{flyi} = [] OR
    % predictdata{expi}{flyi}(timelinei). Currently timelinei corresponds
    % to behaviori/labeli for 1:numRealBehaviors.
    predictdata
    
    % The predictblocks stores which frames, for which tracks, get
    % predicted when training happens.  (B/c you only really need to
    % predict frames where there are labels.)  Also, if a user is looking
    % at a particular stretch of frames for a particular track, that
    % stretch will get added to predictblocks, regardless of whether there
    % are labelled frames anywhere near it.  -- ALT, Mar 04 2013
    %
    % predictblocks(iCls).t0
    % predictblocks(iCls).t1
    % predictblocks(iCls).expi
    % predictblocks(iCls).flies
    predictblocks

    % See Predict.fastPredict
    % fastPredict(iCls).<etc>
    fastPredict
        
    % constant: radius of window data to compute at a time
    windowdatachunk_radius
    predictwindowdatachunk_radius
    % total number of experiments
    %nexps = 0;  % this is now a dependent property
    
    % labels struct array
    % labels(expi) is the labeled data for experiment expi
    % labels(expi).t0s are the start frames of all labeled sequences for
    % experiment expi
    % labels(expi).t1s are the corresponding end frames of all labeled
    % sequences for experiment expi (strictly, one past the last frame)
    % labels(expi).names is the cell array of the corresponding behavior
    % names for all labeled sequences for experiment expi
    % labels(expi).flies is the nseq x nflies_labeled matrix of the
    % corresponding flies for all labeled sequences for experiment expi
    % t0s{j}, t1s{j}, names{j}, and flies(j,:) correspond to each other. 
    % labels(expi).off is the offset so that labels(expi).t0s(j) +
    % labels(expi).off corresponds to the frame of the movie (since the
    % first frame for the trajectory(s) may not be 1.
    % labels(expi).timestamp is the Matlab timestamp at which labels(expi)
    % was last set
    labels
    
    % labels for the current experiment and flies, represented as an array
    % such that labelidx(t+labelidx_off) is the index of the behavior for
    % frame t of the movie. labelidx(i) == 0 corresponds to
    % unlabeled/unknown, otherwise labelidx(i) corresponds to behavior
    % labelnames{labelidx{i})
    labelidx
    labelidx_off
    
    %labelsLoadedFromClassifier = false;
    % first frame that all flies currently selected are tracked
    t0_curr
    % last frame that all flies currently selected are tracked
    t1_curr
    
    % predicted label for current experiment and fly, with the same type
    % of representation as labelidx, except that a value of zero means that
    % there is no prediction (as when a classifier has not yet been trained, 
    % or has been cleared).  These variables are essentially a cache of the
    % data in self.predictdata.
    predictedidx
    scoresidx  % Is this really an index?  Isn't it just the score itself?
    scoresidx_old
    scoreTS  % timestamp for the above. ALTODO: does not appear to be used for anything
    
    % whether the predicted label matches the true label. 0 stands for
    % either not predicted or not labeled, 1 for matching, 2 for not
    % matching. this has the same representation as labelidx.
    erroridx
    
    % TODO: remove this
    % predictedidx for unlabeled data, same representation as labelidx
    suggestedidx
    
    % names of behaviors, corresponding to labelidx
    labelnames        
        
    % number of behaviors, including 'none'.
    % AL: Better name is nlabels
    nbehaviors
  end  
  
  properties
    ntimelines
    iLbl2iCls % 2*nclassifiers-by-1 array. iCls = iLbl2iCls(iLbl) where 
              % iLbl/iCls reference .labelnames/.classifiernames resp.
    iCls2iLbl % nclassifiers-by-1 cell array, each el is 1-by-2 array.
              % [iLblPos iLblNeg] = iCls2iLbl{iCls} where iLblPos, iLblNeg 
              % index .labelnames.

    % statistics of labeled data per experiment
    % labelstats(expi).nflies_labeled is the total number of flies labeled,
    % labelstats(expi).nbouts_labeled is the total number of bouts of
    % behaviors labeled, labelstats(expi).
    labelstats
    %gt_labelstats = struct('nflies_labeled',{},'nbouts_labeled',{});
    
    % computing per-frame properties
    perframe_params
    landmark_params
    
    classifiertype % 1-by-nclassifiers cellstr    
    % currently learned classifier. structure depends on the type of
    % classifier. if empty, then no classifier has been trained yet. 
    classifier % 1-by-nclassifiers cell
    classifier_old
    lastFullClassifierTrainingSize
    classifierTS  % 1-by-nclassifiers vector of default time stamps. Number of days since Jan 0, 0000 (typically non-integer)    
    trainstats % 1-by-nclassifiers cell array
    
    % parameters to learning the classifier. struct fields depend on type of classifier.
    % 1-by-nclassifiers cell
    classifier_params
    
    % stuff cached during prediction
    %predict_cache
    
    % % name of file containing config parameters
    % configfilename = '';
    
    % constant: files per experiment directory
    %filetypes = {'movie','trx','label','gt_label','perframedir','clipsdir','scores'};
    filetypes
    
    % locations of files within experiment directories
    moviefilename
    trxfilename
    scorefilename % cellstr
    perframedir
    clipsdir
    scores
    stfeatures
    
    % Properties relating to whether there is a movie to show
    %openmovie  % true iff a movie is one of the required files for each experiment
    %ismovie  
    
    % experiment info: expi indexes the following
    
    % cell array of input experiment directory paths for the current GT
    % mode
    expdirs
    
    % array of number of flies in each experiment
    nflies_per_exp
    
    % cell array of arrays of first frame of each trajectory for each
    % experiment: firstframes_per_exp{expi}(fly) is the first frame of the
    % trajectory of fly for experiment expi. 
    firstframes_per_exp
    % cell array of arrays of end frame of each trajectory for each
    % experiment: endframes_per_exp{expi}(fly) is the last frame of the
    % trajectory of fly for experiment expi. 
    endframes_per_exp
    
    % sex per experiment, fly
    frac_sex_per_exp
    sex_per_exp
    
    % whether sex is computed
    hassex
    % whether sex is computed on a per-frame basis
    hasperframesex
    
    % last-used path for loading jabfiles
    defaultpath

    % last-used path for loading experiments
    expdefaultpath

    % struct from curperframefns->[structs containing window feature parameters]
    % Each field holds the parameters for a single per-frame feature in the
    % feature vocabulary, with the field name being the per-frame feature
    % name. Score features are included in the feature vocabulary.
    windowfeaturesparams
    
    % struct from curperframefns->[cell array of window feature parameters]
    % parameters of window features, represented as a cell array of
    % parameter name, parameter value, so that it can be input to
    % ComputeWindowFeatures
    windowfeaturescellparams
    
    %savewindowfeatures = false;  % whether unsaved changes have been made
    %                             % to the features
    
    % State of the basic/compact feature table.
    %basicFeatureTable = {};  % now calculate on the fly
    %maxWindowRadiusCommonCached = [];  
      % need to remember between calls to SelectFeatures, because it needs
      % to override the max_window_radius in the window-feature amount
      % presets in the feature lexicon, and these WF amount presets are not
      % retained in the feature vocabulary.  (And we don't want to retain
      % them in JLabelData's feature vocabulary, b/c they're not _really_
      % part of the feature vocabulary.)  (But I suppose we could add them
      % if we wanted to...)
    
    % per-frame features that are used
    allperframefns  % The list of all per-frame feature names in 
                    % the lexicon that are actually calculated for
                    % each frame, plus the scores-as-input feature
                    % names.  I would call this the the 'subdialect'.
                    % --ALT, Apr 5, 2013
    curperframefns  % The list of all per-frame feature names
                    % that are enabled, i.e. used for used for classifier 
                    % training.  This is a subset of allperframefns, and will 
                    % include a subset of the score features (but the
                    % subset might be the empty set).  I would 
                    % call this the 'vocabulary'.  --ALT, May 18, 2013
      % Thus curperframefns is the subset of allperframefns that are enabled.                    
      
    % units for perframedata
    perframeunits 

    % the scores from other classifiers that that used as features for this
    % classifier.  A structure array with number of elements equal to the
    % number of score features.  classifierfile holds the absolute path of
    % the .jab file holding the external classifier, ts holds the time step
    % of the classifier, and scorefilename is the local base name of the
    % score file stored in the experiment directory (e.g. "Chase_v7")
    scoreFeatures 
    
    % experiment/file management

    % matrix of size nexps x numel(file_types), where
    % fileexists(expi,filei) indicates whether file filetypes{filei} exists
    % for experiment expi
    fileexists 
    
    % timestamps indicating time the files were last edited, same structure
    % as fileexists
    filetimestamps
    
    % whether all necessary files for all experiments exist
    allfilesexist 

    % whether we can generate any missing files
    filesfixable 
    
    % whether user has given permission to generate the perframe files
    perframeGenerate
    
    % to overwrite or keep the perframe files.
    perframeOverwrite
    
    % warn about removing arena features.
    arenawarn
    hasarenaparams
    
    % functions for writing text to a status bar
    setstatusfn
    clearstatusfn
    
    % data for show similar frames.
    frameFig 
    distMat 
    bagModels
    fastPredictBag 

    confThresholds % nclassifiers-by-2 array
    
    % Retrain properly
    doUpdate 
    
    % Ground truthing or not
    gtMode        % Seems like it would make sense to not have
                  % JLabelData know about this---it's really more
                  % a property of the View, not the Model, it seems to
                  % me.  --ALT, Jan 17 2013
                  % Maybe, but making it that way would be a pain in the
                  % ass.  --ALT, Apr 22 2013
                  % This is set to empty unless a file is open.
    
    % Ground truthing suggestion
    randomGTSuggestions % randomGTSuggestions{iExp}(iFly).start, .end (scalars)
    thresholdGTSuggestions
    loadedGTSuggestions % same format/structure as randomGTSuggestions, except .start/.end can be vectors
    balancedGTSuggestions
    GTSuggestionMode
    
    cacheSize
    savewindowdata % 1-by-nclassifiers double
    loadwindowdata % 1-by-nclassifiers double. 
    
    postprocessparams % 1-by-nclassifiers cell
    version
        
    % A place to store things for the other mode.
    % So if the JLabelData instance is created in GT mode, this stores the
    % normal experiment directory names, labels, and label statisitics.  If
    % JLabelData is created in Normal mode, this store the GT experiment
    % directory names, etc.  This keeps the stuff for the other mode out of
    % our hair, but keeps it around so that we can save it to the
    % everything file.
    otherModeLabelsEtc
    
    % you could argue that these are view-related, and so shouldn't be in
    % here, but they get saved to the everything file, so we'll include
    % them here.
    labelGraphicParams
    trxGraphicParams
    labelcolors
    unknowncolor
    
    % A slot to store whether the JLabelData object is being used
    % interactively.  Controls whether the object tries to ask the user
    % questions, etc.  At some point, it might be nice to refactor so that
    % this went away, and the JLabelData object _never_ did UI type stuff.
    isInteractive
    
    % .jab-file handling stuff
    thereIsAnOpenFile
    everythingFileNameAbs      % the name of the everything file, if one
                               % is open.  We need this here b/c a new
                               % everything file doesn't have a JLabelData
                               % object yet.
    userHasSpecifiedEverythingFileName         % true iff the everything
                                               % file name was specified by
                                               % the user, as opposed to
                                               % being chosen by default
                                               % when a new file was
                                               % created
    needsave  % true iff a file is open and there are unsaved changes.  False if no file is open.
    
    usePastOnly % whether to only use past information when predicting the current frame
    
    deterministic = false; % scalar logical or double, for testing purposes. If nonzero, may be used as RNG seed
    
  end

 
  % -----------------------------------------------------------------------
  properties (GetAccess=public,SetAccess=immutable,Dependent=true)
    expnames
    nexps
    nTargetsInCurrentExp
    ismovie    % true iff the movie file name is nonempty.  If movie file name is empty, it means we don't try to open movies.
    nclassifiers
    classifiernames % 1-by-nclassifiers cellstr
    nobehaviornames % 1-by-nclassifiers cellstr  
    iCls2LblNames % nclassifiers-by-1 cell array, each el is 1-by-2 cellstr
  end

  
  % -----------------------------------------------------------------------
  methods  % getters and setters need to be in a methods block with no access specifiers
    function v = get.nclassifiers(self)
      v = self.ntimelines;
    end
    function v = get.classifiernames(self)
      v = self.labelnames(1:self.nclassifiers);
    end
    function v = get.nobehaviornames(self)
      v = self.labelnames(self.nclassifiers+1:end);
    end
    function v = get.iCls2LblNames(self)
      lblnames = self.labelnames;
      iCls2iLbl = self.iCls2iLbl;
      v = cellfun(@(x)lblnames(x),iCls2iLbl,'uni',0);
    end
    
    function expnames = get.expnames(self)
      % Get the names of all the experiments for the current GT mode
      expDirNames = self.expdirs;
      expnames = cellfun(@fileBaseName,expDirNames,'UniformOutput',false);
    end
    
%     function set.expnames(self,newValue)  %#ok
%       % Do nothing, b/c now we just compute expnames when we need it 
%       % Eventually this method should go away, and all calls to it also.
%       warning('Trying to set JLabelData.expnames');
%     end    
    
    function nexps = get.nexps(self)
      % Get the number of experiments for the current GT mode
      nexps = length(self.expdirs);
    end
    
%     function set.nexps(self,newValue)  %#ok
%       % Do nothing, b/c now we just compute nexps when we need it 
%       % Eventually this method should go away, and all calls to it also.
%       warning('Trying to set JLabelData.nexps');
%     end

    function nTargetsInCurrentExp=get.nTargetsInCurrentExp(self)
      if self.nexps>0 && ~isempty(self.expi) && self.expi~=0 ,
        nTargetsInCurrentExp=self.nflies_per_exp(self.expi);
      else
        nTargetsInCurrentExp=[];
      end
    end
    
%     function set.nTargetsInCurrentExp(self,newValue)  %#ok
%       % do nothing---this property is read-only
%       warning('Trying to set JLabelData.nTargetsInCurrentExp');
%     end
    
    function ismovie = get.ismovie(self)
      % Get whether the movie file name is set
      ismovie = ~isempty(self.moviefilename);
      % ismovie=~isempty(self.moviefilename) && self.openmovie;
    end
    
  %end  % methods block
  
  % ALTODO: This access=private is there for a reason, why is it commented out
  % -----------------------------------------------------------------------
  %methods (Access=private)
    % ---------------------------------------------------------------------
    function initialize(self)
      % Set all properties to the state they should have just after the
      % JLabelData object is created, before any .jab file has been loaded
      % or a new file is created.  The state of the object after calling
      % this function does not depend at all on the state prior to calling
      % it.  Nothing is spared.  Scorched earth.
      % Also: No attempt is done to close open files, or anything like
      % that.  It just sets the properties to the values they should have
      % initially.
      self.expi = 0;
      self.flies = [];    
      self.targettype = 'fly';
      self.trx = {};
      self.perframedata = {};
      self.featureLexiconName='';
      self.featureLexicon=[];
      self.windowdata = WindowData.windowdata(0);
      self.predictdata = {};
      self.predictblocks = Predict.predictblocks(0);
      self.fastPredict = Predict.fastPredict(0);
      self.windowdatachunk_radius = 100;
      self.predictwindowdatachunk_radius = 10000;
      self.labels = Labels.labels(0); 
      self.labelidx = struct('vals',[],'imp',[],'timestamp',[]);
      self.labelidx_off = 0;
      self.t0_curr = 0;
      self.t1_curr = 0;
      self.predictedidx = [];
      self.scoresidx = [];  
      self.scoresidx_old = [];
      self.scoreTS = [];  
      self.erroridx = [];
      self.suggestedidx = [];
      self.labelnames = {};
      self.nbehaviors = 0;
      self.ntimelines = 0;
      self.labelstats = struct('nflies_labeled',{},'nbouts_labeled',{});
      self.perframe_params = {};
      self.landmark_params = struct;  % scalar struct with no fields
      self.classifiertype = 'boosting';
      self.classifier = [];
      self.classifier_old = [];
      self.lastFullClassifierTrainingSize = 0;
      self.classifierTS = zeros(1,0); 
      self.trainstats = cell(1,0);
      self.classifier_params = cell(1,0);
      %self.predict_cache = struct;
      self.filetypes = {'movie','trx','perframedir','clipsdir','scores','stfeatures'};
      self.moviefilename = 0;
      self.trxfilename = 0;
      self.scorefilename = 0;
      self.perframedir = 0;
      self.clipsdir = 0;
      self.scores = 0;
      self.stfeatures = 0;
      %self.openmovie = false;
      % self.ismovie = false;
      self.expdirs = {};
      self.nflies_per_exp = [];
      self.firstframes_per_exp = {};
      self.endframes_per_exp = {};
      self.frac_sex_per_exp = {};
      self.sex_per_exp = {};
      self.hassex = false;
      self.hasperframesex = false;
      self.defaultpath = '';
      self.expdefaultpath = '';
      self.windowfeaturesparams = cell(0,1);
      self.windowfeaturescellparams = cell(0,1);
      self.allperframefns = {};
      self.curperframefns = {};
      self.perframeunits = {};
      self.scoreFeatures = struct('classifierfile',{}, ...
                                  'ts',{}, ...
                                  'scorefilename',{});
      self.fileexists = false(0,numel(self.filetypes));
      self.filetimestamps = nan(0,numel(self.filetypes));
      self.allfilesexist = true;
      self.filesfixable = true;
      self.perframeGenerate = [];
      self.perframeOverwrite = [];
      self.arenawarn = true;
      self.hasarenaparams = [];
      self.setstatusfn = '';
      self.clearstatusfn = '';
      self.frameFig = [];
      self.distMat = [];
      self.bagModels = {};
      self.fastPredictBag = ...
        struct('classifier',[], ...
               'windowfeaturescellparams',[],...
               'wfs',[], ...
               'pffs',[], ...
               'ts',[], ...
               'tempname',[], ...
               'curF',[], ...
               'dist',[], ...
               'trainDist',[]);
      self.confThresholds = zeros(0,2);
      self.doUpdate = true;
      self.gtMode = [];
      self.randomGTSuggestions = {};
      self.thresholdGTSuggestions = [];
      self.loadedGTSuggestions = {};
      self.balancedGTSuggestions = {};
      self.GTSuggestionMode = '';
      self.cacheSize = 4000;
      self.postprocessparams = [];
      self.version = '';
      self.otherModeLabelsEtc = struct('expDirNames',{cell(1,0)}, ...
                                       'labels',{struct([])});
      self.labelGraphicParams=[];
      self.trxGraphicParams=[];
      self.labelcolors = [];
      self.unknowncolor = [0 0 0];
      self.isInteractive=true;
      self.thereIsAnOpenFile=false;
      self.everythingFileNameAbs='';
      self.userHasSpecifiedEverythingFileName=false;
      self.needsave=false;
      self.savewindowdata = false(1,0);
      self.loadwindowdata = true(1,0);
      
      self.usePastOnly = false;
      
    end  % method
    
    
%     % ---------------------------------------------------------------------    
%     function [success,msg] = setFeatureLexiconAndTargetSpeciesRaw(obj,featureLexicon,targetSpecies,varargin)
%       % This sets the feature lexicon to the given one, and also sets the target species.  If the
%       % featureLexicon is not one of the named ones, then either no
%       % featureLexiconName should be given, or the name should be 'custom'.
%             
%       obj.targettype=targetSpecies;  % what species the targets are
%       [success,msg] = ...
%         obj.setFeatureLexiconAndFLName(featureLexicon,varargin{:});
%     end  % method
    
    
%     % ---------------------------------------------------------------------    
%     function [success,msg] = setFeatureLexiconAndTargetSpeciesFromFLName(obj,featureLexiconName)
%       % This sets the feature lexicon to the one named by
%       % featureLexiconName
%       
% %       % Only do stuff if the new lexicon name is different than the current
% %       % one
% %       if isequal(featureLexiconName,obj.featureLexiconName)
% %         success=true;
% %         return
% %       end
%       
%       % Get the lexicon itself and the associated animal type
%       [featureLexicon,animalType]= ...
%         featureLexiconFromFeatureLexiconName(featureLexiconName);     
% 
%       % Store the lexicon-associated stuff in obj
%       %[success,msg] = obj.setFeatureLexiconAndTargetSpeciesRaw(featureLexicon,animalType,featureLexiconName);
%       [success,msg] = obj.setFeatureLexiconAndFLName(featureLexicon,featureLexiconName);
%       
%       % Set the animal type
%       obj.targettype=animalType;
%     end  % method
    
    
%     % ---------------------------------------------------------------------    
%     function [success,msg] = setFeatureLexiconAndFLName(obj,featureLexicon,featureLexiconName)
%       % This sets the feature lexicon to the given one.  If the
%       % featureLexicon is not one of the named ones, then either no
%       % featureLexiconName should be given, or the name should be 'custom'.
%       
%       % process args
%       if ~exist('featureLexiconName','var')
%         featureLexiconName='custom';
%       end
%       
%       % Setup the default return values
%       %success = false;
%       msg = '';
% 
%       % Store the lexicon-associated stuff in obj
%       obj.featureLexiconName=featureLexiconName;
%       obj.featureLexicon=featureLexicon;  % save to obj
%       %obj.targettype=targetSpecies;  % what species the targets are
%       
%       % Update obj.perframe_params based on the new feature lexicon
%       if isfield(featureLexicon,'perframe_params'),
%         obj.perframe_params=featureLexicon.perframe_params;
%         % pf_fields = fieldnames(featureLexicon.perframe_params);
%         % for ndx = 1:numel(pf_fields),
%         %   obj.perframe_params.(pf_fields{ndx}) = ...
%         %     featureLexicon.perframe_params.(pf_fields{ndx});
%         % end
%       end
% 
%       % Update obj.allperframefns based on the new feature lexicon
%       obj.allperframefns =  fieldnames(featureLexicon.perframe);
%       
%       % Re-load the perframe feature signals, since the PFFs may have changed
%       obj.loadPerframeData(obj.expi,obj.flies);
% 
%       % Clear the classifier, since the feature lexicon has changed
%       % This also clears the features currently in use by the classifier
%       % trainer
%       obj.clearClassifierProper();
%       
%       % If we got this far, all is good
%       obj.needsave=true;
%       success = true;
%     end  % method
    
    
    % ---------------------------------------------------------------------    
    function setFeatureSublexicon(obj,featureLexicon,featureLexiconName,sublexiconPFNames)
      % This sets the feature lexicon to the given one. If the
      % featureLexicon is not one of the named ones, then either no
      % featureLexiconName should be given, or the name should be 'custom'.
            
      obj.featureLexiconName = featureLexiconName;
      obj.featureLexicon = featureLexicon;
      
      % Update obj.perframe_params based on the new feature lexicon
      if isfield(featureLexicon,'perframe_params')
        obj.perframe_params = featureLexicon.perframe_params;
        % pf_fields = fieldnames(featureLexicon.perframe_params);
        % for ndx = 1:numel(pf_fields),
        %   obj.perframe_params.(pf_fields{ndx}) = ...
        %     featureLexicon.perframe_params.(pf_fields{ndx});
        % end
      elseif ~isstruct(obj.perframe_params)
        obj.perframe_params = struct;
      end
      if ~isfield(obj.perframe_params,'nroi')
        obj.perframe_params.nroi = 0;
      end
      if ~isfield(obj.perframe_params,'nflies_close')
        obj.perframe_params.nflies_close = [];
      end
      
      obj.isST = isfield(featureLexicon,'st');

      % Update obj.allperframefns based on the new feature lexicon
      %obj.allperframefns =  fieldnames(featureLexicon.perframe);
      % assert(all(ismember(sublexiconPFNames,fieldnames(featureLexicon.perframe)))); % AL: true?
      obj.allperframefns = sublexiconPFNames;
            
      for i = 1:obj.perframe_params.nroi
        obj.allperframefns{end+1} = sprintf('dist2roi2_%02d',i);
        obj.allperframefns{end+1} = sprintf('angle2roi2_%02d',i);
      end
      
      for ii = 1:numel(obj.perframe_params.nflies_close)
        i = obj.perframe_params.nflies_close(ii);
        obj.allperframefns{end+1} = sprintf('nflies_close_%02d',i);
      end
      
      % Generate the necessary files now, so that any problems occur now.
      if obj.isST
        % none for now
      else
        generateMissingPerframeFiles = obj.perframeGenerate;
        for iExp=1:obj.nexps
          expName = obj.expnames{iExp};
          allPerframeFilesExist = obj.fileOfGivenTypesExistForGivenExps('perframedir',iExp);
          if ~allPerframeFilesExist
            % Figure out whether to try to generate the missing files
            obj.SetStatus('Some files missing for %s...',expName);
            if isempty(generateMissingPerframeFiles) && obj.isInteractive
              % Would be good to move UI stuff out of JLabelData, which is
              % essentially a model in MVC terms --ALT, Apr 30, 2013
              questionString = sprintf('Experiment %s is missing required per-frame files. Generate now?',expName);
              res = questdlg(questionString, ...
                             'Generate missing per-frame files?', ...
                             'Yes','No', ...
                             'Yes');
              if strcmpi(res,'Yes')
                generateMissingPerframeFiles = true;
                obj.perframeGenerate = true;
              elseif isempty(res) || strcmpi(res,'No')
                generateMissingPerframeFiles = false;
              end
            end
            % Generate the missing files, or generate an error  
            if ~isempty(generateMissingPerframeFiles) && generateMissingPerframeFiles
              obj.SetStatus('Generating missing files for %s...',expName);
              [success,msg] = obj.GeneratePerframeFilesExceptScoreFeatures(iExp);
              if ~success
                error('JLabelData:unableToGeneratePerframeFile',msg);
              end
            else
              obj.SetStatus('Not generating missing files for %s...',expName);
              msg = 'Unable to generate per-frame files because user declined to.';
              error('JLabelData:unableToGeneratePerframeFile',msg);
            end
          end
        end
        
        % Re-load the perframe feature signals, since the PFFs may have changed
        [success,msg] = obj.loadPerframeData(obj.expi,obj.flies);
        if ~success
          error('JLabelData:unableToLoadPerframeData',msg);
        end
      end      

      % Clear the classifier, since the feature lexicon has changed
      % This also clears the features currently in use by the classifier
      % trainer
      obj.clearClassifierProper();

      obj.needsave = true;
    end
    
    
    % ---------------------------------------------------------------------
    function [success,msg]=loadPerframeData(obj,expi,indicesOfTargets)
      % Loads the per-frame features for experiment expi and target
      % iTarget into obj.perframedata and obj.perframeunits      
      
      % Test for various degenerate cases 
      if isempty(indicesOfTargets)
        success=true;  msg='';
        return
      end
      iTarget=indicesOfTargets(1);
      if isempty(expi) || ~((1<=expi)&&(expi<=obj.nexps))
        success=true;  msg='';
        return
      end        
      % If we got here, expi and iTarget are non-degenerate
      perframeFileNameList = obj.GetPerframeFiles(expi);
      nPerframeFeatures=numel(obj.allperframefns);
      obj.perframedata=cell(1,nPerframeFeatures);
      obj.perframeunits=cell(1,nPerframeFeatures);      
      for j = 1:nPerframeFeatures,
        perframeFileName=perframeFileNameList{j};
        if ~exist(perframeFileName,'file'),
          success = false;
          msg = sprintf('Per-frame data file %s does not exist',perframeFileNameList{j});
          return;
        end
        tmp = load(perframeFileName);
        obj.perframedata{j} = tmp.data{iTarget};
        obj.perframeunits{j} = tmp.units;
      end
      success=true;
      msg='';
    end  % method
    
    
    % ---------------------------------------------------------------------
    function addSingleScoreFeature(obj,scoreFeature)
      % This is called by setScoreFeatures() to add a single score feature.
      % Rolling back on error is handled by setScoreFeatures.
      % We assume the score feature to be added is not already present.
      % This changes obj.scoreFeatures and obj.allperframefns, but not
      % obj.perframedata.
      
      % MERGEST OK

      % Convert the scores files into perframe files.
      pfName = scoreFeature.scorefilename; % this is the base name of the score file, which also serves as the per-frame feature name
      timeStamp = scoreFeature.ts;
      nExps = obj.nexps;
      for iExp = 1:nExps
        expName = obj.expnames{iExp};
        obj.SetStatus('Generating score-based per-frame feature file %s for %s...',pfName,expName);
        [success,msg,timeStamp,newProjectName] = obj.ScoresToPerframe(iExp, ...
          pfName, ...
          timeStamp,...
          scoreFeature.classifierfile);
        if ~success
          error('JLabelData:errorGeneratingPerframeFileFromScoreFile', ...
                sprintf('Error generating score-based per-frame file %s for %s: %s',pfName,expName,msg)); %#ok
        end
        scoreFeature.classifierfile = newProjectName;
      end
      
      scoreFeature.ts = timeStamp;
      
      % store scoreFeatures in self
      assert(~any(strcmp(pfName,obj.allperframefns)),...
        'Perframe function with name ''%s'' already exists.');
      obj.scoreFeatures = [obj.scoreFeatures;scoreFeature];
      obj.allperframefns = [obj.allperframefns;pfName];
    end

    
    % ---------------------------------------------------------------------
    function deleteSingleScoreFeature(obj,scoreFeature)
      % This is called by setScoreFeatures() to delete a single score feature.
      % Rolling back on error is handled by setScoreFeatures.
      % This changes obj.scoreFeatures and obj.allperframefns, but not
      % obj.perframedata.
      
      % MERGEST OK

      % Delete from scoreFeatures
      toBeDeleted = arrayfun(@(s)isequal(s,scoreFeature),obj.scoreFeatures);
      obj.scoreFeatures = obj.scoreFeatures(~toBeDeleted);
      
      % Delete from allperframefns
      pfName = scoreFeature.scorefilename;
      tf = strcmp(pfName,obj.allperframefns);
      assert(isequal(tf,toBeDeleted));
      notPfName = @(string)(~isequal(string,pfName));
      obj.allperframefns = cellFilter(notPfName,obj.allperframefns);      
    end
  
    
    % ---------------------------------------------------------------------
    function setMacguffin(obj,everythingParams,loadexps)
      % This initializes the JLabelData object based on the contents of
      % everythingParams
  
      % Deal with arguments
      if ~exist('loadexps','var')
        loadexps=true;
      end
      
      before=obj.copy();  % make a copy of the object, in case something goes wrong
      try
        % Note sure what to do here---Macguffin class doesn't have a perframe
        % property at present
        if isfield(everythingParams.extra,'perframe'),
          if isfield(everythingParams.extra.perframe,'params') && isstruct(everythingParams.extra.perframe.params),
            pf_fields = fieldnames(everythingParams.extra.perframe.params);
            for ndx = 1:numel(pf_fields),
              everythingParams.featureLexicon.perframe_params.(pf_fields{ndx}) = everythingParams.extra.perframe.params.(pf_fields{ndx});
            end
          end
          if isfield(everythingParams.extra.perframe,'landmarkParams'),
            obj.landmark_params = everythingParams.extra.perframe.landmarkParams;
          end
        end  % isfield(basicParams,'perframe'),

        % feature config file
        obj.setFeatureSublexicon(everythingParams.featureLexicon, ...
                                 everythingParams.featureLexiconName, ...
                                 everythingParams.sublexiconPFNames);
%         if isequal(everythingParams.featureLexiconName,'custom')
%           %obj.setFeatureLexiconAndTargetSpeciesCustom(everythingParams.featureLexicon, ...
%           %                                            everythingParams.behaviors.type);
%           [success,msg] = obj.setFeatureLexiconAndFLName(everythingParams.featureLexicon,'custom');
%           obj.targettype=everythingParams.behaviors.type;
%         else
%           [success,msg]=obj.setFeatureLexiconAndTargetSpeciesFromFLName(everythingParams.featureLexiconName);
%         end
%         if ~success , 
%           error('JLabelData:unableToSetFeatureSublexicon',msg);
%         end

        % Set the target species
        obj.targettype=everythingParams.behaviors.type;
                
        obj.labelGraphicParams=everythingParams.labelGraphicParams;
        obj.trxGraphicParams=cookTrxGraphicParams(everythingParams.trxGraphicParams);
        obj.labelcolors=everythingParams.behaviors.labelcolors;
        obj.unknowncolor=everythingParams.behaviors.unknowncolor;

        %
        % load in the rest of the stuff, depending on the fields present
        %

        % read in behavior names
        if isfield(everythingParams.behaviors,'names'),
          obj.labelnames = everythingParams.behaviors.names;
          assert(iscell(obj.labelnames));        
          obj.nbehaviors = numel(obj.labelnames);
        else
          obj.labelnames = {'Behavior','None'};
        end
        assert(numel(obj.labelcolors)==3*numel(obj.labelnames));

        [obj.ntimelines,obj.iLbl2iCls,obj.iCls2iLbl] = Labels.determineNumTimelines(obj.labelnames);
                
        if isfield(everythingParams.file,'moviefilename'),
          [success1,msg] = obj.SetMovieFileName(everythingParams.file.moviefilename);
          if ~success1,
            error('JLabelData:unableToSetMovieFileName', ...
                  msg);
          end
        end
        if isfield(everythingParams.file,'trxfilename'),
          [success1,msg] = obj.SetTrxFileName(everythingParams.file.trxfilename);
          if ~success1,
            error('JLabelData:unableToSetTrxFileName', ...
                  msg);
          end
        end
        if isfield(everythingParams.file,'scorefilename'),
          scorefilename = everythingParams.file.scorefilename;
        else
          scorefilename = {sprintf('scores_%s.mat',obj.labelnames{1})};
        end
        [success1,msg] = obj.setScoreFileName(scorefilename);
        if ~success1,
          error('JLabelData:unableToSetScoreFileName', ...
                msg);
        end
        if isfield(everythingParams.file,'perframedir'),
          [success1,msg] = obj.SetPerFrameDir(everythingParams.file.perframedir);
          if ~success1,
            error('JLabelData:unableToSetPerframeDirName', ...
                  msg);
          end
        end
        if isfield(everythingParams.file,'clipsdir') && ~isempty(everythingParams.file.clipsdir),
          [success1,msg] = obj.SetClipsDir(everythingParams.file.clipsdir);
          if ~success1,
            error('JLabelData:unableToSetClipsDirName', ...
                  msg);
          end
        end
        
        obj.stfeatures = 'features.mat'; % temporary hardcode
        [success1,msg] = obj.UpdateStatusTable('stfeatures');
        if ~success1
          error('JLabelData:unableToSetSTFeaturesName',msg);
        end

        if isfield(everythingParams.extra,'usePastOnly'),
          obj.usePastOnly = everythingParams.extra.usePastOnly;
        end


  %       if isfield(basicParams,'scoreFeatures') ,
  %         obj.scoreFeatures = basicParams.scoreFeatures;
  %         nScoreFeaturess=length(basicParams.scoreFeatures);
  %         scoreFeaturesPFNames=cell(nScoreFeaturess,1);
  %         for i = 1:nScoreFeaturess ,
  %           [~,pfName] = fileparts(obj.scoreFeatures(i).scorefilename);
  %           scoreFeaturesPFNames{i} = pfName;
  %         end
  %         obj.allperframefns=[obj.allperframefns ; ...
  %                             scoreFeaturesPFNames];
  %       end  % if isfield(basicParams,'scoreFeatures'),

        % Re-load the perframe feature signals, since the PFFs may have changed
        obj.loadPerframeData(obj.expi,obj.flies);

  %       % initialize the post-processing parameters
  %       obj.InitPostprocessparams();

        % initialize everything else
        if loadexps,
          obj.setAllLabels(everythingParams);
        end
        
        obj.setScoreFeatures(everythingParams.scoreFeatures);
        obj.setWindowFeaturesParams(everythingParams.windowFeaturesParams);
        obj.setClassifierStuff(everythingParams.classifierStuff);
        
      catch excp
        % If there's a problem, restore the object to its original state.
        obj.setToValue(before);
        rethrow(excp);
      end
        
    end  % method
    
    

    % ---------------------------------------------------------------------
    function setLabelsFromStructForAllExps(self,labelsForAll)
      statusTableString = fif(self.gtMode,'gt_label','label');
      nExps = length(self.expdirs);
      for expi = 1:nExps
        self.loadLabelsFromStructForOneExp(expi,labelsForAll(expi));
        %self.labelfilename = 0;
        self.UpdateStatusTable(statusTableString);   
      end
    end
    
    
    % ---------------------------------------------------------------------
    function loadLabelsFromStructForOneExp(self,expi,labels)
      % Load the labels for a single experiment into self.
            
      self.SetStatus('Loading labels for %s',self.expdirs{expi});

      self.labels(expi).t0s = labels.t0s;
      self.labels(expi).t1s = labels.t1s;
      self.labels(expi).names = labels.names;
      self.labels(expi).flies = labels.flies;
      self.labels(expi).off = labels.off;
      self.labelstats(expi).nflies_labeled = size(labels.flies,1);
      self.labelstats(expi).nbouts_labeled = numel([labels.t0s{:}]);
      Nfly = numel(labels.flies);
      if iscell(labels.timestamp)
        self.labels(expi).timestamp = labels.timestamp;
      else
        for ndx = 1:Nfly
          nBouts = numel(labels.t0s{ndx});
          if isempty(labels.timestamp)
            self.labels(expi).timestamp{ndx}(1:nBouts) = now;
          else
            self.labels(expi).timestamp{ndx}(1:nBouts) = labels.timestamp;
          end
        end
      end
      if isfield(labels,'timelinetimestamp')
        timelineTS = labels.timelinetimestamp;
        assert(iscell(timelineTS) && isequal(size(timelineTS),[1 Nfly]));
        self.labels(expi).timelinetimestamp = timelineTS;
      else
        self.labels(expi).timelinetimestamp = cell(1,Nfly);
        for ndx = 1:Nfly
          self.labels(expi).timelinetimestamp{ndx} = struct();
        end
      end
      if isfield(labels,'imp_t0s');
        self.labels(expi).imp_t0s = labels.imp_t0s;
        self.labels(expi).imp_t1s = labels.imp_t1s;
      else
        self.labels(expi).imp_t0s = cell(1,numel(labels.flies));
        self.labels(expi).imp_t1s = cell(1,numel(labels.flies));
      end

      self.ClearStatus();
    end  % method

    
    % ---------------------------------------------------------------------
    function UpdatePredictedIdx(obj)
      % Updates obj.predictedidx, obj.scoresidx, obj.scoreTS, obj.erroridx, 
      % and obj.suggestedidx to match what's in obj.predictdata, obj.expi,
      % obj.flies, obj.t0_curr, and obj.t1_curr.  For instance, this might
      % be used to update those variables after obj.expi changes.
      
      %MERGESTREVIEWED
      
      if obj.expi == 0,
        return;
      end
      
      n = obj.t1_curr - obj.t0_curr + 1;
      nTL = obj.labelidx.nTL;      
     
      obj.predictedidx = zeros(nTL,n);
      obj.scoresidx = zeros(nTL,n);
      obj.scoresidx_old = zeros(nTL,n);
      obj.scoreTS = zeros(nTL,n);
      
      if ~isempty(obj.predictdata) && ~isempty(obj.predictdata{obj.expi}) 
        % Overwrite by scores from predictdata.
        
        pdArr = obj.predictdata{obj.expi}{obj.flies};
        assert(numel(pdArr)==nTL);
        for iTL = 1:nTL 
          pd = pdArr(iTL);
          
          idxcurr = pd.cur_valid;
          idx = pd.t(idxcurr)-obj.t0_curr+1;
          obj.predictedidx(iTL,idx) = -sign(pd.cur(idxcurr))*0.5 + 1.5;
          obj.scoresidx(iTL,idx) = pd.cur(idxcurr);
          %obj.scoreTS(iTL,idx) = obj.classifierTS(iTL); 
          % ALTODO: .scoreTS does not appear to be used by anything.
          % This assignment causing problems due to order-of-initialization
          % (classifierTS is empty in certain call chains), just comment
          % out for now.
        end
      end
      obj.UpdateErrorIdx();
    end    
    
    
    % ---------------------------------------------------------------------
    function UpdateErrorIdx(obj)
      % Updates the obj.erroridx and obj.suggestedidx to match
      % obj.predictedidx and obj.labelidx.

      %MERGESTREVIEWED

      if obj.expi == 0,
        return;
      end
      
      n = obj.t1_curr - obj.t0_curr + 1;      
      nTL = obj.labelidx.nTL;
      
      obj.erroridx = zeros(nTL,n);
      obj.suggestedidx = zeros(nTL,n);
      
      assert(isequal(size(obj.predictedidx),size(obj.labelidx.vals)));
      idxcurr = obj.predictedidx ~= 0 & obj.labelidx.vals ~= 0;
      obj.erroridx(idxcurr) = double(obj.predictedidx(idxcurr) ~= obj.labelidx.vals(idxcurr))+1;
      
      idxcurr = obj.predictedidx ~= 0 & obj.labelidx.vals == 0;
      obj.suggestedidx(idxcurr) = obj.predictedidx(idxcurr);
    end

    
    % ---------------------------------------------------------------------
    function ClearCachedPerExpData(obj)
    % ClearCachedPerExpData(obj)
    % Clears all cached data for the currently loaded experiment
      obj.unsetCurrentTarget();
      obj.trx = {};
      obj.expi = 0;
      obj.flies = nan(size(obj.flies));
      obj.perframedata = {};
      obj.labelidx = struct('vals',[],'imp',[],'timestamp',[]);
      obj.labelidx_off = 0;
      obj.t0_curr = 0;
      obj.t1_curr = 0;
      obj.predictedidx = [];
      obj.scoresidx = [];
      obj.scoresidx_old = [];
      obj.erroridx = [];
      obj.suggestedidx = [];
    end
    
    
    % ---------------------------------------------------------------------
    function StoreLabelsAndPreLoadWindowData(obj)
      % Store labels cached in labelidx for the current experiment and flies
      % to labels structure. This is when the timestamp on labels gets
      % updated.  Also preloads the window data if not in GT mode.
      
      % flies not yet initialized
      if isempty(obj.flies) || all(isnan(obj.flies)) || isempty(obj.labelidx.vals),
        return;
      end
      
      obj.StoreLabelsForCurrentAnimal();
            
%       % preload labeled window data while we have the per-frame data loaded
%       ts = find(obj.labelidx.vals~=0) - obj.labelidx_off;
%       if ~obj.IsGTMode(),
%         [success,msg] = obj.PreLoadWindowData(obj.expi,obj.flies,ts);
%         if ~success,
%           warning(msg);
%         end
%       end
%       
%       % update windowdata's labelidx_new
%       if ~isempty(obj.windowdata.exp),
%         idxcurr = obj.windowdata.exp == obj.expi & ...
%           all(bsxfun(@eq,obj.windowdata.flies,obj.flies),2);
%         obj.windowdata.labelidx_new(idxcurr) = obj.labelidx.vals(obj.windowdata.t(idxcurr)+obj.labelidx_off);
%         obj.windowdata.labelidx_imp(idxcurr) = obj.labelidx.imp(obj.windowdata.t(idxcurr)+obj.labelidx_off);
%       end
      
      %obj.UpdateWindowDataLabeled(obj.expi,obj.flies);
      
    end  % method

    
% Training and prediction.
    % ---------------------------------------------------------------------
    function invalidatePredictions(self)
      % Mark the current and old classifier predictions as invalid.
      nExps=self.nexps;
      for iExp=1:nExps
        nTargets=self.nflies_per_exp(iExp);
        for iTarget=1:nTargets
          nTL = numel(self.predictdata{iExp}{iTarget});
          for iPD = 1:nTL
            self.predictdata{iExp}{iTarget}(iPD).cur(:)=0;
            self.predictdata{iExp}{iTarget}(iPD).cur_pp(:)=0;
            self.predictdata{iExp}{iTarget}(iPD).cur_valid(:)=false;
            self.predictdata{iExp}{iTarget}(iPD).old(:)=0;
            self.predictdata{iExp}{iTarget}(iPD).old_pp(:)=0;          
            self.predictdata{iExp}{iTarget}(iPD).old_valid(:)=false;
          end
        end
      end
      % Do I need to set self.windowdata.scoreNorm to something?
    end  % method
      

    % ---------------------------------------------------------------------
    function MoveCurPredictionsToOld(obj)
      for expi = 1:numel(obj.predictdata)
        for flies = 1:numel(obj.predictdata{expi})
          for iTL = 1:numel(obj.predictdata{expi}{flies})
            obj.predictdata{expi}{flies}(iTL).old = obj.predictdata{expi}{flies}(iTL).cur;
            obj.predictdata{expi}{flies}(iTL).old_valid = obj.predictdata{expi}{flies}(iTL).cur_valid;
            obj.predictdata{expi}{flies}(iTL).old_pp = obj.predictdata{expi}{flies}(iTL).cur_pp;
            obj.predictdata{expi}{flies}(iTL).cur_valid(:) = false;
          end
        end
      end
    end  % method
    
    
    % ---------------------------------------------------------------------
    function res = DoFullTraining(obj,doFastUpdates)  %#ok
      % ALTODO remove?
      
      % Check if we should do fast updates or not.
      res = true; return; % Always do complete training.
%       if ~doFastUpdates, return; end
%       if isempty(obj.classifier), return; end
%       if isempty(obj.windowdata.binVals), return; end
%       
%       if (numel(obj.classifier) - obj.classifier_params.iter)/obj.classifier_params.iter_updates > 4
%         return;
%       end
%       
%       oldNumPts = obj.lastFullClassifierTrainingSize;
%       newNumPts = nnz(obj.windowdata.labelidx_new ~= 0 & obj.windowdata.labelidx_imp );
%       newData = newNumPts - oldNumPts;
%       if (newData/oldNumPts)>0.25, return; end
%       
%       res = false;
    end
    
    
    % ---------------------------------------------------------------------
    function PredictLoaded(obj)
    % PredictLoaded(obj)
    % Runs the classifier on all preloaded window data.
            
    %MERGESTUPDATED
    
      if isempty(obj.classifier),
        return;
      end

      nCls = obj.nclassifiers;
      for iCls = 1:nCls
        pbs = obj.predictblocks(iCls);
        switch obj.classifiertype{iCls},
          case {'boosting','fancyboosting'}
            for ndx = 1:numel(pbs.t0)
              curex = pbs.expi(ndx);
              flies = pbs.flies(ndx);
              numcurex = nnz(pbs.expi(:)==curex & pbs.flies(:)==flies);
              numcurexdone = nnz(pbs.expi(1:ndx)==curex & pbs.flies(1:ndx)==flies);
              obj.SetStatus('Predicting for %s: exp %s fly %d ... %d%% done',...
                obj.labelnames{iCls},obj.expnames{curex},flies,round(100*numcurexdone/numcurex));
              obj.PredictFast(curex,flies,pbs.t0(ndx),pbs.t1(ndx),iCls);
            end
        end
      end
      
      obj.NormalizeScores(zeros(nCls,0));
      obj.ApplyPostprocessing();
      obj.ClearStatus();
            
      % transfer to predictidx for current fly
      if ~isempty(obj.expi) && obj.expi > 0 && ~isempty(obj.flies) && all(obj.flies > 0),
        obj.UpdatePredictedIdx();
      end
      
    end
    
    
    % ---------------------------------------------------------------------
    function SetTrainingData(obj,trainingdata)  %#ok
    % SetTrainingData(obj,trainingdata)
    % Sets the labelidx_cur of windowdata based on the input training data.
    % This reflects the set of labels the classifier was last trained on. 
      return;
%       for i = 1:numel(trainingdata),
%         [ism,labelidx] = ismember(trainingdata(i).names,obj.labelnames);
%         if any(~ism),
%           tmp = unique(trainingdata(i).names(~ism));
%           error('Unknown labels %s',sprintf('%s ',tmp{:})); %#ok<SPERR>
%         end
%         isexp = obj.windowdata.exp == i;
%         for j = 1:numel(trainingdata(i).t0s),
%           t0 = trainingdata(i).t0s(j);
%           t1 = trainingdata(i).t1s(j);
%           l = labelidx(j);
%           flies = trainingdata(i).flies(j,:);
%           isflies = isexp & all(bsxfun(@eq,obj.windowdata.flies,flies),2);
%           ist = isflies & obj.windowdata.t >= t0 & obj.windowdata.t < t1;
%           if nnz(ist) ~= (t1-t0),
%             uiwait(warndlg('Labels in the classifier do not match the training data'));
%           end
%           obj.windowdata.labelidx_cur(ist) = l;
%         end
%       end
    end  % method

    
%    % ---------------------------------------------------------------------
%    function trainingdata = SummarizeTrainingData(obj)
%    % trainingdata = SummarizeTrainingData(obj)
%    % Summarize labelidx_cur into trainingdata, which is similar to the
%    % form of labels.
%      
%      trainingdata = struct('t0s',{},'t1s',{},'names',{},'flies',{});
%      waslabeled = obj.windowdata.labelidx_cur;
%      for expi = 1:obj.nexps,
%        trainingdata(expi) = struct('t0s',[],'t1s',[],'names',{{}},'flies',[]);
%        isexp = waslabeled & obj.windowdata.exp == expi;
%        if ~any(isexp),
%          continue;
%        end
%        fliess = unique(obj.windowdata.flies(isexp,:),'rows');
%        for fliesi = 1:size(fliess,1),
%          flies = fliess(fliesi,:);
%          isflies = isexp & all(bsxfun(@eq,obj.windowdata.flies,flies),2);
%          labelidxs = setdiff(unique(obj.windowdata.labelidx_cur(isflies)),0);
%          for labelidxi = 1:numel(labelidxs),
%            labelidx = labelidxs(labelidxi);
%            islabel = isflies & labelidx == obj.windowdata.labelidx_cur;
%            ts = sort(obj.windowdata.t(islabel));
%            breaks = find(ts(1:end-1)+1~=ts(2:end));
%            t1s = ts(breaks)+1;
%            t0s = ts(breaks+1);
%            t0s = [ts(1);t0s];%#ok<AGROW>
%            t1s = [t1s;ts(end)+1];%#ok<AGROW>
%            n = numel(t0s);
%            trainingdata(expi).t0s(end+1:end+n,1) = t0s;
%            trainingdata(expi).t1s(end+1:end+n,1) = t1s;
%            trainingdata(expi).names(end+1:end+n,1) = repmat(obj.labelnames(labelidx),[%1,n]);
%            trainingdata(expi).flies(end+1:end+n,:) = repmat(flies,[n,1]);
%          end
%        end
%      end
%    end  % method

    
    % ---------------------------------------------------------------------
    function FindFastPredictParams(obj)
      obj.fastPredict = Predict.fastPredictInit(obj.fastPredict,...
        obj.classifier,obj.classifierTS,{obj.windowdata.featurenames}); 
    end
    
    % ---------------------------------------------------------------------
    %function FindWfidx(obj,iCls,feature_names)
    %  obj.fastPredict(iCls) = Predict.fastPredictFindWfidx(obj.fastPredict(iCls),feature_names);     
    %end
    
    
    % ---------------------------------------------------------------------
    function finished = WindowDataPredictFast(obj,expi,flies,clsIdx,t0,t1)
      % Try to predict all classifiers using data cached in windowdata.
      %
      % clsIdx: index of classifier to predict
      % 
      % Effect: update obj.predictdata{expi}{flies}(:) for t0:t1, as 
      % possible. This method will do a partial update.   
      %
      % finished: logical scalar. finished is true if classifier clsIdx
      % is fully predicted over t0:t1. finished will be false if there is a 
      % single timepoint in t0:t1 which is not
      % predicted.
      
      % MERGESTUPDATED 
 
      assert(isscalar(clsIdx) && any(clsIdx==1:obj.nclassifiers));

      finished = false;
      windata = obj.windowdata(clsIdx);
      
      if isempty(windata.exp)
        return;
      end
      idxfly = find(windata.exp == expi & all(bsxfun(@eq,windata.flies,flies),2));
      if isempty(idxfly)
        return;
      end
      
      % ism(i) is whether there is windowdata for t0+i-1
      % idxfly(idx1(i)) is which index of windowdata corresponds to t0+i-1
      [ism,idx1] = ismember(t0:t1,windata.t(idxfly));
      idxism = find(ism);
      if isempty(idxism)
        return;
      end
      % idx(i) is the index into windowdata for t0+idxism(i)-1
      idx = idxfly(idx1(idxism));
      
      % run the classifier: scores(i) is the score for t0+idxism(i)-1
      scores = myBoostClassify(windata.X(idx,:),obj.classifier{clsIdx});
      
      % store in predictdata
      % predictism(i) is whether t0+idxism(i)-1 is in predictdata
      % predictidx(i) is the location in predictdata{expi}{flies} of
      % t0+idxism-1
      [predictism,predictidx] = ismember(t0+idxism-1,obj.predictdata{expi}{flies}(clsIdx).t);
      assert(all(predictism),'There are ts requested that are not in predictdata');
      obj.predictdata{expi}{flies}(clsIdx).cur(predictidx) = scores;
      obj.predictdata{expi}{flies}(clsIdx).timestamp(predictidx) = obj.classifierTS(clsIdx);
      obj.predictdata{expi}{flies}(clsIdx).cur_valid(predictidx) = true;
      
      finished = all(ism);
      % Even if finished==false, predictdata may be updated
    end
      
    
    % ---------------------------------------------------------------------
    function didpredict = PredictFast(obj,expi,flies,t0,t1,clsIdx)
    % Predict fast by computing only the required window features.
    %
    % clsIdx: vector of classifier indices to predict. If not specified,
    % clsIdx is equal to 1:obj.nclassifiers.
    %
    % Effect: update obj.predictdata{expi}{flies}(:) for t0:t1
    % Side Effects: update predictblocks, fastPredict
    %
    % didpredict: true if any (new) predictions were generated

    % MERGESTUPDATED
          
      nCls = obj.nclassifiers;
      if ~exist('clsIdx','var')
        clsIdx = 1:nCls;
      end
      
      didpredict = false; 
      
      if isempty(obj.classifier) || t0>t1
        return;
      end
      
      % Determine which behaviors/classifiers need predicting;
      pdArr = obj.predictdata{expi}{flies};
      for i = numel(clsIdx):-1:1
        pd = pdArr(clsIdx(i));
        idxcurr_t = pd.t>=t0 & pd.t<=t1;
        if all(pd.cur_valid(idxcurr_t))
          clsIdx(i) = [];
        end
      end   
      if isempty(clsIdx)
        return; 
      end
      
      didpredict = true;
      
      % Try WindowDatapredictFast
      for i = numel(clsIdx):-1:1
        finished = obj.WindowDataPredictFast(expi,flies,clsIdx(i),t0,t1);
        % ALTODO: optimization, WindowDataPredictFast might have
        % successfully predicted a lot of t0:t1
        if finished
          clsIdx(i) = [];
        end
      end
      if isempty(clsIdx)
        return;
      end
      
      %%% Full Prediction      
      if isempty(obj.fastPredict(1).classifier)
        obj.FindFastPredictParams();
      end
      
      perframeInMemory = ~isempty(obj.flies) && obj.IsCurFly(expi,flies);
      perframefile = obj.GetPerframeFiles(expi);
      for iCls = clsIdx(:)'      
        % There is at least one frame in t0:t1 that does not have a
        % current prediction. We
        % are going to predict on all frames in [t0,t1] even though some may
        % already have current predictions.
        %
        % ALTODO: Optimization, be smarter about not repredicting everything.
        
        % Initialize missingts, ts which need new prediction
        
        obj.SetStatus('Predicting for classifier %s...',obj.labelnames{iCls});
        
        pd = pdArr(iCls);
        missingts = pd.t(pd.t>=t0 & pd.t<=t1);
        nmissingts = inf;        
        
        while true
                    
          % - Choose a frame missing window data
          % - Try to use an existing predict block if available

          t = missingts(1);
          curblockndx = obj.predictblocks(iCls).expi==expi & obj.predictblocks(iCls).flies==flies;
          curbs_t0 = obj.predictblocks(iCls).t0(curblockndx);
          curbs_t1 = obj.predictblocks(iCls).t1(curblockndx);
          
          if ~isempty(curbs_t0) && any((t-curbs_t0)>=0 & (t-curbs_t1)<=0) && ...
              t1-t0 > 2*obj.predictwindowdatachunk_radius-2,
            % AL: For second condition, don't we really want
            % curbs_t1-curbs_t0 > 2*radius-2 etc?
            tempndx = find( (t-curbs_t0)>=0 & (t-curbs_t1)<=0 );
            t0 = curbs_t0(tempndx(1));
            t1 = curbs_t1(tempndx(1));
          else
            t = median(missingts);
            if ~ismember(t,missingts),
              t = missingts(argmin(abs(t-missingts)));
            end
            
            % bound at start and end frame of these flies
            T0 = max(obj.GetTrxFirstFrame(expi,flies));
            T1 = min(obj.GetTrxEndFrame(expi,flies));
            
            t1 = min(t+obj.predictwindowdatachunk_radius,T1);
            % go backward 2*r to find the start of the chunk
            t0 = max(t1-2*obj.predictwindowdatachunk_radius,T0);
            % go forward 2*r again to find the end of the chunk
            t1 = min(t0+2*obj.predictwindowdatachunk_radius,T1);
            
            
            % Find blocks that overlap with the current interval and merge
            % them into one block.
            overlapping_blocks1 = find(curbs_t0-t0 >= 0 & curbs_t0-t1 <= 0); %
            overlapping_blocks2 = find(curbs_t1-t0 >= 0 & curbs_t0-t1 <= 0); % ALXXX MINIMAL: intend curbs_t1 in both terms?
            overlapping_blocks = unique([overlapping_blocks1(:);overlapping_blocks2(:)]);
            if ~isempty(overlapping_blocks),
              t0 = min(t0,min(curbs_t0(overlapping_blocks)));
              t1 = max(t1,max(curbs_t1(overlapping_blocks)));
              todelete = find(curblockndx);
              todelete = todelete(overlapping_blocks);
              obj.predictblocks(iCls).t0(todelete) = [];
              obj.predictblocks(iCls).t1(todelete) = [];
              obj.predictblocks(iCls).flies(todelete) = [];
              obj.predictblocks(iCls).expi(todelete) = [];
            end
            %             overlap_start = find( (t0-curbs_t0)>=0 & (t0-curbs_t1)<=0);
            %             if ~isempty(overlap_start),
            %               t0 = max(curbs_t1(overlap_start))+1;
            %             end
            %
            %             overlap_end = find( (t1-curbs_t0)>=0 & (t1-curbs_t1)<=0);
            %             if ~isempty(overlap_end),
            %               t1 = max(curbs_t0(overlap_end))-1;
            %             end
            
            if t0 <= t1,
              obj.predictblocks(iCls).t0(end+1) = t0;
              obj.predictblocks(iCls).t1(end+1) = t1;
              obj.predictblocks(iCls).expi(end+1) = expi;
              obj.predictblocks(iCls).flies(end+1) = flies;
            else
              warning('Trying to add interval to predict with t0 = %d > t1 = %d, not doing this. MAYANK, IS THIS RIGHT??',t0,t1);
            end
          end
          
          % - Range of prediction [t0,t1] has been updated
          % - obj.predictblocks(iCls) has been updated as necessary to 
          % include a block spanning precisely [t0,t1] (possibly merging blocks etc)
          
          i0 = t0 - obj.GetTrxFirstFrame(expi,flies) + 1;
          i1 = t1 - obj.GetTrxFirstFrame(expi,flies) + 1;          
          
          X = [];
          
          %%% Compute window features
          perframedata_cur = obj.perframedata;
          allperframefns = obj.allperframefns;
          windowfeaturescellparams = obj.fastPredict(iCls).windowfeaturescellparams;
          pffs = obj.fastPredict(iCls).pffs;
          feature_names_list = cell(1,numel(pffs));
          x_curr_all = cell(1,numel(pffs));
          
          try
            parfor j = 1:numel(pffs),
              
              fn = pffs{j};
              
              ndx = find(strcmp(fn,allperframefns));
              if perframeInMemory,
                perframedata = perframedata_cur{ndx};  %#ok
              else
                perframedata = load(perframefile{ndx});  %#ok
                perframedata = perframedata.data{flies(1)};  %#ok
              end
              
              i11 = min(i1,numel(perframedata));
              [x_curr,cur_f] = ...
                ComputeWindowFeatures(perframedata,...
                windowfeaturescellparams.(fn){:},'t0',i0,'t1',i11);  %#ok
              
              if i11 < i1,
                x_curr(:,end+1:end+i1-i11) = nan;
              end
              
              x_curr_all{j} = single(x_curr);
              feature_names_list{j} = cur_f;
            end  % parfor
            
          catch ME,
            
            uiwait(warndlg(sprintf('Could not predict:%s',ME.message)));
            
          end
          
          % Passing on to next stage: x_curr_all, feature_names_list
          
          % Form feature matrix X          
          for j = 1:numel(pffs),
            fn = pffs{j};
            x_curr = x_curr_all{j}; % will be empty if err occurred
            % add the window data for this per-frame feature to X
            nold = size(X,1);
            nnew = size(x_curr,2);
            if nold > nnew,
              warning(['Number of examples for per-frame feature %s does not '...
                'match number of examples for previous features'],fn);
              x_curr(:,end+1:end+nold-nnew) = nan;
            elseif nnew > nold && ~isempty(X),
              warning(['Number of examples for per-frame feature %s does not '...
                'match number of examples for previous features'],fn);
              X(end+1:end+nnew-nold,:) = nan;
            end
            X = [X,x_curr']; %#ok<AGROW>
          end
          
          if ~obj.fastPredict(iCls).wfidx_valid,
            feature_names = {};
            for ndx = 1:numel(feature_names_list)
              fn = pffs{ndx};
              feature_names = [feature_names,cellfun(@(s) [{fn},s],...
                feature_names_list{ndx},'UniformOutput',false)]; %#ok<AGROW>
            end
            obj.fastPredict(iCls) = Predict.fastPredictFindWfidx(obj.fastPredict(iCls),feature_names);
            assert(obj.fastPredict(iCls).wfidx_valid);
          end
          
          scores = myBoostClassify(X(:,obj.fastPredict(iCls).wfidx),obj.fastPredict(iCls).classifier);
          
          curndx = obj.predictdata{expi}{flies}(iCls).t>=t0 & ...
                   obj.predictdata{expi}{flies}(iCls).t<=t1;
          obj.predictdata{expi}{flies}(iCls).cur(curndx) = scores;
          obj.predictdata{expi}{flies}(iCls).timestamp(curndx) = obj.classifierTS(iCls);
          obj.predictdata{expi}{flies}(iCls).cur_valid(curndx) = true;
          
          missingts(missingts >= t0 & missingts <= t1) = [];
          
          if isempty(missingts),
            break;
          end
          
          nmissingtsnew = numel(missingts);
          if nmissingtsnew >= nmissingts,
            errordlg('Sanity check: Number of frames missing window features did not decrease. Breaking out of loop.');
            break;
          end
          nmissingts = nmissingtsnew;
        end
      end
      
      obj.ClearStatus();
    end
    
    
% Evaluating performance
    

    % ---------------------------------------------------------------------
    function errorRates = createConfMat(obj,iCls,scores,modLabels)
      % iCls: classifier index
      % scores: vector 
      % modLabels: label vector for scores with values as follows:
      %   1: lbl1+important
      %   2: lbl1+notimportant
      %   3: lbl2+important
      %   4: lbl2+notimportant
      % errorRates: .numbers, .frac: 4x3 arrays. rows are labeled:
      %   row1: lbl1+important
      %   row2: lbl1+any, ie lbl1+(important or notimportant)
      %   row3: lbl2+important
      %   row4: lbl2+any
      
      %MERGESTUPDATED
      
      % AL: This method is a little awkward in that the original intent 
      % appears to have been to handle more than two labels/behaviors;
      % for now we are explicitly specifying a classifier index and
      % assuming only two label/behavior types in modLabels.      
      
      assert(isvector(scores) && isvector(modLabels) ...
        && numel(scores)==numel(modLabels));
      
      scoreNorm = obj.windowdata(iCls).scoreNorm;
      if isempty(scoreNorm) || isnan(scoreNorm)
        scoreNorm = 0;
      end
      confThresholds = obj.confThresholds(iCls,:);
    
      NBEH = 2;
      confMat = zeros(2*NBEH,3);
      for ndx = 1:2*NBEH
        if mod(ndx,2)
          curIdx = modLabels==ndx;
        else
          % either ndx or ndx-1; or lblN for both important and
          % nonimportant
          curIdx = modLabels>(ndx-1.5) & modLabels<(ndx+0.5);
        end
        confMat(ndx,1) = nnz( scores(curIdx)>= (confThresholds(1)*scoreNorm)); 
        confMat(ndx,2) = nnz(-scores(curIdx)<  (confThresholds(2)*scoreNorm) & ...
                              scores(curIdx)<  (confThresholds(1)*scoreNorm) );
        confMat(ndx,3) = nnz(-scores(curIdx)>= (confThresholds(2)*scoreNorm));
      end
      
      errorRates = struct();
      errorRates.numbers = confMat;
      errorRates.frac = errorRates.numbers./repmat( sum(errorRates.numbers,2),[1 3]);
    end

    
    % ---------------------------------------------------------------------
    function bouts = getLabeledBouts(obj,iCls)
    % Find window data for labeled bouts.
    %
    % bouts
    % .ndx: nBout-by-nsamp logical. bouts.ndx(iBout,:) indexes obj.windowdata(iCls).t etc
    % .label: 1-by-nBout vector of 1/2 for positive/negative lbls for this classifier
    % .timestamp: 1-by-nBout vector
        
    %MERGESTUPDATED
    
      bouts = struct('ndx',[],'label',[],'timestamp',[]);
      
      wd = obj.windowdata(iCls);
      clsLblNames = obj.iCls2LblNames{iCls};
      % clsLblNames = {posLbl negLbl}
      
      for expNdx = 1:obj.nexps
        for flyNdx = 1:obj.nflies_per_exp(expNdx)
          
          labelsShort = obj.GetLabels(expNdx,flyNdx);
          nBout = numel(labelsShort.t0s);
          tfFlyNdx = obj.FlyNdx(expNdx,flyNdx,iCls);
          for iBout = 1:nBout
            tfClsLbl = strcmp(labelsShort.names{iBout},clsLblNames);
            if any(tfClsLbl)
              idx = tfFlyNdx & ...
                wd.t >= labelsShort.t0s(iBout) & ...
                wd.t < labelsShort.t1s(iBout) & ...
                wd.labelidx_imp;
              if ~all(wd.labelidx_new(idx))
                continue;
              end
              bouts.ndx(end+1,:) = idx;
              bouts.label(1,end+1) = find(tfClsLbl); % 1/2 for posLbl/negLbl resp
              bouts.timestamp(1,end+1) = labelsShort.timestamp(iBout);
            end
          end
        end
      end      
    end

    
%     % ---------------------------------------------------------------------
%     function bouts = GetLabeledBouts_KB(obj)
%       
%       bouts = struct('t0s',[],'t1s',[],'flies',[],'expis',[],'timestamps',[],'names',{{}});
%       for expi = 1:numel(obj.labels),
%         for flyi = 1:size(obj.labels(expi).flies,1),
%           flies = obj.labels(expi).flies(flyi,:);
%           t0s = obj.labels(expi).t0s{flyi};
%           t1s = obj.labels(expi).t1s{flyi};
%           if isempty(t0s),
%             continue;
%           end
%           n = numel(t0s);
%           bouts.t0s(end+1:end+n) = t0s;
%           bouts.t1s(end+1:end+n) = t1s;
%           bouts.flies(end+1:end+n,:) = flies;
%           bouts.expis(end+1:end+n) = expi;
%           bouts.timestamps(end+1:end+n) = obj.labels(expi).timestamp{flyi};
%           bouts.names(end+1:end+n) = obj.labels(expi).names{flyi};
%         end
%       end
%       
%     end  % method
    
    
 % Window data computation.
    % ---------------------------------------------------------------------
    function InitPredictionData(obj,expi)
      % Dimensions the predictions for experiment expi.

      % MERGESTOK
      
      % Create the cell array for this exeriment
      nTargets = obj.nflies_per_exp(expi);
      obj.predictdata{expi} = cell(1,nTargets);
      
      % Don't need to pre-allocate the fields in a structure array.
      % I benchmarked it to be sure ---It's slightly faster without this
      % code.  --ALT, Apr 17 2013
%       % For each target, put a scalar struct in that cell array element,
%       % with the proper fields, but empty values
%       for iTarget = 1:nTargets
%         obj.predictdata{expi}{iTarget} = ...
%           struct('t',[],...
%                  'cur',[], ...
%                  'cur_valid', logical([]), ...
%                  'cur_pp',[], ...
%                  'old',[], ...
%                  'old_valid',logical([]), ...
%                  'old_pp',[],...
%                  'loaded',[], ...
%                  'loaded_valid',logical([]), ...
%                  'loaded_pp',[],...
%                  'timestamp',[]);
%       end

      nTL = obj.ntimelines;
            
      % For each target, and each field in the scalar struct, set it to a
      % double or logical array of the proper length.  Set all double
      % values to nan, all logical value to false.
      for iTarget = 1:obj.nflies_per_exp(expi)
        firstframe = obj.firstframes_per_exp{expi}(iTarget);
        endframe = obj.endframes_per_exp{expi}(iTarget);
        nframes = endframe-firstframe+1;
        nanArray = nan(1,nframes);
        falseArray = false(1,nframes);
        
        for i = 1:nTL
          obj.predictdata{expi}{iTarget}(i).t = (firstframe:endframe);
          obj.predictdata{expi}{iTarget}(i).cur = nanArray;
          obj.predictdata{expi}{iTarget}(i).cur_pp = nanArray;
          obj.predictdata{expi}{iTarget}(i).cur_valid = falseArray;
          obj.predictdata{expi}{iTarget}(i).old = nanArray;
          obj.predictdata{expi}{iTarget}(i).old_pp = nanArray;
          obj.predictdata{expi}{iTarget}(i).old_valid = falseArray;
          obj.predictdata{expi}{iTarget}(i).loaded = nanArray;
          obj.predictdata{expi}{iTarget}(i).loaded_pp = nanArray;
          obj.predictdata{expi}{iTarget}(i).loaded_valid = falseArray;
          obj.predictdata{expi}{iTarget}(i).timestamp = nanArray;
        end
      end
    end


    % ---------------------------------------------------------------------
    function object = createPreLoadWindowDataObj(obj,expi,flies,iCls)
      % create a simple struct for PreLoadWindowData, which is parfor-ed
      
      obj.CheckExp(expi); 
      obj.CheckFlies(flies);

      object = struct();
      object.isempty_fieldnames_windowfeaturesparams = isempty(fieldnames(obj.windowfeaturesparams{iCls})); % ALTODO can almost definitely be removed
      object.GetTrxFirstFrame = obj.GetTrxFirstFrame(expi,flies);
      object.GetTrxEndFrame = obj.GetTrxEndFrame(expi,flies);
      object.windowdatachunk_radius = obj.windowdatachunk_radius;
      object.not_isempty_windowdata_exp = ~isempty(obj.windowdata(iCls).exp);
      object.windowdata_t_flyndx = obj.windowdata(iCls).t(obj.FlyNdx(expi,flies,iCls));
      %object.gettrxfirstframe = obj.GetTrxFirstFrame(expi,flies);
      object.curperframefns = obj.curperframefns{iCls};
      object.allperframefns = obj.allperframefns;
      object.perframefile = obj.GetPerframeFiles(expi);
      object.windowfeaturescellparams = obj.windowfeaturescellparams{iCls};
      
      % ALTODO factor this out (see also ComputeWindowDataChunk) into eg ensurePerFrameFiles.
      % Call the result before calling createPreLoadWindowDataObj. This
      % should also eliminate perframefn consistency issues in caller
      % (Preloadperi)
      for j = 1:numel(object.curperframefns)
        fn = object.curperframefns{j};

        % get per-frame data
        ndx = find(strcmp(fn,object.allperframefns));
        assert(~isempty(ndx),...
          'Internal error: There is at least one per-frame feature in the vocabulary (%s) that is not in the subdialect.',fn);

        if ~exist(object.perframefile{ndx},'file'),
          if ~isdeployed 
            if isempty(obj.GetGenerateMissingFiles())
              res = questdlg(sprintf(['Experiment %s is missing some perframe files '...
                '(%s, possibly more). Generate now?'],obj.expnames{expi},object.perframefile{ndx}),...
                'Generate missing files?','Yes','Cancel','Yes');
              if strcmpi(res,'Yes');
                obj.SetGenerateMissingFiles();
              end
            else 
              res = fif(obj.GetGenerateMissingFiles(),'Yes','No');
            end
          else
            res = 'Yes';
          end

          if strcmpi(res,'Yes'),
            for ndx = 1:obj.nexps  
              [success1,msg1] = obj.GenerateMissingFiles(ndx);
              if ~success1
                error(msg1);
              end
            end
          else
            error('Cannot compute window data for %s.',obj.expnames{expi});
          end
        end
      end
    end
      
    function SetWindowFeatureNames(obj)
      % set windowdata.featurenames based on obj.curperframefns and
      % obj.windowfeaturescellparams.
      
      % MERGESTUPDATED

      obj.SetStatus('Setting window feature names...');
      
      FAKEPFDATA = zeros(1,101);

      nclassifiers = obj.nclassifiers;
      for iCls = 1:nclassifiers
        
        %wfparams = obj.windowfeaturesparams{iCls};
        wfcparams = obj.windowfeaturescellparams{iCls};
        curPFFs = obj.curperframefns{iCls};
        Ncpff = numel(curPFFs);
        
%         if isempty(fieldnames(wfparams))
%           feature_names = {cell(1,0)};
%           % msg = 'No features selected';
%           % obj.ClearStatus();
%           % return;
%         else        
        feature_names = cell(1,Ncpff);
        for j = 1:Ncpff
          fn = curPFFs{j};
          [~,tmp_feature_names_all] = ...
            ComputeWindowFeatures(FAKEPFDATA,wfcparams.(fn){:},'t0',51,'t1',51);
          feature_names{j} = cellfun(@(s) [{fn},s],tmp_feature_names_all,'UniformOutput',false);
        end
%         end

        feature_names = [feature_names{:}];
        if isempty(feature_names)
          feature_names = cell(1,0);
        end
        obj.windowdata(iCls) = WindowData.windowdataSetFeaturenames(...
          obj.windowdata(iCls),{feature_names});
      end
        
      obj.ClearStatus();

    end  % method
      
    function [success,msg,t0,t1,X,feature_names] = ComputeWindowDataChunk(obj,expi,flies,t,mode,forceCalc)
    % [success,msg,t0,t1,X,feature_names] = ComputeWindowDataChunk(obj,expi,flies,t)
    % Computes a chunk of windowdata near frame t for experiment expi and
    % flies flies. if mode is 'start', then the chunk will start at t. if
    % it is 'center', the chunk will be centered at t. if mode is 'end',
    % the chunk will end at t. by default, mode is 'center'. 
    % t0 and t1 define the bounds of the chunk of window data computed. X
    % is the nframes x nfeatures window data, feature_names is a cell array
    % of length nfeatures containing the names of each feature. 
    %
    % This function first chooses an interval of frames around t, depending 
    % on the mode. it then chooses a subinterval of this interval that
    % covers all frames in this interval that do not have window data. This
    % defines t0 and t1. 
    % 
    % It then loops through all the per-frame features, and calls
    % ComputeWindowFeatures to compute all the window data for that
    % per-frame feature. 
    %
    % To predict over the whole movie we use forceCalc which
    % forces the function to recalculate all the features even though they
    % were calculated before.
      
    %ALXXX EXTENDED. Called only by SimilarFrames, Bagging
    
      success = false; msg = '';  %#ok
      
      if ~exist('mode','var'), mode = 'center'; end
      if ~exist('forceCalc','var'), forceCalc = false; end
      
      % Check if the features have been configured.
      % I really don't like this.  The JLabelData is pretty close to being a
      % model in the MVC sense.  As such, it shouldn't be creating a view.
      % Not clear to me what the best way to fix this is, though.
      % --ALT, Feb 4, 2013
      if isempty(fieldnames(obj.windowfeaturesparams))
        figureJLabel=findall(0,'tag','figure_JLabel');
        figureSelectFeatures=SelectFeatures(figureJLabel);
        uiwait(figureSelectFeatures);
        if isempty(fieldnames(obj.windowfeaturesparams))
          error('No features selected!');
        end
      end
      
      % choose frames to compute:
      
      % bound at start and end frame of these flies
      T0 = max(obj.GetTrxFirstFrame(expi,flies));
      T1 = min(obj.GetTrxEndFrame(expi,flies));
      
      switch lower(mode),
        case 'center',
          % go forward r to find the end of the chunk
          t1 = min(t+obj.windowdatachunk_radius,T1);
          % go backward 2*r to find the start of the chunk
          t0 = max(t1-2*obj.windowdatachunk_radius,T0);
          % go forward 2*r again to find the end of the chunk
          t1 = min(t0+2*obj.windowdatachunk_radius,T1);
        case 'start',
          t0 = max(t,T0);
          t1 = min(t0+2*obj.windowdatachunk_radius,T1);
        case 'end',
          t1 = min(t,T1);
          t0 = max(t1-2*obj.windowdatachunk_radius,T0);
        otherwise
          error('Unknown mode %s',mode);
      end
      
      % find a continuous interval that covers all uncomputed ts between t0
      % and t1
      off = 1-t0;
      n = t1-t0+1;
      docompute = true(1,n);
      if ~isempty(obj.windowdata.exp) && ~forceCalc,
        tscomputed = obj.windowdata.t(obj.FlyNdx(expi,flies));
        tscomputed = tscomputed(tscomputed >= t0 & tscomputed <= t1);
        docompute(tscomputed+off) = false;
      end
      
      X = single([]);
      feature_names = {};
      if ~any(docompute),
        t1 = t0-1;
        success = true;
        return;
      end
      
      t0 = find(docompute,1,'first') - off;
      t1 = find(docompute,1,'last') - off;
      i0 = t0 - obj.GetTrxFirstFrame(expi,flies) + 1;
      i1 = t1 - obj.GetTrxFirstFrame(expi,flies) + 1;
      
      %       try
      
      curperframefns = obj.curperframefns;
      allperframefns = obj.allperframefns;
      perframeInMemory = ~isempty(obj.flies) && obj.IsCurFly(expi,flies);
      perframedata_all = obj.perframedata;
      perframefile = obj.GetPerframeFiles(expi);
      x_curr_all = cell(1,numel(curperframefns));
      feature_names_all = cell(1,numel(curperframefns));
      windowfeaturescellparams = obj.windowfeaturescellparams;
      
      % loop through per-frame fields to check that they exist.
      % ALTODO: factor this out, see createPreLoadWindowDataObj
      for j = 1:numel(curperframefns),
        fn = curperframefns{j};        
        
        % get per-frame data
        ndx = find(strcmp(fn,allperframefns));
        if isempty(ndx),
          success = false;
          msg = sprintf('Internal error: There is at least one per-frame feature in the vocabulary (%s) that is not in the subdialect.',fn);
          return;
        end
        
        if ~exist(perframefile{ndx},'file'),
          if ~isdeployed 
            if isempty(obj.GetGenerateMissingFiles())
              res = questdlg(sprintf(['Experiment %s is missing some perframe files '...
                '(%s, possibly more). Generate now?'],obj.expnames{expi},perframefile{ndx}),...
                'Generate missing files?','Yes','Cancel','Yes');
              if strcmpi(res,'Yes');
                obj.SetGenerateMissingFiles();
              end
            else 
              res = fif(obj.GetGenerateMissingFiles(),'Yes','No');
            end
          else
            res = 'Yes';
          end
          
          if strcmpi(res,'Yes'),
            for ndx = 1:obj.nexps  
              [success1,msg1] = obj.GenerateMissingFiles(ndx);
              if ~success1,
                success = success1; msg = msg1;
                return;
              end
            end
            
          else
            success = false;
            msg = sprintf('Cannot compute window data for %s ',obj.expnames{expi});
            return;
          end

          
        end
        
      end
      
      parfor j = 1:numel(curperframefns),
      %for j = 1:numel(curperframefns),
        fn = curperframefns{j};
%        fprintf('Computing window data for per-frame feature %d: %s\n',j,fn);
        
        % get per-frame data
        ndx = find(strcmp(fn,allperframefns));
        if perframeInMemory,
          perframedata = perframedata_all{ndx};  %#ok
        else
          perframedata = load(perframefile{ndx});  %#ok
          perframedata = perframedata.data{flies(1)};  %#ok
        end
        
        i11 = min(i1,numel(perframedata));
        [x_curr,feature_names_curr] = ...
          ComputeWindowFeatures(perframedata,windowfeaturescellparams.(fn){:},'t0',i0,'t1',i11);  %#ok
        if any(imag(x_curr(:)))
          fprintf('Feature values are complex, check input\n');
        end
        
        if i11 < i1,
          x_curr(:,end+1:end+i1-i11) = nan;
        end
        
        x_curr_all{j} = single(x_curr);
        feature_names_all{j} = feature_names_curr;
        
      end
      
      feature_names=cell(1,numel(curperframefns));
      for j = 1:numel(curperframefns),
        fn = curperframefns{j};
        x_curr = x_curr_all{j};
        feature_names_curr = feature_names_all{j};
        % add the window data for this per-frame feature to X
        nold = size(X,1);
        nnew = size(x_curr,2);
        if nold > nnew,
          warning(['Number of examples for per-frame feature %s does not match number '...
            'of examples for previous features'],fn);
          x_curr(:,end+1:end+nold-nnew) = nan;
        elseif nnew > nold && ~isempty(X),
          warning(['Number of examples for per-frame feature %s does not match number '...
            'of examples for previous features'],fn);
          X(end+1:end+nnew-nold,:) = nan;
        end
        X(:,end+1:end+size(x_curr,1)) = x_curr';
        % add the feature names
        if nargout>5
          feature_names{j} = cellfun(@(s) [{fn},s],feature_names_curr,'UniformOutput',false); %#ok<AGROW>
        end
      end
      feature_names=[feature_names{:}];
      %       catch ME,
      %         msg = getReport(ME);
      %         return;
      %       end
      %X = single(X);
      success = true;
     
    end  % method    
   
    % ---------------------------------------------------------------------
    function initWindowData(obj)
      % Inits windowdata and predictblocks. Clears predictions.
      
      %MERGESTUPDATED

      obj.windowdata = WindowData.windowdata(obj.nclassifiers);
      obj.predictblocks = Predict.predictblocks(obj.nclassifiers);      
      obj.UpdatePredictedIdx();
    end
    
    % ---------------------------------------------------------------------
    function [success,msg] = PreLoadPeriLabelWindowData(obj)
      % [success,msg] = PreLoadPeriLabelWindowData(obj)
      % This function precomputes any missing window data for all labeled
      % training examples by calling PreLoadWindowData on all labeled frames.
      %
      % Effect: Update obj.predictblocks, obj.windowdata
      % SideEffect: In obscure situations, obj.curperframefns can get
      % updated
      
      %MERGESTUPDATED
      
      for expi = 1:obj.nexps
        for iCls = 1:obj.nclassifiers
          
          obj.SetStatus('Computing windowdata for %s: %s',...
            obj.expnames{expi},obj.labelnames{iCls});
          obj.CheckExp(expi);
          
          flies_curr = obj.labels(expi).flies; % labeled flies for this exp (ANY behavior)
          Nfliescurr = size(flies_curr,1);
          
          % load up state for parfor-windowdata computation
          labelIdxVals = cell(1,Nfliescurr); % vectors, labelidx.vals for this exp/fly/classifier
          labelIdxImp = cell(1,Nfliescurr); % vectors, labelidx.imp for this exp/fly/classifier
          labelIdxT0 = cell(1,Nfliescurr); % scalars, labelidx T0 offsets for this exp/fly
          missingts = cell(1,Nfliescurr); % vectors, labeled frames for this classiifer which are not in this classifier's windowdata
          object = cell(1,Nfliescurr); % structs, dummy object for this exp/fly/classifier
          for flyi = 1:Nfliescurr
            flies = flies_curr(flyi,:);  % BJA: is this ever 2-D ?
            obj.CheckFlies(flies);
            
            [labelIdx,labelIdxT0{flyi}] = obj.GetLabelIdx(expi,flies);
            assert(isequal(size(labelIdx.vals,1),size(labelIdx.imp,1),obj.nclassifiers));
            labelIdxVals{flyi} = labelIdx.vals(iCls,:);
            labelIdxImp{flyi} = labelIdx.imp(iCls,:);
            object{flyi} = obj.createPreLoadWindowDataObj(expi,flies,iCls);
            
            % Find all labeled frames for this exp/classifier/fly
            if obj.nclassifiers==1
              % Legacy codepath: build up ts from labels_curr. This should
              % end up the same as labelidxVals{flyi}; assert this to
              % verify.
              ts = zeros(1,0);
              labels_curr = obj.GetLabels(expi,flies);
              for j = 1:numel(labels_curr.t0s),
                ts = [ts,labels_curr.t0s(j):labels_curr.t1s(j)-1]; %#ok<AGROW>
              end
              assert(isequal(sort(ts+labelIdx.off),sort(find(labelIdxVals{flyi}))));
            else
              % Just use labelIdxVals{flyi} and trust that it is the right
              % thing.
              ts = find(labelIdxVals{flyi})-labelIdx.off;
            end
              
            % Determine which frames are missing windowdata
            if isempty(obj.windowdata(iCls).exp)
              missingts{flyi} = ts;
            else
              idxcurr = obj.FlyNdx(expi,flies,iCls);
              tscurr = obj.windowdata(iCls).t(idxcurr); % object{flyi}.windowdata_t_flyndx
              t0_labelidx = labelIdxT0{flyi};
              obj.windowdata(iCls).labelidx_new(idxcurr) = labelIdxVals{flyi}(tscurr-t0_labelidx+1);
              obj.windowdata(iCls).labelidx_imp(idxcurr) = labelIdxImp{flyi}(tscurr-t0_labelidx+1);
              missingts{flyi} = setdiff(ts,tscurr);
            end
          end
          
          curperframefns = obj.curperframefns{iCls};
          allperframefns = obj.allperframefns;
          Ncpff = numel(curperframefns);
          parfor_predictblocks = cell(1,Ncpff); % parfor_predictblocks{perframei}{flyi}
          parfor_windowdata = cell(1,Ncpff); % parfor_windowdata{perframei}{flyi}
          obj_getperframefiles = obj.GetPerframeFiles(expi);
          assert(numel(allperframefns)==numel(obj_getperframefiles));
          
          % AL 20140313 Ensure consistency of curperframefns/allperframefns
          % lists. At the moment there appears to be an obscure potential
          % codepath from CreateObjectForComputeWindowDataChunk to
          % removeArenaPFs which could lead to mutation of the perframefn
          % lists across object{1}, object{2}, etc.
          % ALTODO this will be cleaned up createPreLoadWindowDataObj is
          % factored.
          for flyi = 1:Nfliescurr
            object{flyi}.curperframefns = curperframefns;
            object{flyi}.allperframefns = allperframefns;
          end
          
          parfor perframei = 1:Ncpff
            perframefn = curperframefns{perframei};
            ndx = find(strcmp(perframefn,allperframefns));
            perframedata = load(obj_getperframefiles{ndx}); %#ok
            perframedata = perframedata.data;
            
            parfor_predictblocks{perframei} = cell(1,Nfliescurr);
            parfor_windowdata{perframei} = cell(1,Nfliescurr);
            
            for flyi = 1:Nfliescurr
              flies = flies_curr(flyi,:); %#ok<PFBNS>
              
              [tmpsuccess,~,predictblocks,windowdata] = ...
                PreLoadWindowData(object{flyi},perframefn,perframedata{flies},...
                missingts{flyi},labelIdxVals{flyi},labelIdxImp{flyi},labelIdxT0{flyi}); %#ok<PFBNS>
              assert(tmpsuccess,'Loading windowdata failed for perframe function %s.',perframefn);
              
              if perframei==1
                parfor_predictblocks{perframei}{flyi}.t0 = predictblocks.t0;
                parfor_predictblocks{perframei}{flyi}.t1 = predictblocks.t1;
              end
              parfor_windowdata{perframei}{flyi}.X = windowdata.X;
              parfor_windowdata{perframei}{flyi}.t = windowdata.t;
              parfor_windowdata{perframei}{flyi}.labelidx_new = windowdata.labelidx_new;
              parfor_windowdata{perframei}{flyi}.labelidx_imp = windowdata.labelidx_imp;
            end
          end % perframei
          
          for flyi = 1:Nfliescurr
            flies = flies_curr(flyi,:);
            
            tmp2 = length(parfor_predictblocks{1}{flyi}.t0);
            obj.predictblocks(iCls).expi = [obj.predictblocks(iCls).expi repmat(expi,1,tmp2)];
            obj.predictblocks(iCls).flies = [obj.predictblocks(iCls).flies repmat(flies,1,tmp2)];
            obj.predictblocks(iCls).t0 = [obj.predictblocks(iCls).t0 parfor_predictblocks{1}{flyi}.t0];
            obj.predictblocks(iCls).t1 = [obj.predictblocks(iCls).t1 parfor_predictblocks{1}{flyi}.t1];
            
            tmp = cellfun(@(x) x{flyi}, parfor_windowdata); % should be 1xNcpff struct array
            nframes = size(tmp(1).X,1);
            %ALTODO: How are we assured that the columns of [tmp.X]
            %correspond to the columns of windowdata.X? In fact
            %curperframefns may have mutated during this method...
            obj.windowdata(iCls).X = [obj.windowdata(iCls).X; [tmp.X]];
            obj.windowdata(iCls).exp = [obj.windowdata(iCls).exp; repmat(expi,nframes,1)];
            obj.windowdata(iCls).flies = [obj.windowdata(iCls).flies; repmat(flies,nframes,1)];
            obj.windowdata(iCls).t = [obj.windowdata(iCls).t; tmp(1).t];
            obj.windowdata(iCls).labelidx_cur = [obj.windowdata(iCls).labelidx_cur; zeros(nframes,1)];
            obj.windowdata(iCls).labelidx_new = [obj.windowdata(iCls).labelidx_new; tmp(1).labelidx_new];
            obj.windowdata(iCls).labelidx_imp = [obj.windowdata(iCls).labelidx_imp; tmp(1).labelidx_imp];
            obj.windowdata(iCls).labelidx_old = [obj.windowdata(iCls).labelidx_old; zeros(nframes,1)];
%             obj.windowdata(iCls).predicted = [obj.windowdata(iCls).predicted; zeros(nframes,1)];
%             obj.windowdata(iCls).scores = [obj.windowdata(iCls).scores; zeros(nframes,1)];
%             obj.windowdata(iCls).scores_old = [obj.windowdata(iCls).scores_old; zeros(nframes,1)];
%             obj.windowdata(iCls).scores_validated = [obj.windowdata(iCls).scores_validated; zeros(nframes,1)];
%             obj.windowdata(iCls).postprocessed = [obj.windowdata(iCls).postprocessed; zeros(nframes,1)];
%             obj.windowdata(iCls).isvalidprediction = [obj.windowdata(iCls).isvalidprediction; false(nframes,1)];
            %obj.windowdata(iCls).featurenames = [obj.windowdata(iCls).featurenames tmp(1).featurenames];
          end          
        end % iCls

        % AL: Move outside exp loop?
        obj.windowdata = WindowData.windowdataTrim(obj.windowdata,...
          @(x)x.labelidx_new==0);        
      end % expi
      
      success = true;
      msg = '';
      
      obj.ClearStatus();
    end  % function/method
    
    
    % ---------------------------------------------------------------------
    function UpdateBoostingBins(obj,iCls)
      %MERGESTUPDATED
      islabeled = obj.windowdata(iCls).labelidx_new~=0;
      obj.windowdata(iCls).binVals = findThresholds(obj.windowdata(iCls).X(islabeled,:),...
        obj.classifier_params{iCls},'deterministic',obj.deterministic);
    end
    
    
    % ---------------------------------------------------------------------
    function [successes,msg] = CheckMovies(obj,expis)
    % [successes,msg] = CheckMovies(obj,expis)
    % check that the movie files exist and can be read for the input
    % experiments.
      
      successes = []; msg = '';
      
      if nargin < 2,
        expis = 1:obj.nexps;
      end
      
      if isempty(expis),
        return;
      end
      
      successes = true(1,numel(expis));
      
      if ~obj.ismovie,
        return;
      end
      
      for i = 1:numel(expis),
        moviefilename = obj.GetFile('movie',expis(i));
        obj.SetStatus('Checking movie %s...',moviefilename);
        
        % check for file existence
        if ~exist(moviefilename,'file'),
          successes(i) = false;
          msg1 = sprintf('File %s missing',moviefilename);
          if isempty(msg),
            msg = msg1;
          else
            msg = sprintf('%s\n%s',msg,msg1);
          end
        else
          
          % try reading a frame
%           try
            [readframe,~,movie_fid] = ...
              get_readframe_fcn(moviefilename);
            if movie_fid <= 0,
              error('Could not open movie %s for reading',moviefilename);
            end
            readframe(1);
            fclose(movie_fid);
%           catch ME,
%             successes(i) = false;
%             msg1 = sprintf('Could not parse movie %s: %s',moviefilename,getReport(ME));
%             if isempty(msg),
%               msg = msg1;
%             else
%               msg = sprintf('%s\n%s',msg,msg1);
%             end
%           end
          
        end
      end
      
      obj.ClearStatus();
      
    end  % method
    
    
    % ---------------------------------------------------------------------
    function [success,msg,missingfiles] = UpdateStatusTable(obj,filetypes,expis)
    % [success,msg] = UpdateStatusTable(obj,filetypes,expis)
    % Update the tables of what files exist for what experiments. This
    % returns false if all files were in existence or could be generated
    % and now they are/can not.  It mutates the instance variables
    % fileexists and filetimestamps, and sets filesfixable and
    % allfilesexist.
    %
    % missingfiles: Cell vector of length obj.nexps. Each element is a 
    % cellstr. QUIRKY API: Only missingfiles(expis) are meaningful, 
    % containing missing files for expis. Remaining elements are
    % empty/indeterminate.

      % Initialize return vars
      msg = '';
      success = false;
      missingfiles = cell(1,obj.nexps);
      for i = 1:obj.nexps,
        missingfiles{i} = {};
      end

      % Process arguments
      if ~exist('filetypes','var') || isempty(filetypes)
        filetypes = obj.filetypes;
      end
      if ~exist('expis','var') || isempty(expis)
        expis = 1:obj.nexps;
      end

      % Check that the file types requested are valid
      [fileTypeIsValid,fileTypeIndices] = ismember(filetypes,obj.filetypes);
      if any(~fileTypeIsValid),
        msg = 'Unknown filetypes';
        return
      end

      % Get the file existance and time-stamp tables
      [fileExists,fileTimeStamps,missingFileNames] = ...
        obj.fileOfGivenTypesExistForGivenExps(filetypes,expis);
      
      % Update the state vars accordingly
      obj.fileexists(expis,fileTypeIndices) = fileExists;
      obj.filetimestamps(expis,fileTypeIndices) = fileTimeStamps;
      missingfiles(expis) = missingFileNames;
      
      % store old values to see if latest change broke something
      old_filesfixable = obj.filesfixable;
      old_allfilesexist = obj.allfilesexist;

      % initialize summaries to true
      [allRequiredFilesExist, ...
       missingFilesCanBeGenerated, ...
       oneMissingFileTypeThatCantBeGenerated] = ...
        obj.allRequiredFilesExist(obj.fileexists);
      
      % Write the file status summaries into the object state, and
      % modify the error message if necessary to reflect missing files that
      % cannot be generated.
      obj.allfilesexist = allRequiredFilesExist;
      if allRequiredFilesExist
        obj.filesfixable = true;
      else
        obj.filesfixable = missingFilesCanBeGenerated;
        if ~missingFilesCanBeGenerated
          msg1 = sprintf('%s missing and cannot be generated.',oneMissingFileTypeThatCantBeGenerated);
          if isempty(msg),
            msg = msg1;
          else
            msg = sprintf('%s\n%s',msg,msg1);
          end
        end
      end

      % Modify the error message to reflect missing files for each exp
      nFileNamesMissingTotal = sum(cellfun(@(c)length(c),missingFileNames));
      if nFileNamesMissingTotal>0
        stringForEachExpWithMissingFiles={};        
        for i=1:length(missingFileNames)
          expi=expis(i);
          missingFileNamesThis=missingFileNames{i};
          if ~isempty(missingFileNamesThis)
            stringForEachExpWithMissingFiles{end+1}= ...
              [civilizedStringFromCellArrayOfStrings(missingFileNamesThis) ' from experiment ' obj.expnames{expi}];  %#ok
          end
        end
        msg= [msg ' Missing ' civilizedStringFromCellArrayOfStrings(stringForEachExpWithMissingFiles,';')];
      end
      
      % fail if was ok and now not ok
      success = ~(old_allfilesexist || old_filesfixable) || ...
                 (obj.allfilesexist || obj.filesfixable);      
    end  % method
    
    
    % ---------------------------------------------------------------------
    function [success,msg] = SetTrxFileName(obj,trxfilename)
      % [success,msg] = SetTrxFileName(obj,trxfilename)
      % set the name of the trx file within the experiment directory. this
      % does not currently check for missing/bad trx files, or replace
      % preloaded trx data, so you really shouldn't call it if expdirs are
      % loaded. (TODO)

      success = false;
      msg = '';
      if ischar(trxfilename),
        if ischar(obj.trxfilename) && strcmp(trxfilename,obj.trxfilename),
          success = true;
          return;
        end
        obj.trxfilename = trxfilename;
        [success,msg] = obj.UpdateStatusTable('trx');        
        % TODO: check that trx are parsable, remove bad experiments, update
        % preloaded trx
      end
    end  % method    


    % ---------------------------------------------------------------------
    function StoreLabelsForCurrentAnimal(obj)
      % Store labels cached in labelidx for the current experiment and flies
      % to labels structure. This is when the timestamp on labels gets
      % updated. 
      if isempty(obj.flies) || obj.expi==0 || all(isnan(obj.flies)) || isempty(obj.labelidx.vals),
        return
      end      
      obj.StoreLabelsForGivenAnimal(obj.expi,obj.flies,obj.labelidx,obj.labelidx_off);
    end  % method

    
    % ---------------------------------------------------------------------
    function StoreLabelsForGivenAnimal(obj,expi,flies,labelidx,labelidx_off)
      
      % MERGESTUPDATED
      
      % Write label info to newlabels structure
      % TODO: don't know why writing to intermediate variable rather than obj.labels
      newlabels = struct('t0s',[],'t1s',[],'names',{{}},'flies',[],'timestamp',[],'imp_t0s',[],'imp_t1s',[]);
      assert(isequal(labelidx.labelnames,obj.labelnames));
      assert(labelidx.nbeh==obj.nbehaviors);
      for iTL = 1:labelidx.nTL
        
        % Write bouts
        % ALTODO: Optimization: don't loop over all behaviors/labels, just those relevant
        % to this timeline
        for j = 1:obj.nbehaviors,
          [i0s,i1s] = get_interval_ends(labelidx.vals(iTL,:)==j);          
          if ~isempty(i0s)
            n = numel(i0s);
            newlabels.t0s(end+1:end+n) = i0s - labelidx_off;
            newlabels.t1s(end+1:end+n) = i1s - labelidx_off;
            newlabels.names(end+1:end+n) = repmat(labelidx.labelnames(j),[1,n]);
            newlabels.timestamp(end+1:end+n) = labelidx.timestamp(iTL,i0s); % first frames of bouts
            assert(all(labelidx.timestamp(iTL,i0s)>0),'Label with missing timestamp.');
          end
        end
      end
      % write importance
      if labelidx.nTL==1
        [i0s,i1s] = get_interval_ends(labelidx.imp);
        if ~isempty(i0s)
          newlabels.imp_t0s = i0s - labelidx_off;
          newlabels.imp_t1s = i1s - labelidx_off;
        end
      else
        % ALXXX EXTENDED
        % Multiclassifier importance for GT
      end
      maxtimestamps = max(labelidx.timestamp,[],2); % most recent timestamp each timeline was edited
%       % Store labels according to the mode
%       if obj.IsGTMode(),
%         labelsToUse = 'gt_labels';
%         labelstatsToUse = 'gt_labelstats';
%       else
%         labelsToUse = 'labels';
%         labelstatsToUse = 'labelstats';
%       end
      
      if isempty(obj.labels(expi).flies),
        ism = false;
      else
        [ism,j] = ismember(flies,obj.labels(expi).flies,'rows');
      end
      if ~ism,
        j = size(obj.labels(expi).flies,1)+1;
      end

      obj.labels(expi).t0s{j} = newlabels.t0s;
      obj.labels(expi).t1s{j} = newlabels.t1s;
      obj.labels(expi).names{j} = newlabels.names;
      obj.labels(expi).flies(j,:) = flies;
      obj.labels(expi).off(j) = labelidx_off; % ALTODO: Don't understand, if we have adjusted by labelidx_off above, why are we recording this?
      obj.labels(expi).timestamp{j} = newlabels.timestamp;
      obj.labels(expi).imp_t0s{j} = newlabels.imp_t0s;
      obj.labels(expi).imp_t1s{j} = newlabels.imp_t1s;
      NtimelineTS = numel(obj.labels(expi).timelinetimestamp);
      if NtimelineTS<j
        obj.labels(expi).timelinetimestamp(NtimelineTS+1:j) = {struct()};
      end
      for iTL = 1:labelidx.nTL
        classifiername = obj.labelnames{iTL};
        if ~isfield(obj.labels(expi).timelinetimestamp{j},classifiername)
          obj.labels(expi).timelinetimestamp{j}.(classifiername) = 0;
        end
        obj.labels(expi).timelinetimestamp{j}.(classifiername) = ...
          max(obj.labels(expi).timelinetimestamp{j}.(classifiername),maxtimestamps(iTL));
      end          

      %ALTODO: isn't obj.labels(expi).flies always unique?
      obj.labelstats(expi).nflies_labeled = numel(unique(obj.labels(expi).flies));
      obj.labelstats(expi).nbouts_labeled = numel(newlabels.t1s);
    end
    
    
% Show similar frames


    % ---------------------------------------------------------------------
    function [success,msg,dist] = ComputeBagFeatures(obj,curexp,curfly,curF)
    % Use the fast feature computation to find the bag features..
      success = true; msg = '';
      featureFileName = sprintf('%s_%s_%d',obj.fastPredictBag.tempname,obj.expnames{curexp},curfly);
      if exist(featureFileName,'file'),
        load(featureFileName,'dX'),
        dist = sum(abs(dX - repmat(curF,[size(dX,1) 1]))); %#ok<NODEF>
        return;
      end
      
      obj.SetStatus(sprintf('Computing distance to fly %d in exp:%s',curfly,obj.expnames{curexp}));
      perframeInMemory = ~isempty(obj.flies) && obj.IsCurFly(curexp,curfly);
      perframefile = obj.GetPerframeFiles(curexp);

      
      T0 = obj.GetTrxFirstFrame(curexp,curfly);
      T1 = obj.GetTrxEndFrame(curexp,curfly);
      
      
      
      perframedata_cur = obj.perframedata;
      windowfeaturescellparams = obj.fastPredictBag.windowfeaturescellparams;
      pffs = obj.fastPredictBag.pffs;
      allperframefns = obj.allperframefns;

      X_all = [];
      for t0 = T0:(2*obj.predictwindowdatachunk_radius):T1
       t1 = min(T1,t0+2*obj.predictwindowdatachunk_radius-1)-T0+1;
       
       % for the parfor loop.
       x_curr_all = cell(1,numel(pffs));
       X = []; fnames = {};
       parfor j = 1:numel(pffs),
         
         fn = pffs{j};
         
         ndx = find(strcmp(fn,allperframefns));
         if perframeInMemory,
           perframedata = perframedata_cur{ndx};  %#ok
         else
           perframedata = load(perframefile{ndx});  %#ok
           perframedata = perframedata.data{curfly(1)};  %#ok
         end
         
         t11 = min(t1,numel(perframedata));
         [x_curr,curf] = ...
           ComputeWindowFeatures(perframedata,...
           windowfeaturescellparams.(fn){:},'t0',t0-T0+1,'t1',t11);  %#ok
         fnames{j} = curf;
         if t11 < t1,
           x_curr(:,end+1:end+t1-t11) = nan;
         end
         
         x_curr_all{j} = single(x_curr);
       end
       
       allFeatures = {};
       for j = 1:numel(pffs),
         fn = pffs{j};
         x_curr = x_curr_all{j};
         % add the window data for this per-frame feature to X
         nold = size(X,1);
         nnew = size(x_curr,2);
         if nold > nnew,
           warning(['Number of examples for per-frame feature %s does not '...
             'match number of examples for previous features'],fn);
           x_curr(:,end+1:end+nold-nnew) = nan;
         elseif nnew > nold && ~isempty(X),
           warning(['Number of examples for per-frame feature %s does not '...
             'match number of examples for previous features'],fn);
           X(end+1:end+nnew-nold,:) = nan;
         end
         X = [X,x_curr']; %#ok<AGROW>
         jj = fnames{j};
         feature_names_curr = cellfun(@(x) [{pffs{j}},x],jj,'UniformOutput',false);  %#ok

         allFeatures = [allFeatures,feature_names_curr];  %#ok
       end
       
       X_all = [X_all;X];  %#ok
      end
     
      X_all = X_all(:,obj.fastPredictBag.wfidx);
      
      dX = zeros(size(X_all,1),numel(obj.fastPredictBag.classifier));
      for ndx = 1:numel(obj.fastPredictBag.classifier)
        curWk = obj.fastPredictBag.classifier(ndx);
        dd = X_all(:,curWk.dim)*curWk.dir;
        tt = curWk.tr*curWk.dir;
        dX(:,ndx) = sign( (dd>tt)-0.5 )*curWk.alpha;
        
      end
     save(featureFileName,'dX');
     dist = sum(abs(dX - repmat(curF,[size(dX,1) 1])),2);
     obj.ClearStatus();
    end
    
    
    % ---------------------------------------------------------------------
    function [success,msg] = ComputeBagDistFly(obj,expi,fly)
      [success,msg,dist] = obj.ComputeBagFeatures(expi,fly,obj.fastPredictBag.curF);
      obj.fastPredictBag.dist{expi}{fly} = dist;
    end

    
    % ---------------------------------------------------------------------
    function [success,msg] = ComputeBagDistExp(obj,curexp,curfly,curt,expi)  %#ok
      for ndx = 1:numel(obj.nflies_per_exp(expi))
        [success,msg,dist] = obj.ComputeBagFeatures(expi,ndx,obj.fastPredict.curF);
        obj.fastPredictBag.dist{expi}{ndx} = dist;
      end
      
    end
    
    
    % ---------------------------------------------------------------------
    function [nextT,distT] = FindNextClosest(obj,dist,curV,dir)  %#ok

      nextT = []; distT = [];
      switch dir
        case 'next'
          
          if max(dist) > curV,
            tt = dist-curV;
            tt(tt<=0) = inf;
            [~,nextT] = min(tt);
            distT = dist(nextT);
          end
          
        case 'prev'

          if min(dist) < curV,
            tt = dist-curV;
            tt(tt>=0) = -inf;
            [~,nextT] = max(tt);
            distT = dist(nextT);
          end
        
      end
      
    end

    
    % ---------------------------------------------------------------------
    function has = HasDistance(obj,expi,flies)
      has = ~(isempty(obj.bagModels) || ...
          isempty(obj.fastPredictBag.dist) || ...
          numel(obj.fastPredictBag.dist)<expi || ...
          isempty(obj.fastPredictBag.dist{expi}) || ...
         numel(obj.fastPredictBag.dist{expi})<flies || ...
         isempty(obj.fastPredictBag.dist{expi}{flies})); 
    end
    
    
    % ---------------------------------------------------------------------
    function ComputeBagDistanceTraining(obj)
      if isempty(obj.fastPredictBag.trainDist)
        dX = zeros(size(obj.windowdata.X,1),numel(obj.bagModels));
        for ndx = 1:numel(obj.bagModels)
          curWk = obj.bagModels(ndx);
          dd = obj.windowdata.X(:,curWk.dim)*curWk.dir;
          tt = curWk.tr*curWk.dir;
          dX(:,ndx) = sign( (dd>tt)-0.5 )*curWk.alpha;
          
        end
        
        dist = sum(abs(dX - repmat(obj.fastPredictBag.curF,[size(dX,1) 1])),2);
        
        obj.fastPredictBag.trainDist = dist;
      end
    end  % method
    
    
    % ---------------------------------------------------------------------
    function InitSimilarFrames(obj, HJLabel)
      obj.frameFig = showSimilarFrames;
      showSimilarFrames('SetJLabelData',obj.frameFig,obj,HJLabel);
      showSimilarFrames('CacheTracksLabeled',obj.frameFig);
      showSimilarFrames('add_prep_list', obj.frameFig);
    end
    
    
    
% Ground truthing functions.    

    % ---------------------------------------------------------------------
    function [success,msg] = SuggestRandomGT(obj,perfly,perexp)
      % Set obj.randomGTSuggestions, obj.GTSuggestionMode
      %
      % This is currently public, but seems like maybe it should be private, 
      % and get called when callers actually query
      % self.randomGTSuggestions, or something.  -- ALT, Apr 19, 2013
      
      % MERGEST OK
      
      success = false; 
      msg = '';
      
      % Do nothing if we already have suggestions with the same settings for
      % all the experiments.
      if numel(obj.randomGTSuggestions)<numel(obj.nflies_per_exp)
        recompute = true; 
      else
        recompute = false;
        for endx = 1:obj.nexps
          prevperexp = 0;
          
          for fndx = 1:obj.nflies_per_exp(endx)
            if isempty(obj.randomGTSuggestions{endx}(fndx).start);
              continue;
            end
            prevperfly = obj.randomGTSuggestions{endx}(fndx).end - ...
              obj.randomGTSuggestions{endx}(fndx).start+1;
            if (prevperfly ~= perfly)
              recompute = true;
              break; % AL: Ideally breaks out of both loops, not just inner?
            end
            prevperexp = prevperexp+1;
          end
          
          if prevperexp ~= perexp
            recompute = true;
          end          
        end
      end
      if ~recompute
        obj.GTSuggestionMode = 'Random';
        return;
      end
      
      for endx = 1:obj.nexps
        % AL: appears to be the wrong initialization, don't we want
        % repmat(...,1,obj.nflies_per_exp(endx)?
        obj.randomGTSuggestions{endx} = repmat(struct('start',[],'end',[]),1,perexp);
        
        validflies = find( (obj.endframes_per_exp{endx} - ...
          obj.firstframes_per_exp{endx})>perfly );
        if numel(validflies)<perexp
          msg = sprintf('Experiment %s does not have %d flies with more than %d frames',...
            obj.expnames{endx},perexp,perfly);
          success = false;
          return;
        end
        permuteValid = validflies(randperm(numel(validflies)));
        randFlies = permuteValid(1:perexp);
        
        for fndx = 1:obj.nflies_per_exp(endx)
          if any(fndx == randFlies)
              first = obj.firstframes_per_exp{endx}(fndx);
              last = obj.endframes_per_exp{endx}(fndx);
              suggestStart = first + round( (last-first-perfly)*rand(1));
              obj.randomGTSuggestions{endx}(fndx).start = suggestStart;
              obj.randomGTSuggestions{endx}(fndx).end = suggestStart+perfly-1;
          else
              obj.randomGTSuggestions{endx}(fndx).start = [];
              obj.randomGTSuggestions{endx}(fndx).end = [];              
          end
        end        
      end
      success = true;
      obj.GTSuggestionMode = 'Random';      
    end
    
    
    % ---------------------------------------------------------------------
    function [success,msg] = SuggestBalancedGT(obj,intsize,numint)
      % Set obj.balancedGTSuggestions, obj.GTSuggestionMode
      %
      % Suggest frames such that half the suggested frames are predicted
      % positive and half are negative.
      % Excludes frames that have normal labels.
      
      % MERGEST OK
      
      assert(obj.nclassifiers==1,'Unsupported for multiple classifiers.');
      
      success = true; msg = '';
      
      if ~obj.HasLoadedScores(1)
        uiwait(warndlg('No scores have been loaded. Load precomputed scores to use this'));
      end
      
      jabparams = load(obj.everythingFileNameAbs,'-mat');
      assert(numel(jabparams.x.classifierStuff==1),'Unsupported for multiple classifiers.');
      frames2exclude = cell(1,obj.nexps);
      for ndx = numel(jabparams.x.expDirNames)
        matchingGtexp = find(strcmp(jabparams.x.expDirNames{ndx},obj.expdirs));
        if isempty(matchingGtexp), continue; end
        frames2exclude{matchingGtexp} = jabparams.x.labels(ndx);
      end
      
      numpos = 0;
      numneg = 0;
      for expi = 1:obj.nexps,
        for flies = 1:obj.nflies_per_exp(expi)
          numpos = numpos + nnz(obj.predictdata{expi}{flies}.loaded>0);
          numneg = numneg + nnz(obj.predictdata{expi}{flies}.loaded<0);
        end
      end
      poswt = numneg/(numneg+numpos);
      negwt = numpos/(numneg+numpos);
      
      int = struct('exp',[],'flies',[],'tStart',[],'wt',[]);
      obj.balancedGTSuggestions = {};
      for endx = 1:obj.nexps
        obj.SetStatus('Couting predictions on experiment%d',endx);
        for flies = 1:obj.nflies_per_exp(endx)
          if ~obj.predictdata{endx}{flies}.loaded_valid(1),
            msg = sprintf('No Scores have been loaded for %s, cannot suggest intervals for ground truthing\n',...
              obj.expnames{endx});
            success = false;
            return;
          end
          
          curt = obj.predictdata{endx}{flies}.t;
          if numel(curt)<intsize; continue; end
          numT = numel(curt)-intsize+1;
          int.exp(1,end+1:end+numT) = endx;
          int.flies(1,end+1:end+numT) = flies;
          int.tStart(1,end+1:end+numT) = curt(1:end-intsize+1);
          curwt = (obj.predictdata{endx}{flies}.loaded<0)*negwt +(obj.predictdata{endx}{flies}.loaded>0)*poswt ;
          
          cumwt = cumsum(curwt);
          sumwt = cumwt(intsize+1:end)-cumwt(1:end-intsize);
          sumwt = [cumwt(intsize) sumwt]; %#ok<AGROW>

          if ~isempty(frames2exclude{endx}) && any(frames2exclude{endx}.flies == flies)
            
            fndx = find(frames2exclude{endx}.flies == flies);
            labeledF = false(size(curwt));
            for bndx = 1:numel(frames2exclude{endx}.t0s{fndx})
              tStart = frames2exclude{endx}.off(fndx);
              curt0 = max(1, frames2exclude{endx}.t0s{fndx}(bndx)-intsize + tStart );
              curt1 = min(numel(sumwt),frames2exclude{endx}.t1s{fndx}(bndx)+intsize +tStart);
              labeledF(curt0:curt1-1) = true;
            end
            
            sumwt(labeledF) = 0;
          end
          
          int.wt(1,end+1:end+numT) = sumwt;
          
        end
      end
      
      obj.balancedGTSuggestions = [];
      for ndx = 1:numint
        obj.SetStatus('Finding interval %d to label',ndx);
        
        % weight sampling was off by 1
        % fixed 20140331 by KB
        
        % old sampling
        %cumwt = cumsum(int.wt)/sum(int.wt);
        cumwt = cumsum([0,int.wt(1:end-1)])/sum(int.wt);
        intlocs = rand;
        locsSel = find(cumwt<=intlocs,1,'last');
        
        if isempty(locsSel), locsSel = numel(cumwt); end
        expi = int.exp(locsSel);
        flies = int.flies(locsSel);
        tStart = int.tStart(locsSel);
        obj.balancedGTSuggestions(ndx).start = tStart;
        obj.balancedGTSuggestions(ndx).end = tStart+intsize-1;
        obj.balancedGTSuggestions(ndx).exp = expi;
        obj.balancedGTSuggestions(ndx).flies = flies;
        
        % Removing intervals that overlap
        overlap = int.exp == int.exp(locsSel) & ...
                        int.flies == int.flies(locsSel) & ...
                        abs( int.tStart-int.tStart(locsSel))<=intsize;
        int.exp(overlap) = [];
        int.flies(overlap) = [];
        int.tStart(overlap) = [];
        int.wt(overlap) = [];
      end
      
      obj.GTSuggestionMode = 'Balanced';
      
    end  % method
    
    
    % ---------------------------------------------------------------------
    function [success,msg] = SuggestLoadedGT(obj,filename)
      %MERGEST OK
      
      success = false; %#ok<NASGU>
      msg = '';
      fid = fopen(filename);
      if fid < 0,
        msg = sprintf('Could not open file %s for reading',filename);
      end
      dat = cell(0,4);
      missingexps = {};
      while true,
        s = fgetl(fid);
        if ~ischar(s),
          break;
        end
        s = strtrim(s);
        m = regexp(s,'^exp:(.*),fly:(.*),start:(.*),end:(.*)','tokens','once');
        if isempty(m),
          continue;
        end
        if isempty(m{3}) || isempty(m{4}),
          continue;
        end
        curexp = find(strcmp(m{1},obj.expnames));
        if isempty(curexp)
          if ~any(strcmp(m{1},missingexps))
            missingexps{end+1} = m{1}; %#ok<AGROW>
          end
          continue;
        end
        dat{end+1,1} = curexp; %#ok<AGROW>
        dat(end,2:4) = cellfun(@(x) str2double(x),m(2:end),'UniformOutput',false);
      end
      
      if ~isempty(missingexps)
        expstring = '';
        for ii = 1:numel(missingexps),
          expstring = [expstring ' ' missingexps{ii}]; %#ok<AGROW>
        end
        uiwait(warndlg(sprintf(...
          'Experiments:%s are not currently loaded. Not loading the GT suggestions for these experiments',...
          expstring)));        
      end
      
      dat = cell2mat(dat);
      fclose(fid);
      expi = dat(:,1); fly = dat(:,2); t0s = dat(:,3); t1s = dat(:,4);
      for curexpi = 1:obj.nexps
        for ndx = 1:obj.nflies_per_exp(curexpi)
          loc = ismember(fly,ndx) & ismember(expi,curexpi);
          if ~any(loc),
            obj.loadedGTSuggestions{curexpi}(ndx).start = 1;
            obj.loadedGTSuggestions{curexpi}(ndx).end = 0;
          else
            obj.loadedGTSuggestions{curexpi}(ndx).start = t0s(loc);
            obj.loadedGTSuggestions{curexpi}(ndx).end = t1s(loc);
          end
        end
      end
      obj.GTSuggestionMode = 'Imported';
      success = true;
    end  % method

    
    % ---------------------------------------------------------------------
    function SuggestThresholdGT(obj,threshold)
      obj.thresholdGTSuggestions = threshold;
      obj.GTSuggestionMode = 'Threshold';
    end  % method
    
    
    % ---------------------------------------------------------------------
    function tf = HasLoadedScores(obj,iCls)
      % tf: true if there are loaded scores for all exps/flies
      
      %MERGESTUPDATED
      
      assert(isscalar(iCls) && any(iCls==1:obj.nclassifiers));
      
      tf = true;
      for expi = 1:obj.nexps
        for flies = 1:obj.nflies_per_exp(expi)
          pdArr = obj.predictdata{expi}{flies};
          if ~pdArr(iCls).loaded_valid(1)
            tf = false;
            return;
          end
        end
      end      
    end

    
% Post Processing functions

%    % ---------------------------------------------------------------------
%    function InitPostprocessparams(obj)
%      % AL no callsites
%      obj.postprocessparams.method = 'Hysteresis';
%      obj.postprocessparams.hystopts(1) = struct('name','High Threshold','tag','hthres','value',0);
%      obj.postprocessparams.hystopts(2) = struct('name','Low Threshold','tag','lthres','value',0);
%      obj.postprocessparams.filtopts(1) = struct('name','Size','tag','size','value',1);
%      obj.postprocessparams.blen = 1;
%    end

    
    % ---------------------------------------------------------------------
    function [success,msg] = ApplyPostprocessing(obj,expis,allflies)
    % Applies postprocessing to current, loaded scores.
    %
    % Effect: update obj.predictdata{expis}{...}(:).cur_pp and
    % obj.predictdata{expis}{...}(:).loaded_pp
    
    %MERGESTUPDATED
            
      if nargin < 2,
        expis = 1:obj.nexps;
      end
      if nargin >= 3,
        if ~iscell(allflies),
          allflies = {allflies};
        end
      else
        allflies = {};
      end
      for i = 1:numel(expis),
        if numel(allflies) < i,
          endx = expis(i);
          allflies{i} = 1:obj.nflies_per_exp(endx);
        end
      end
      
      assert(numel(expis)==numel(allflies) && iscell(allflies));
      % allflies{i} contains list of flies for exp expis{i}
          
      %fprintf('Calling ApplyPostprocessing for %d experiments and %d flies...\n',numel(expis),sum(cellfun(@numel,allflies)));  
      
      nCls = obj.nclassifiers;
      assert(numel(obj.windowdata)==nCls);
      for ibeh = 1:nCls
        scoreNorm = obj.windowdata(ibeh).scoreNorm;
        ppparams = obj.postprocessparams{ibeh};
        for expii = 1:numel(expis),
          endx = expis(expii);
          for flies = allflies{expii},
            idx = obj.predictdata{endx}{flies}(ibeh).cur_valid;
            ts = obj.predictdata{endx}{flies}(ibeh).t(idx);
            [sortedts, idxorder] = sort(ts);
            gaps = find((sortedts(2:end) - sortedts(1:end-1))>1)+1; 
            gaps = [1;gaps';numel(ts)+1];
            for ndx = 1:numel(gaps)-1
              % Loop over "nongap" or "consecutive-t" subseqs
              % - idxorder(gaps(ndx):gaps(ndx+1)-1) appears to be indices into ts
              % for a consecutive subseq
              % - so curidx represent indices into fields of predictdata{}{}(ibeh)
              curidx = idx(idxorder(gaps(ndx):gaps(ndx+1)-1));
              curs = obj.predictdata{endx}{flies}(ibeh).cur(curidx);
              obj.predictdata{endx}{flies}(ibeh).cur_pp(curidx) = ...
                PostProcessor.PostProcess(curs,ppparams,scoreNorm);
            end
          end
        end
      end
      
      for ibeh = 1:nCls
        scoreNorm = obj.windowdata(ibeh).scoreNorm;
        ppparams = obj.postprocessparams{ibeh};
        for expii = 1:numel(expis),
          endx = expis(expii);
          for flies = allflies{expii},
            curidx = obj.predictdata{endx}{flies}(ibeh).loaded_valid;
            curt = obj.predictdata{endx}{flies}(ibeh).t(curidx);
            if any(curt(2:end)-curt(1:end-1) ~= 1)
              msg = 'Scores are not in order';
              success = false;
              return;
              % ALTODO early return has left obj.predictdata partially
              % updated. Is this an assert?
            end
            curs = obj.predictdata{endx}{flies}(ibeh).loaded(curidx);
            obj.predictdata{endx}{flies}(ibeh).loaded_pp(curidx) = ...
              PostProcessor.PostProcess(curs,ppparams,scoreNorm);
          end %flies
        end
      end
      
      msg = ''; 
      success = true;     
    end  % method

    
%     % ---------------------------------------------------------------------
%     function posts = Postprocess(obj,curs,scoreNorm)
%       posts = PostProcessor.PostProcess(curs,obj.postprocessparams,scoreNorm);
%     end 
%     
    
    % ---------------------------------------------------------------------
    function SaveScores(self,allScoresCell,sfn)
      % Save prediction scores for a whole experiment.
      % 
      % allScoresCell: cell array, nclassifiers elements, each el is an
      %  allScore (see ScoreFile)
      % sfn: cellstr, full filenames to be saved
      
      % MERGESTUPDATED
      
      nCls = self.nclassifiers;
      assert(iscell(allScoresCell) && numel(allScoresCell)==nCls);
      assert(iscellstr(sfn) && numel(sfn)==nCls);

      if ~self.userHasSpecifiedEverythingFileName
        error('JLabelData:noJabFileNameSpecified', ...
          'A .jab file name must be specified before scores can be saved.');
      end
      
      sf = ScoreFile;
      sf.jabFileNameAbs = self.everythingFileNameAbs;
      sf.version = self.version;
      timestamp = self.classifierTS;
      behnames = self.classifiernames;
      assert(isequal(nCls,numel(timestamp),numel(behnames)));
      
      for iCls = 1:nCls
        sf.allScores = allScoresCell{iCls};
        sf.behaviorName = behnames{iCls};
        sf.timestamp = timestamp(iCls);
        save(sf,sfn{iCls});
      end
    end
    
  end  % private methods

  
  % -----------------------------------------------------------------------
  % -----------------------------------------------------------------------
  methods (Access=public,Static=true)

    % movie, trx, and perframedir are required for each experiment
    % perframedir can be generated
    function res = CanGenerateFile(file)
      res = ismember(file,{'perframedir'});
    end
    
    % which files should go in the output directory
    function res = IsOutputFile(file)
      res = ismember(file,{'label','clipsdir','scores','gt_label'});
    end    
    
    function valid = CheckExp(expi)
      if numel(expi) ~= 1,
        error('Usage: expi must be a scalar');
        %valid = false;
      else
        valid = true;
      end
    end
    
    function valid = CheckFlies(flies)
      if size(flies,1) ~= 1,
        error('Usage: one set of flies must be selected');
        %valid = false;
      else
        valid = true;
      end
    end      

    function [X,feature_names] = ...
      ComputeWindowDataChunkStatic(curperframefns,allperframefns,perframefile,...
        flies,windowfeaturescellparams,t0,t1)
      % Computes a chunk of windowdata between frames t0 and t1 for flies
      % flies. Loop through all the per-frame features, and call
      % ComputeWindowFeatures to compute all the window data for that
      % per-frame feature.
      %
      % X: nframes x nfeatures window data
      % feature_names: 1 x nfeatures cell array labeling columns of X
      
      %MERGESTUPDATED
      
      assert(numel(allperframefns)==numel(perframefile));
      assert(isequal(fieldnames(windowfeaturescellparams),curperframefns(:)));
      
      X = [];
      feature_names = cell(1,numel(curperframefns));
      for j = 1:numel(curperframefns)
        fn = curperframefns{j};
        ndx = find(strcmp(fn,allperframefns));
        
        perframedata = load(perframefile{ndx}); %#ok
        perframedata = perframedata.data{flies(1)};
        
        t11 = min(t1,numel(perframedata));
        [x_curr,feature_names_curr] = ...
          ComputeWindowFeatures(perframedata,windowfeaturescellparams.(fn){:},'t0',t0,'t1',t11);
        
        if t11 < t1,
          x_curr(:,end+1:end+t1-t11) = nan;
        end
        
        % add the window data for this per-frame feature to X
        nold = size(X,1);
        nnew = size(x_curr,2);
        if nold > nnew,
          warning('Number of examples for per-frame feature %s does not match number of examples for previous features',fn);
          x_curr(:,end+1:end+nold-nnew) = nan;
        elseif nnew > nold && ~isempty(X),
          warning('Number of examples for per-frame feature %s does not match number of examples for previous features',fn);
          X(end+1:end+nnew-nold,:) = nan;
        end
        X = [X,x_curr']; %#ok<AGROW>
        % add the feature names
        if nargout>1
          feature_names{j} = cellfun(@(s) [{fn},s],feature_names_curr,'UniformOutput',false); 
        end
      end
      X = single(X);
      feature_names = [feature_names{:}];
    end
    
    function params = convertTransTypes2Cell(params)
      % Convert the trans_types field into cell type
      if ~isstruct(params), return; end
      fnames = fieldnames(params);
      for ndx = 1:numel(fnames)
        if isstruct(params.(fnames{ndx}))
          params.(fnames{ndx}) = JLabelData.convertTransTypes2Cell(params.(fnames{ndx}));
        end
      end
      if isfield(params,'trans_types')
        if ~iscell(params.trans_types)
          params.trans_types = {params.trans_types};
        end
        x = cellfun(@isempty,params.trans_types);
        params.trans_types(x)=[];
      end
    end
    
    
    % ---------------------------------------------------------------------
    function cellparams = convertParams2CellParams(params)
      % Convert the windowFeatureParams structure, which stores a 'list' of
      % per-frame features and the parameters that determine how each is
      % converted to a set of window features, to it's corresponding
      % cell-based form, which is apparently sometimes useful.
      cellparams = struct;
      fns1 = fieldnames(params);
      for i1 = 1:numel(fns1),
        fn1 = fns1{i1};
        fns2 = fieldnames(params.(fn1));
        cellparams.(fn1) = {};
        feature_types = {};
        for i2 = 1:numel(fns2),
          fn2 = fns2{i2};
          if ~isstruct(params.(fn1).(fn2)),
            cellparams.(fn1)(end+1:end+2) = {fn2,params.(fn1).(fn2)};
          else
            cellparams.(fn1)(end+1:end+2) = {[fn2,'_params'],struct2paramscell(params.(fn1).(fn2))};
            feature_types{end+1} = fn2; %#ok<AGROW>
          end
        end
        cellparams.(fn1)(end+1:end+2) = {'feature_types',feature_types};
      end
    end  % method

    
    % --------------------------------------------------------------------------
    function [nFlies,firstFrames,endFrames,hasArenaParams,hasSex,fracSex,sex,hasPerFrameSex] = ...
        readTrxInfoFromFile(trxFileName)
      % Read the trx file
      [trx,~,success] = load_tracks(trxFileName);
      if ~success,
        error('JAABA:JLabelData:readTrxInfoFromFile:errorReadingTrxFile', ...
              'Unable to read .trx file');
      end
      
      % Set the returned things which can be read directly from the .trx
      % file
      nFlies = numel(trx);
      firstFrames = [trx.firstframe];
      endFrames = [trx.endframe];
      hasArenaParams=isfield(trx,'arena');
      hasSex = isfield(trx,'sex');
      hasPerFrameSex = false;
        
      % Compute fracSex and sex from the trx file contents
      fracSex = struct('M',repmat({nan},[1 nFlies]), ...
                       'F',repmat({nan},[1 nFlies]));
      sex = repmat({'?'},[1 nFlies]);
      if hasSex,
        % this track file has sex
        if nFlies==0,
          hasPerFrameSex=true;  % vacuous truth
        else
          hasPerFrameSex = iscell(trx(1).sex);
        end
        if hasPerFrameSex,
          % this trx file has per-frame sex
          for iFly = 1:nFlies,
            n = numel(trx(iFly).sex);
            nMale = nnz(max(strcmpi(trx(iFly).sex,'M'),strcmpi(trx(iFly).sex,'male')));
            nFemale = nnz(max(strcmpi(trx(iFly).sex,'F'),strcmpi(trx(iFly).sex,'female')));
            fracSex(iFly).M = nMale/n;
            fracSex(iFly).F = nFemale/n;
            if nMale > nFemale,
              sex{iFly} = 'M';
            elseif nFemale > nMale,
              sex{iFly} = 'F';
            else
              sex{iFly} = '?';
            end
          end
        else
          % this trx files does not have per-frame sex
          for iFly = 1:nFlies,
            sex{iFly} = trx(iFly).sex;
            if strcmpi(trx(iFly).sex,'M'),
              fracSex(iFly).M = 1;
              fracSex(iFly).F = 0;
            elseif strcmpi(trx(iFly).sex,'F'),
              fracSex(iFly).M = 0;
              fracSex(iFly).F = 1;
            end
          end
        end
      end
    end  % method
    
    
    % ---------------------------------------------------------------------
    function result=isValidBehaviorName(behaviorName)
      result=~isempty(regexp(behaviorName,'^[a-zA-Z_0-9]+$','once'));
    end

    
    % ---------------------------------------------------------------------
    function result=isValidScoreFileName(scoreFileName)
      [path,baseName,ext]=fileparts(scoreFileName);
      if ~isempty(path) ,
        result=false;
      elseif ~isequal(ext,'.mat')
        result=false;
      else
        result=~isempty(regexp(baseName,'^[a-zA-Z_0-9]+$','once'));
      end
    end    
    
    
%     % ------------------------------------------------------------------------
%     function basicParams=basicParamsFromMacguffin(everythingParams)
%       basicParams=struct();
%       basicParams.featureLexiconName=everythingParams.featureLexiconName;
%       basicParams.featureLexicon=everythingParams.featureLexicon;
%       %basicParams.scoreFeatures=everythingParams.scoreFeatures;
%       basicParams.sublexiconPFNames=everythingParams.sublexiconPFNames;
%       basicParams.behaviors=everythingParams.behaviors;  % need the animal type, in case featureLexiconName is 'custom'
%       basicParams.behaviors.names=everythingParams.behaviors.names(1);  % just want the first one
%       basicParams.file=everythingParams.file;
%       basicParams.labelGraphicParams=everythingParams.labelGraphicParams;
%       basicParams.trxGraphicParams=everythingParams.trxGraphicParams;
%       basicParams.landmarkParams=everythingParams.landmarkParams;
%     end    
  end  % class methods
  
  
  % -----------------------------------------------------------------------
  methods (Access=public)
    function obj = JLabelData(varargin)
    % obj = JLabelData(configParams,...)
    %
    % constructor: first input should be the config params. All other
    % inputs are optional. if configfilename is not input, throws an error. 
    % 
    % optional inputs: 
    %
    % TODO: debug this
    % override stuff set in the config file: 
    %
    % moviefilename, trxfilename, labelfilename, perframedir, clipsdir: names of
    % files within experiment directories: 
    % featureparamsfilename: file containing feature parameters
    % rootoutputdir: in case we don't want to write to the experiment
    % directory, we will mirror the experiment directory structure in the
    % rootoutputdir this can be the same as the input root directory
    %
    % defaultpath: default location to look for experiments
    % setstatusfn: handle to function that inputs sprintf-like input and
    % outputs the corresponding string to a status bar.
    % clearstatusfn: handle to function that returns the status to the
    % default string
    % classifierfilename: name of classifier file to save/load classifier from
 
      % Initialize the object
      obj.initialize();
    
      % args should be key-value pairs
      if mod(numel(varargin),2) ~= 0,
        error('JLabelData:oddNumberOfArgsToConstructor',  ...
              'Number of inputs to JLabelData constructor must be even');
      end

      % parse arguments into keywords and corresponding values
      keys = varargin(1:2:end);
      values = varargin(2:2:end);     
      
      % Set the function to be called when the SetStatus method is invoked
      i = find(strcmpi(keys,'setstatusfn'),1);
      if isempty(i),
        obj.setstatusfn = @disp;  % do-nothing function
      else
        obj.setstatusfn = values{i};
      end

      % Set the function to be called when the ClearStatus method is
      % invoked
      i = find(strcmpi(keys,'clearstatusfn'),1);
      if isempty(i),
        obj.clearstatusfn = @()([]);  % do-nothing function
      else
        obj.clearstatusfn = values{i};
      end
                          
      % default path
      i = find(strcmpi(keys,'defaultpath'),1);
      if ~isempty(i),
        [success,msg] = obj.SetDefaultPath(values{i});
        if ~success,
          warning(msg);
        end
      end
      
      % isInteractive
      i = find(strcmpi(keys,'isInteractive'),1);
      if ~isempty(i),
        obj.isInteractive=values{i};
      end
      
      % cacheSize
      % Not used for anything as of Apr 30, 2013 --ALT
      i = find(strcmpi(keys,'cacheSize'),1);
      if ~isempty(i),
        obj.cacheSize = values{i};
      end
      
      % Set the JAABA version
      try 
        vid = fopen('version.txt','r');
        vv = textscan(vid,'%s');
        fclose(vid);
        obj.version = vv{1}{1};
      catch ME
        warning('Cannot detect JAABA Version (%s). Setting it to 0.0',ME.message);  
        obj.version = '0.0';
      end
      
      % % initialize the status table describing what required files exist
      % [success,msg] = obj.UpdateStatusTable();
      % if ~success,
      %   error(msg);
      % end      
    end  % constructor method

    
% Some helper functions.

    % ---------------------------------------------------------------------
    function res = IsRequiredFile(obj,file)
      if obj.isST
        res = any(strcmp(file,{'trx' 'stfeatures'}));
      else
        res = ismember(file,{'trx','perframedir'});
      end
    end


    % ---------------------------------------------------------------------
    function idx = FlyNdx(obj,expi,flies,iCls)
      %MERGESTUPDATED      
      
      if isempty(obj.windowdata(iCls).exp)
        idx = [];
        return;
      end
      idx = obj.windowdata(iCls).exp==expi & all(bsxfun(@eq,obj.windowdata(iCls).flies,flies),2);
    end
    
    
    % ---------------------------------------------------------------------
    function val = IsCurFly(obj,expi,flies)
      val = all(flies == obj.flies) && (expi==obj.expi);
    end

    
    % ---------------------------------------------------------------------
    function expi = GetExp(obj)
      expi = obj.expi;
    end

    
    % ---------------------------------------------------------------------
    function flies = GetFlies(obj)
      flies = obj.flies;
    end
    
    
    % ---------------------------------------------------------------------
    function nflies = GetNumFlies(obj,expi)
      nflies = obj.nflies_per_exp(expi);
    end

    
    % ---------------------------------------------------------------------
    function firstframes = GetFirstFrames(obj,expi,flies)
      
      if nargin < 2,
        firstframes = obj.firstframes_per_exp;
      elseif nargin < 3,
        firstframes = obj.firstframes_per_exp(expi);
      else
        firstframes = obj.firstframes_per_exp{expi}(flies);
      end
      
    end

    
    % ---------------------------------------------------------------------
    function endframes = GetEndFrames(obj,expi,flies)
      
      if nargin < 2,
        endframes = obj.endframes_per_exp;
      elseif nargin < 3,
        endframes = obj.endframes_per_exp(expi);
      else
        endframes = obj.endframes_per_exp{expi}(flies);
      end
      
    end

    % ---------------------------------------------------------------------
    function minFirstframes = GetMinFirstFrame(obj)
      minFirstframes = min(obj.firstframes_per_exp{obj.expi});
    end

    
    % ---------------------------------------------------------------------
    function maxEndframe = GetMaxEndFrame(obj)
      maxEndframe = max(obj.endframes_per_exp{obj.expi});
    end
    
    % ---------------------------------------------------------------------
    function [fileExists,fileTimeStamps,missingFileNamesComplete] = ...
        fileOfGivenTypesExistForGivenExps(obj,filetypes,expis)
      % This gets whether the experiment files of filetypes (a cell array
      % of strings) exist, for the experiments indicated by expis.  On
      % return, fileExists is a length(expis) x length(filetypes) logical
      % array, indicating whether the given file type exists for the given
      % experiment.  fileTimeStamps has the same shape, and given the time
      % stamp of each file if it exists, and -inf otherwise.
      % missingFileNamesComplete is a cell array vector of length
      % length(expis).  Each element is a cell array of strings, listing
      % the missing files for that experiment.  These lists are not 
      % truncated to any particular length.  (That's why 'Complete' is in 
      % the name.  Note that this function is a getter---it does not change
      % the object state at all.
      %
      % For filetypes that can represent multiple files:
      %  - fileExists is only true if *all* files are present
      %  - fileTimeStamps is the *oldest* of all timestamps
      %      AL20150109: For fileType='perframedir', fileTimeStamps appears
      %      to be *newest* of all timestamps

      % ST OK
      
      % Process arguments
      if ~exist('filetypes','var') || isempty(filetypes)
        filetypes = obj.filetypes;
      end
      if ~exist('expis','var') || isempty(expis)
        expis = 1:obj.nexps;
      end

      % Check that the file types requested are valid
      [fileTypeIsValid,fileTypeIndices] = ismember(filetypes,obj.filetypes);
      assert(all(fileTypeIsValid),'JLabelData:unknownFileType', ...
        'Internal error: Unknown file type.  Please report to the JAABA developers.');
      
      % Initialize the return vars
      nExpsToCheck = length(expis);
      nFileTypesToCheck = length(fileTypeIndices);
      fileExists = false(nExpsToCheck,nFileTypesToCheck);
      fileTimeStamps = nan(nExpsToCheck,nFileTypesToCheck);
      missingFileNamesComplete = cell(1,nExpsToCheck);
      for i = 1:nExpsToCheck
        missingFileNamesComplete{i} = {};
      end
      
      % Loop through all file types, checking the existence of files of
      % that type.
      for j=1:nFileTypesToCheck
        fileTypeIndex = fileTypeIndices(j);
        fileType = obj.filetypes{fileTypeIndex};
        % loop through experiments
        for i=1:nExpsToCheck
          expi = expis(i);
          if strcmpi(fileType,'perframedir'),
            % fileType of 'perframedir' is a special case, and has to be
            % handled separately
            [perframeFileNames,timestamps] = obj.GetPerframeFiles(expi);
            if isempty(perframeFileNames),
              fileExists(i,j) = false;
              fileTimeStamps(i,j) = -inf;
            else
              perframeFileExists = cellfun(@(s) exist(s,'file'),perframeFileNames);
              fileExists(i,j) = all(perframeFileExists);
              if ~fileExists(i,j) && obj.IsRequiredFile(fileType),
                for indicesOfMissingPerframeFiles = find(~perframeFileExists(:)'),
                  [~,fileNameThis] = myfileparts(perframeFileNames{indicesOfMissingPerframeFiles});
                  missingFileNamesComplete{i}{end+1} = ['perframe_' fileNameThis];
                end
              end
              fileTimeStamps(i,j) = max(timestamps); % AL 20150109: This is newest timestamp, comments above say oldest
            end
          else
            % if fileType is anything besides 'perframedir'
            % check for existence of current file(s)
            [fn,fTS,tffound] = obj.GetFile(fileType,expi);
            assert(iscell(fn)||ischar(fn),'Legacy check.');
            fileExists(i,j) = all(tffound);
            fileTimeStamps(i,j) = min(fTS);
            if ~fileExists(i,j) && obj.IsRequiredFile(fileType)
              missingFileNamesComplete{i}{end+1} = fileType;
            end
          end
        end
      end
    end  % method


    % ---------------------------------------------------------------------
    function [allRequiredFilesExist, ...
              missingFilesCanBeGenerated, ...
              oneMissingFileTypeThatCantBeGenerated] = allRequiredFilesExist(obj,fileExists)
      % Check whether all required files exist for all experiments.
      % fileExists is optional, and if provided should be a complete matrix
      % of file existance information, e.g. as returned by
      % fileExists=obj.fileOfGivenTypesExistForGivenExps().  If this
      % argument is not provided, this method calls
      % fileOfGivenTypesExistForGivenExps() to get current file existance
      % information.  (The idea is that if you just called
      % fileOfGivenTypesExistForGivenExps(), you can give its output to
      % this method, and then this method won't have to figure that stuff
      % out again.)
      % On return, allRequiredFilesExist is a logical scalar.  If
      % allRequiredFilesExist is false, missingFilesCanBeGenerated is a
      % logical scalar indicating whether the missing files can be
      % generated.  If both allRequiredFilesExist and
      % missingFilesCanBeGenerated are false,
      % oneMissingFileTypeThatCantBeGenerated gives the name of one file
      % type that cannot be generated.  Note that this function is a
      % getter---it does not change the object state at all.

      % ST OK
      
      % Get detailed information about file existance, if not given as
      % argument
      if ~exist('fileExists','var')
        fileExists = obj.fileOfGivenTypesExistForGivenExps();
          % with no args, computed for all file types, all exps
      end
      
      nExp = obj.nexps;
      nType = numel(obj.filetypes);
      assert(isequal(size(fileExists),[nExp nType]));
            
      % initialize outputs
      allRequiredFilesExist = true;
      missingFilesCanBeGenerated = [];
      oneMissingFileTypeThatCantBeGenerated = '';
      
      for iType = 1:nType
        type = obj.filetypes{iType};
        tfReqd = obj.IsRequiredFile(type);
        if tfReqd
          for iExp = 1:nExp
            if ~fileExists(iExp,iType)
              allRequiredFilesExist = false;
              % if furthermore file can't be generated, then not fixable
              missingFilesCanBeGenerated = JLabelData.CanGenerateFile(type);
              if ~missingFilesCanBeGenerated
                oneMissingFileTypeThatCantBeGenerated = type;
                return;
              end
            end
          end
        end
      end
    end 
    
    
% Configuration settings.

    % ---------------------------------------------------------------------

%     function [success,msg] = SetConfigFileName(obj,configfilename)
%       % [success,msg] = SetConfigFileName(obj,configfilename)
%       % Set and read config file.
%       % Reads the XML config file, then sets all the file names and paths.
%       % I think this currently needs to be called before experiments, labels
%       % are loaded in, as locations of files, behaviors can be modified by
%       % this step.
%       % labelnames, nbehaviors are also set by the config file. If not
%       % included explicitly, the 'None' behavior is added. 'None' is put at
%       % the end of the behavior list.
%       
%       success = false;
%       msg = '';
%       if ~ischar(configfilename),
%         return;
%       end
%       %       try
%       [~,~,ext] = fileparts(configfilename);
%       if strcmp(ext,'.xml'),
%         configParams = ReadXMLConfigParams(configfilename);
%       else
%         configParams = load(configfilename);
%       end
%       
%       [success,msg] = setProjectParams(obj,configParams,configfilename);
%       
%     end


    % ---------------------------------------------------------------------
    function basicParams = getBasicParamsStruct(obj)
      basicParams=struct();
      basicParams.featureLexiconName=obj.featureLexiconName;
      basicParams.scoreFeatures=obj.scoreFeatures;
      subdialectPFNames=obj.allperframefns;
      nScoreFeaturess=length(obj.scoreFeatures);
      sublexiconPFNames=subdialectPFNames(1:end-nScoreFeaturess);  
      basicParams.sublexiconPFNames=sublexiconPFNames;

      %assert(numel(basicParams.behaviors.names)==numel(basicParams.behaviors.labelcolors));
      %ALTODO labelcolors one less currently
      %assert(strcmp(obj.labelnames{end},'None'));
      basicParams.behaviors.names=obj.labelnames;
      basicParams.behaviors.labelcolors=obj.labelcolors;
      basicParams.behaviors.unknowncolor=obj.unknowncolor;
      
      basicParams.file.moviefilename=obj.moviefilename;
      basicParams.file.trxfilename=obj.trxfilename;
      basicParams.file.scorefilename=obj.scorefilename;
      %basicParams.scoresinput=obj.scoreFeatures;
      basicParams.labelGraphicParams=obj.labelGraphicParams;
      basicParams.trxGraphicParams=obj.trxGraphicParams;
    end
    
    
    % ---------------------------------------------------------------------
    function setBehaviorName(obj,behaviorName)
      % ALTODO: See Labels.renameBehavior
      % Set the behavior name, a string
      
      if JLabelData.isValidBehaviorName(behaviorName),
        oldbehaviorname = obj.labelnames{1};
        obj.labelnames = {behaviorName 'None'};
        obj.nbehaviors = 2;
        obj.needsave=true;
        
        % ALTODO: see Labels.renameBehavior
        for expi = 1:obj.nexps
          for flynum = 1:numel(obj.labels(expi).flies)
            for bnum = 1:numel(obj.labels(expi).names{flynum})
              if strcmp(obj.labels(expi).names{flynum}{bnum},oldbehaviorname),
                obj.labels(expi).names{flynum}{bnum} = behaviorName;
              end
              
            end
            
          end
          
        end
        
      else
        error('JLabelData:invalidBehaviorName','Invalid behavior name');
      end
    end
        
        
    % ---------------------------------------------------------------------
    function behaviorName = getBehaviorName(obj)
      % Get the behavior name, a string
      % ALXXX EXTENDED
      behaviorName = obj.labelnames{1};
    end
    
    function tf = isBehaviorName(obj,name)
      % as opposed to no-behavior name
      tf = any(strcmp(name,obj.classifiernames));
    end
    
    function tf = isNoBehaviorName(obj,name)
      tf = any(strcmp(name,obj.nobehaviornames));      
    end
    
    function iCls = classifierIndexForName(obj,name)
      tf = strcmp(name,obj.labelnames);
      assert(nnz(tf)==1);
      iCls = obj.labelidx.idxBeh2idxTL(tf);
    end
        
    % ---------------------------------------------------------------------
    function setNeedSave(obj)
      % Get the behavior name, a string
      obj.needsave = true;
    end
        
        
    % ---------------------------------------------------------------------
    function [success,msg] = SetMovieFileName(obj,moviefilename)
    % change/set the name of the movie within the experiment directory
    % will fail if movie files don't exist for any of the current
    % experiment directories (checked by CheckMovies)

      success = false; msg = '';

      if ischar(moviefilename),
        if ischar(obj.moviefilename) && strcmp(moviefilename,obj.moviefilename),
          success = true;
          return;
        end
        oldmoviefilename = obj.moviefilename;
        obj.moviefilename = moviefilename;
        %obj.ismovie = ~isempty(moviefilename) && obj.openmovie;
        [success1,msg] = obj.CheckMovies();
        if ~success1,
          obj.moviefilename = oldmoviefilename;
          return;
        end
        [success,msg] = obj.UpdateStatusTable('movie');
      end
      
    end
    
    
%     % ---------------------------------------------------------------------
%     function [success,msg] = SetLabelFileName(obj,labelfilename)
%     % [success,msg] = SetLabelFileName(obj,labelfilename)
%     % set the name of the label file within the experiment directory. this
%     % does not currently update labelidx, and probably should not be called
%     % once an experiment is open. 
%       
%       success = false;
%       msg = 'Error in JLabelData.SetLabelFileName()';
% 
%       if ischar(labelfilename),
%         if ischar(obj.labelfilename) && strcmp(labelfilename,obj.labelfilename),
%           success = true;
%           return;
%         end
% 
%         % reload labels from file
%         for expi = 1:obj.nexps,
%           [success1,msg] = obj.LoadLabelsFromFile(expi);
%           if ~success1,
%             return;
%           end
%         end
%         
%         obj.labelfilename = labelfilename;
%         [success,msg] = obj.UpdateStatusTable('label');   
%       else
%         
%       end
%       
%     end

        
%     % ---------------------------------------------------------------------
%     function setGTLabelsFromStructForAllExps(self,gtLabelsForAll)
%       nExps=length(self.gtExpDirNames);
%       for expi = 1:nExps,
%         self.loadGTLabelsFromStructForOneExp(expi,gtLabelsForAll(expi));
%         %self.gt_labelfilename = 0;
%         self.UpdateStatusTable('gt_label');   
%       end
%     end

    
    
%     % ---------------------------------------------------------------------
%     function [success,msg] = SetGTLabelFileName(obj,gt_labelfilename)
%     % [success,msg] = SetGTLabelFileName(obj,labelfilename)
%     % set the name of the *ground truth* label file within the experiment directory. this
%     % does not currently update labelidx, and probably should not be called
%     % once an experiment is open. 
% 
%       success = false;
%       msg = '';
% 
%       if ischar(gt_labelfilename),
%         if ischar(obj.gt_labelfilename) && strcmp(gt_labelfilename,obj.gt_labelfilename),
%           success = true;
%           return;
%         end
% 
%         % reload labels from file
%         for expi = 1:obj.nexps,
%           [success1,msg] = obj.LoadLabelsFromFile(expi);
%           if ~success1,
%             return;
%           end
%         end
%         
%         obj.gt_labelfilename = gt_labelfilename;
%         [success,msg] = obj.UpdateStatusTable('gt_label');   
%       end
%       
%     end
    

    % ---------------------------------------------------------------------
    function scoreFileName = getScoreFileName(obj)
      scoreFileName = obj.scorefilename;
    end
    
    
    % ---------------------------------------------------------------------
    function [success,msg] = setScoreFileName(obj,sfn)
      assert(iscellstr(sfn) && numel(sfn)==obj.nclassifiers,...
        'Number of score filenames must match number of classifiers.');
      assert(numel(sfn)==numel(unique(sfn)),...
        'Score filenames must be unique.');
      
      tfValid = cellfun(@JLabelData.isValidScoreFileName,sfn);
      if ~all(tfValid)
        error('JLabelData:scoreFileName',...
          'The following are not valid score filenames: %s',...
          civilizedStringFromCellArrayOfStrings(sfn(~tfValid)));
      end
      
      obj.scorefilename = sfn;
      obj.needsave = true;
      [success,msg] = obj.UpdateStatusTable('scores');
    end

% Status display
    

    % ---------------------------------------------------------------------
    function SetStatus(obj,varargin)
      % SetStatus(obj,<sprintf-like arguments>)
      % Update an associated status text according to the input sprintf-like
      % arguments.
      
      if isempty(obj.setstatusfn),
        fprintf(varargin{:});
        fprintf('\n');
      else
        obj.setstatusfn(sprintf(varargin{:}));
        drawnow;
      end
      %       allF = findall(0,'type','figure');
      %       jfigNdx = find(strcmp(get(allF,'name'),'JAABA'));
      %       jfig = allF(jfigNdx);
      %       if ~isempty(jfig),
      %         set(jfig,'pointer','watch');
      %       end
    end  % method
    
    
    % ---------------------------------------------------------------------
    function ClearStatus(obj)
      % ClearStatus(obj)
      % Return an associated status text to the default.
      
      if ~isempty(obj.clearstatusfn),
        obj.clearstatusfn();
        drawnow;
      end
    end  % method

%     % ---------------------------------------------------------------------
%     function [success,msg] = SetClassifierType(obj,classifiertype)
% 
%       success = true;
%       msg = '';
%       
%       % TODO: retrain classifier if necessary
%       if strcmpi(classifiertype,obj.classifiertype),
%         return;
%       end
%       
%       obj.classifiertype = classifiertype;
%       
%     end
    

%     % ---------------------------------------------------------------------
%     function [success,msg] = LoadLabelsFromExternalFile(obj,expdir,labelfilename)
%       
%       success = false; msg = '';
%       if ~exist(labelfilename,'file'),
%         msg = sprintf('Label file %s does not exist',labelfilename);
%         return;
%       end
%       expi = find(strcmp(expdir,obj.expdirs),1);
%       if isempty(expi),
%         msg = sprintf('Experiment %s not loaded in',expdir);
%         return;
%       end
% 
%       obj.SetStatus('Loading labels for %s from %s',obj.expdirs{expi},labelfilename);
%       
%       %         try
%       loadedlabels = load(labelfilename,'t0s','t1s','names','flies','off','timestamp');
%       
%       if obj.IsGTMode(),
%         obj.gt_labels(expi).t0s = loadedlabels.t0s;
%         obj.gt_labels(expi).t1s = loadedlabels.t1s;
%         obj.gt_labels(expi).names = loadedlabels.names;
%         obj.gt_labels(expi).flies = loadedlabels.flies;
%         obj.gt_labels(expi).off = loadedlabels.off;
%         obj.gt_labelstats(expi).nflies_labeled = size(loadedlabels.flies,1);
%         obj.gt_labelstats(expi).nbouts_labeled = numel([loadedlabels.t0s{:}]);
%         
%         if iscell(loadedlabels.timestamp)
%           obj.gt_labels(expi).timestamp = loadedlabels.timestamp;
%         else
%           for ndx = 1:numel(loadedlabels.flies)
%             nBouts = numel(loadedlabels.t0s{ndx});
%             if isempty(loadedlabels.timestamp)
%               obj.gt_labels(expi).timestamp{ndx}(1:nBouts) = now;
%             else
%               obj.gt_labels(expi).timestamp{ndx}(1:nBouts) = loadedlabels.timestamp;
%             end
%           end
%         end
%         
%         if ~isempty(whos('-file',labelfilename,'imp_t0s'))
%           loadedimp = load(labelfilename,'imp_t0s','imp_t1s');
%           obj.gt_labels(expi).imp_t0s = loadedimp.imp_t0s;
%           obj.gt_labels(expi).imp_t1s = loadedimp.imp_t1s;
%         else
%           obj.gt_labels(expi).imp_t0s = cell(1,numel(loadedlabels.flies));
%           obj.gt_labels(expi).imp_t1s = cell(1,numel(loadedlabels.flies));
%         end
%         
%       else
%         
%         obj.labels(expi).t0s = loadedlabels.t0s;
%         obj.labels(expi).t1s = loadedlabels.t1s;
%         obj.labels(expi).names = loadedlabels.names;
%         obj.labels(expi).flies = loadedlabels.flies;
%         obj.labels(expi).off = loadedlabels.off;
%         obj.labelstats(expi).nflies_labeled = size(loadedlabels.flies,1);
%         obj.labelstats(expi).nbouts_labeled = numel([loadedlabels.t0s{:}]);
%         if iscell(loadedlabels.timestamp)
%           obj.labels(expi).timestamp = loadedlabels.timestamp;
%         else
%           for ndx = 1:numel(loadedlabels.flies)
%             nBouts = numel(loadedlabels.t0s{ndx});
%             if isempty(loadedlabels.timestamp)
%               obj.labels(expi).timestamp{ndx}(1:nBouts) = now;
%             else
%               obj.labels(expi).timestamp{ndx}(1:nBouts) = loadedlabels.timestamp;
%             end
%           end
%         end
%         if ~isempty(whos('-file',labelfilename,'imp_t0s'))
%           loadedimp = load(labelfilename,'imp_t0s','imp_t1s');
%           obj.labels(expi).imp_t0s = loadedimp.imp_t0s;
%           obj.labels(expi).imp_t1s = loadedimp.imp_t1s;
%         else
%           obj.labels(expi).imp_t0s = cell(1,numel(loadedlabels.flies));
%           obj.labels(expi).imp_t1s = cell(1,numel(loadedlabels.flies));
%         end
%         
%       end
%         %         catch ME,
%         %           msg = getReport(ME);
%         %           obj.ClearStatus();
%         %           return;
%         %         end
%       
%       obj.ClearStatus();
%       success = true;
%       
%     end
    

%     % ---------------------------------------------------------------------
%     function [success,msg] = LoadLabelsFromFile(obj,expi)
%     % [success,msg] = LoadLabelsFromFile(obj,expi)
%     % If the label file exists, this function loads labels for experiment
%     % expi into obj.labels. Otherwise, it sets the labels to be empty. This
%     % does not currently update the windowdata and labelidx (TODO). 
%       
%       %success = false;
%       msg = '';
%       labelfilename = obj.GetFile('label',expi);
%       
%       % if the labelfilename is zero, it means we're using the new
%       % "everything" file, and we shouldn't load labels from the experiment
%       % dir.
%       if ischar(labelfilename) && exist(labelfilename,'file'),
% 
%         obj.SetStatus('Loading labels for %s',obj.expdirs{expi});
%         
%         %         try
%         loadedlabels = load(labelfilename,'t0s','t1s','names','flies','off','timestamp');
%         obj.labels(expi).t0s = loadedlabels.t0s;
%         obj.labels(expi).t1s = loadedlabels.t1s;
%         obj.labels(expi).names = loadedlabels.names;
%         obj.labels(expi).flies = loadedlabels.flies;
%         obj.labels(expi).off = loadedlabels.off;
%         obj.labelstats(expi).nflies_labeled = size(loadedlabels.flies,1);
%         obj.labelstats(expi).nbouts_labeled = numel([loadedlabels.t0s{:}]);
%         if iscell(loadedlabels.timestamp)
%           obj.labels(expi).timestamp = loadedlabels.timestamp;
%         else
%           for ndx = 1:numel(loadedlabels.flies)
%             nBouts = numel(loadedlabels.t0s{ndx});
%             if isempty(loadedlabels.timestamp)
%               obj.labels(expi).timestamp{ndx}(1:nBouts) = now;
%             else
%               obj.labels(expi).timestamp{ndx}(1:nBouts) = loadedlabels.timestamp;
%             end
%           end
%         end
%         if ~isempty(whos('-file',labelfilename,'imp_t0s'))
%           loadedimp = load(labelfilename,'imp_t0s','imp_t1s');
%           obj.labels(expi).imp_t0s = loadedimp.imp_t0s;
%           obj.labels(expi).imp_t1s = loadedimp.imp_t1s;
%         else
%           obj.labels(expi).imp_t0s = cell(1,numel(loadedlabels.flies));
%           obj.labels(expi).imp_t1s = cell(1,numel(loadedlabels.flies));    % all the labeled frames. 
%         end
%         %         catch ME,
%         %           msg = getReport(ME);
%         %           obj.ClearStatus();
%         %           return;
%         %         end
%         
%         obj.ClearStatus();
%         
%       else
%         
%         obj.labels(expi).t0s = {};
%         obj.labels(expi).t1s = {};
%         obj.labels(expi).names = {};
%         obj.labels(expi).flies = [];
%         obj.labels(expi).off = [];
%         obj.labels(expi).timestamp = {};
%         obj.labels(expi).imp_t0s = {};
%         obj.labels(expi).imp_t1s = {};
%         obj.labelstats(expi).nflies_labeled = 0;
%         obj.labelstats(expi).nbouts_labeled = 0;
% 
%       end
%       
%       % TODO: update windowdata
%       
%       success = true;
%       
%     end
    
    
%     % ---------------------------------------------------------------------
%     function loadGTLabelsFromStructForOneExp(self,expi,gtLabels)
%       % Load the GT labels for a single experiment into self.
%             
%       self.SetStatus('Loading GT labels for %s',self.expdirs{expi});
% 
%       self.gt_labels(expi).t0s = gtLabels.t0s;
%       self.gt_labels(expi).t1s = gtLabels.t1s;
%       self.gt_labels(expi).names = gtLabels.names;
%       self.gt_labels(expi).flies = gtLabels.flies;
%       self.gt_labels(expi).off = gtLabels.off;
%       self.gt_labelstats(expi).nflies_labeled = size(gtLabels.flies,1);
%       self.gt_labelstats(expi).nbouts_labeled = numel([gtLabels.t0s{:}]);
%       if iscell(gtLabels.timestamp)
%         self.gt_labels(expi).timestamp = gtLabels.timestamp;
%       else
%         for ndx = 1:numel(gtLabels.flies)
%           nBouts = numel(gtLabels.t0s{ndx});
%           if isempty(gtLabels.timestamp)
%             self.gt_labels(expi).timestamp{ndx}(1:nBouts) = now;
%           else
%             self.gt_labels(expi).timestamp{ndx}(1:nBouts) = gtLabels.timestamp;
%           end
%         end
%       end
%       if isfield(gtLabels,'imp_t0s');
%         self.gt_labels(expi).imp_t0s = gtLabels.imp_t0s;
%         self.gt_labels(expi).imp_t1s = gtLabels.imp_t1s;
%       else
%         self.gt_labels(expi).imp_t0s = cell(1,numel(gtLabels.flies));
%         self.gt_labels(expi).imp_t1s = cell(1,numel(gtLabels.flies));
%       end
% 
%       self.ClearStatus();
%     end
 
    
%     % ---------------------------------------------------------------------
%     function [success,msg] = LoadGTLabelsFromFile(obj,expi)
%     % [success,msg] = LoadGTLabelsFromFile(obj,expi)
%     % If the label file exists, this function loads labels for experiment
%     % expi into obj.gt_labels. Otherwise, it sets the gt_labels to be empty. This
%     % does not currently update the windowdata and labelidx (TODO). 
%       
%       %success = false; 
%       msg = '';
%       
%       labelfilename = obj.GetFile('gt_label',expi);
% 
%       % if the labelfilename is zero, it means we're using the new
%       % "everything" file, and we shouldn't load labels from the experiment
%       % dir.
%       if ischar(labelfilename) && exist(labelfilename,'file'),
%         
%         obj.SetStatus('Loading labels for %s',obj.expdirs{expi});
%         
%         %         try
%         loadedlabels = load(labelfilename,'t0s','t1s','names','flies','off','timestamp');
%         obj.gt_labels(expi).t0s = loadedlabels.t0s;
%         obj.gt_labels(expi).t1s = loadedlabels.t1s;
%         obj.gt_labels(expi).names = loadedlabels.names;
%         obj.gt_labels(expi).flies = loadedlabels.flies;
%         obj.gt_labels(expi).off = loadedlabels.off;
%         obj.gt_labelstats(expi).nflies_labeled = size(loadedlabels.flies,1);
%         obj.gt_labelstats(expi).nbouts_labeled = numel([loadedlabels.t0s{:}]);
% 
%         if iscell(loadedlabels.timestamp)
%           obj.gt_labels(expi).timestamp = loadedlabels.timestamp;
%         else
%           for ndx = 1:numel(loadedlabels.flies)
%             nBouts = numel(loadedlabels.t0s{ndx});
%             if isempty(loadedlabels.timestamp)
%               obj.gt_labels(expi).timestamp{ndx}(1:nBouts) = now;
%             else
%               obj.gt_labels(expi).timestamp{ndx}(1:nBouts) = loadedlabels.timestamp;
%             end
%           end
%         end
%         
%         if ~isempty(whos('-file',labelfilename,'imp_t0s'))
%           loadedimp = load(labelfilename,'imp_t0s','imp_t1s');
%           obj.gt_labels(expi).imp_t0s = loadedimp.imp_t0s;
%           obj.gt_labels(expi).imp_t1s = loadedimp.imp_t1s;
%         else
%           obj.gt_labels(expi).imp_t0s = cell(1,numel(loadedlabels.flies));
%           obj.gt_labels(expi).imp_t1s = cell(1,numel(loadedlabels.flies));
%         end
%         %         catch ME,
%         %           msg = getReport(ME);
%         %           obj.ClearStatus();
%         %           return;
%         %         end
%         
%         obj.ClearStatus();
%         
%       else
%         
%         obj.gt_labels(expi).t0s = {};
%         obj.gt_labels(expi).t1s = {};
%         obj.gt_labels(expi).names = {};
%         obj.gt_labels(expi).flies = [];
%         obj.gt_labels(expi).off = [];
%         obj.gt_labels(expi).timestamp = {};
%         obj.gt_labels(expi).imp_t0s = {};
%         obj.gt_labels(expi).imp_t1s = {};
%         obj.gt_labelstats(expi).nflies_labeled = 0;
%         obj.gt_labelstats(expi).nbouts_labeled = 0;
%       end
%       
%       % TODO: update windowdata
%       
%       success = true;
%       
%     end
    

    % ---------------------------------------------------------------------
    function [success,msg] = SetPerFrameDir(obj,perframedir)
      % [success,msg] = SetPerFrameDir(obj,perframedir)
      % Sets the per-frame directory name within the experiment directory.
      % Currently, this does not change the cached per-frame data or check
      % that all the per-frame files necessary are within the directory
      % (TODO).
      
      success = false; msg = '';
      
      if ischar(perframedir),
        if ischar(obj.perframedir) && strcmp(perframedir,obj.perframedir),
          success = true;
          return;
        end
        
        obj.perframedir = perframedir;
        
        % TODO: check per-frame directories are okay, remove bad
        % experiments
        
        [success,msg] = obj.UpdateStatusTable('perframedir');
      end
      
    end
    
    
    % ---------------------------------------------------------------------
    function [success,msg] = SetClipsDir(obj,clipsdir)
    % [success,msg] = SetClipsDir(obj,clipsdir)
    % Sets the clips directory name within the experiment directory.
      
      success = true;
      msg = '';

      if ischar(clipsdir),
        for i = 1:numel(obj.expdirs),
          %clipsdircurr = fullfile(obj.expdirs{i},clipsdir);
%           if exist(obj.expdirs{i},'dir') && ~exist(clipsdircurr,'dir'),
%             mkdir(clipsdircurr);
%           end
        end
        if ischar(obj.clipsdir) && strcmp(clipsdir,obj.clipsdir),
          success = true;
          return;
        end

        obj.clipsdir = clipsdir;        
        [success,msg] = obj.UpdateStatusTable('clipsdir');
      end
      
    end

    
    % ---------------------------------------------------------------------
    function [success,msg] = SetDefaultPath(obj,defaultpath)
    % [success,msg] = SetDefaultPath(obj,defaultpath)
    % sets the default path to load experiments from. only checks for
    % existence of the directory.
      
      success = false;
      msg = '';
      
      if ischar(defaultpath),
        
        if ~isempty(defaultpath) && ~exist(defaultpath,'file'),
          msg = sprintf('defaultpath directory %s does not exist',defaultpath);
          return;
        end
          
        obj.defaultpath = defaultpath;
        success = true;
      end

    end
    
    function [success,msg] = SetExpDefaultPath(obj,defaultpath)
    % [success,msg] = SetDefaultPath(obj,defaultpath)
    % sets the default path to load experiments from. only checks for
    % existence of the directory.
      
      success = false;
      msg = '';
      
      if ischar(defaultpath),
        
        if ~isempty(defaultpath) && ~exist(defaultpath,'file'),
          msg = sprintf('defaultpath directory %s does not exist',defaultpath);
          return;
        end
          
        obj.expdefaultpath = defaultpath;
        success = true;
      end

    end
    
    
%     % ---------------------------------------------------------------------
%     function [success,msg] = SetRootOutputDir(obj,rootoutputdir)
%     % [success,msg] = SetRootOutputDir(obj,rootoutputdir)
%     % sets the root directory for outputing files. currently, it does not
%     % update labels, etc. or recheck for the existence of all the required
%     % files. (TODO)
%       
%       success = true;
%       msg = '';
%       if ischar(rootoutputdir),
%         if ischar(obj.rootoutputdir) && strcmp(obj.rootoutputdir,rootoutputdir),
%           success = true;
%           return;
%         end
%         if ~exist(rootoutputdir,'file'),
%           msg = sprintf('root output directory %s does not exist, outputs will be stored in the experiment directories',...
%             rootoutputdir);
%           success = false;
%           return;
%         end
%         obj.rootoutputdir = rootoutputdir;
%         for i = 1:obj.nexps,
%           obj.outexpdirs{i} = fullfile(rootoutputdir,obj.expnames{i});
%         end
%         % TODO: check all files are okay, remove bad experiments
%         
%         [success,msg] = obj.UpdateStatusTable();
%       end
%       
%     end    

    
%     % ---------------------------------------------------------------------
%     function [success,msg] = SetClassifierFileName(self,classifierfilename,varargin)
%     % [success,msg] = SetClassifierFileName(obj,classifierfilename)
%     % Sets the name of the classifier file. If the classifier file exists, 
%     % it loads the data stored in the file. This involves removing all the
%     % experiments and data currently loaded, setting the config file,
%     % setting all the file names set in the config file, setting the
%     % experiments to be those listed in the classifier file, clearing all
%     % the previously computed window data and computing the window data for
%     % all the labeled frames. 
%       [classifierlabels,doreadconfigfile] = ...
%         myparse(varargin,...
%                 'classifierlabels',false,...
%                 'doreadconfigfile',true);
%       success = false;
%       msg = '';
%       self.classifierfilename = classifierfilename;
%       if ~isempty(classifierfilename) && exist(classifierfilename,'file'),
%         classifierParams = load(self.classifierfilename);
%         [success,msg]= ...
%           self.setClassifierParamsOld(classifierParams, ...
%                                       'classifierfilename',classifierfilename, ...
%                                       'classifierlabels',classifierlabels, ...
%                                       'doreadconfigfile',doreadconfigfile);
%       end
%     end  % method

    
%     % ---------------------------------------------------------------------
%     function [success,msg] = setClassifierParamsOld(obj, ...
%                                                     classifierParams, ...
%                                                     varargin)
%       % [success,msg] = SetClassifierFileName(obj,classifierfilename)
%       % Sets the name of the classifier file. If the classifier file exists,
%       % it loads the data stored in the file. This involves removing all the
%       % experiments and data currently loaded, setting the config file,
%       % setting all the file names set in the config file, setting the
%       % experiments to be those listed in the classifier file, clearing all
%       % the previously computed window data and computing the window data for
%       % all the labeled frames.
%       
%       [classifierlabels,doreadconfigfile,classifierfilename] = ...
%         myparse(varargin,...
%                 'classifierlabels',false, ...
%                 'doreadconfigfile',true, ...
%                 'classifierfilename',0);
%     
%       success = false;  %#ok
%       msg = '';  %#ok
%       
%       obj.classifierfilename = classifierfilename;
% 
%       if ischar(classifierParams.labelfilename) && ~strcmp(classifierParams.labelfilename,obj.labelfilename),
%         success = false;
%         msg = sprintf(['Label file name specified for the project (%s) don''t match' ...
%           ' the label file name used to train the classifier (%s). Not loading the classifier'],...
%           obj.labelfilename,classifierParams.labelfilename);
%         return;
%       end
% 
%       if ischar(classifierfilename)
%         obj.SetStatus('Loading classifier from %s',obj.classifierfilename);
%       else
%         obj.SetStatus('Loading classifier...');
%       end
% 
%       % remove all experiments
%       obj.RemoveExpDirs(1:obj.nexps);
% 
%       if doreadconfigfile,
%         % set config file
%         %     if ~strcmp(obj.configfilename,'configfilename'),
%         %       obj.SetConfigFileName(classifierParams.configfilename);
%         %     end
% 
%         % set movie
%         [success,msg] = obj.SetMovieFileName(classifierParams.moviefilename);
%         if ~success,error(msg);end
% 
%         % trx
%         [success,msg] = obj.SetTrxFileName(classifierParams.trxfilename);
%         if ~success,error(msg);end
% 
%         % labelPreLoad
%         [success,msg] = obj.SetLabelFileName(classifierParams.labelfilename);
%         if ~success,error(msg);end
% 
%         % perframedir
%         [success,msg] = obj.SetPerFrameDir(classifierParams.perframedir);
%         if ~success,error(msg);end
% 
%         % clipsdir
%         [success,msg] = obj.SetClipsDir(classifierParams.clipsdir);
%         if ~success,error(msg);end
%       end
% 
%       % featureparamsfilename
% %           [success,msg] = obj.SetFeatureParamsFileName(classifierParams.featureparamsfilename);
% %           if ~success,error(msg);end
% 
%       % load actual window features params instead of filename.
%       if all( isfield(classifierParams,{'windowfeaturesparams','windowfeaturescellparams',...
%                                   'basicFeatureTable','maxWindowRadiusCommonCached'}))
% 
%         classifierParams.windowfeaturesparams = JLabelData.convertTransTypes2Cell(classifierParams.windowfeaturesparams);
%         classifierParams.windowfeaturescellparams = JLabelData.convertParams2CellParams(classifierParams.windowfeaturesparams);
%         if ~( isequal(obj.windowfeaturesparams,classifierParams.windowfeaturesparams) && ...
%                 isequal(obj.maxWindowRadiusCommonCached,classifierParams.maxWindowRadiusCommonCached)),
%             str = sprintf('Window feature parameters in the configuration file');
%             str = sprintf('%s\ndo not match the parameters saved in the classifier',str);
%             str = sprintf('%s\nUsing parameters stored in the classifier file',str);
%             uiwait(warndlg(str));
%             obj.setWindowFeaturesParams(classifierParams.windowfeaturesparams,...
%                                      classifierParams.basicFeatureTable,...
%                                      classifierParams.maxWindowRadiusCommonCached);
%         end
%       end
% 
%       if ~isfield(classifierParams,'featurenames')
%         feature_names = {};
%         for j = 1:numel(obj.curperframefns),
%           fn = obj.curperframefns{j};
%           [~,feature_names_curr] = ComputeWindowFeatures([0,0],...
%             obj.windowfeaturescellparams.(fn){:});
%           feature_names_curr = cellfun(@(x) [{fn},x],feature_names_curr,'UniformOutput',false);
%           feature_names = [feature_names,feature_names_curr]; %#ok<AGROW>
%         end
%         obj.windowdata.featurenames = feature_names;
%       else
%         obj.windowdata.featurenames = classifierParams.featurenames;
%       end
% 
% 
%       % rootoutputdir
% %           [success,msg] = obj.SetRootOutputDir(classifierParams.rootoutputdir);
% %           if ~success,error(msg); end
% 
%       % set experiment directories
%       if classifierlabels && isfield(classifierParams,'labels'),
%         [success,msg] = obj.SetExpDirs(classifierParams.expdirs,classifierParams.outexpdirs,...
%           classifierParams.nflies_per_exp,classifierParams.sex_per_exp,classifierParams.frac_sex_per_exp,...
%           classifierParams.firstframes_per_exp,classifierParams.endframes_per_exp);
%         if ~success,error(msg); end
%         obj.labels = classifierParams.labels;
%         [obj.labelidx,obj.t0_curr,obj.t1_curr] = obj.GetLabelIdx(obj.expi,obj.flies);
%         obj.labelidx_off = 1 - obj.t0_curr;
%         [success,msg] = obj.PreLoadPeriLabelWindowData();
%         if ~success,error(msg); end
%         obj.labelsLoadedFromClassifier = true;
%       else
%         if classifierlabels,
%           uiwait(warndlg('The classifier file didn''t have any labels. Loading the current labels'));
%         end
%         [success,msg] = obj.SetExpDirs(classifierParams.expdirs,classifierParams.outexpdirs,...
%           classifierParams.nflies_per_exp,classifierParams.sex_per_exp,classifierParams.frac_sex_per_exp,...
%           classifierParams.firstframes_per_exp,classifierParams.endframes_per_exp);
%         if ~success,error(msg); end
%       end
%       [success,msg] = obj.UpdateStatusTable();
%       if ~success, error(msg); end
% 
%       % update cached data
% %           obj.windowdata = struct('X',[],'exp',[],'flies',[],'t',[],...
% %             'labelidx_cur',[],'labelidx_new',[],'featurenames',{{}},...
% %             'predicted',[],'predicted_probs',[],'isvalidprediction',[]);
%       [success,msg] = obj.PreLoadPeriLabelWindowData();
%       if ~success,error(msg);end
% 
%       obj.classifier = classifierParams.classifier;
%       obj.classifiertype = classifierParams.classifiertype;
%       obj.classifierTS = classifierParams.classifierTS;
%       obj.windowdata.scoreNorm = classifierParams.scoreNorm;
%       obj.confThresholds = classifierParams.confThresholds;
%       if isfield(classifierParams,'postprocessparams')
%         obj.postprocessparams = classifierParams.postprocessparams;
%       end
% 
%       paramFields = fieldnames(classifierParams.classifier_params);
%       for ndx = 1:numel(paramFields)
%         obj.classifier_params.(paramFields{ndx}) = classifierParams.classifier_params.(paramFields{ndx});
%       end
%       % predict for all loaded examples
%       obj.PredictLoaded();
% 
%       % set labelidx_cur
%       obj.SetTrainingData(classifierParams.trainingdata);
% 
% %           if strcmp(obj.classifiertype,'boosting'),
% %             [obj.windowdata.binVals, obj.windowdata.bins] = findThresholds(obj.windowdata.X);
% %           end
% 
%       % make sure inds is ordered correctly
%       if ~isempty(obj.classifier),
%         switch obj.classifiertype,
% 
%           case 'ferns',
%             waslabeled = obj.windowdata.labelidx_cur ~= 0;
%             obj.classifier.inds = obj.predict_cache.last_predicted_inds(waslabeled,:);
% 
%         end
%       end
% 
%       % clear the cached per-frame, trx data
%       obj.ClearCachedPerExpData();
% 
% %         catch ME,
% %           errordlg(getReport(ME),'Error loading classifier from file');
% %         end
% 
%       obj.ClearStatus();
%       obj.classifierfilename = classifierfilename;
%       obj.FindFastPredictParams();
%     end  % setClassifierParamsOld() method

    
%     % ---------------------------------------------------------------------
%     function setLabelsAndClassifier(self, ...
%                                     everythingParams)
%       % [success,msg] = SetClassifierFileName(obj,classifierfilename)
%       % Sets the name of the classifier file. If the classifier file exists,
%       % it loads the data stored in the file. This involves removing all the
%       % experiments and data currently loaded, setting the config file,
%       % setting all the file names set in the config file, setting the
%       % experiments to be those listed in the classifier file, clearing all
%       % the previously computed window data and computing the window data for
%       % all the labeled frames.
%       
%       % % new-style everything files don't use classifier file names
%       % self.classifierfilename = 0;
% 
%       % Update the status bar
%       self.SetStatus('Loading classifier and labels...');
% 
%       % remove all experiments, if presents
%       self.RemoveExpDirs(1:self.nexps);
% 
% %       % set movie
% %       [success,msg] = self.SetMovieFileName(everythingParams.file.moviefilename);
% %       if ~success,error(msg);end
% %       
% %       % trx
% %       [success,msg] = self.SetTrxFileName(everythingParams.file.trxfilename);
% %       if ~success,error(msg);end
% % 
% %       % perframedir
% %       [success,msg] = self.SetPerFrameDir(everythingParams.file.perframedir);
% %       if ~success,error(msg);end
% %       
% %       % clipsdir
% %       [success,msg] = self.SetClipsDir(everythingParams.file.clipsdir);
% %       if ~success,error(msg);end
% 
%       % load the feature names
%       %self.windowdata.featurenames = everythingParams.featurenames;
% 
%       % set experiment directories
%       [success,msg] = ...
%         self.SetExpDirs(everythingParams.expdirs);
%       if ~success,error(msg); end
%       
%       % Update the status table
%       [success,msg] = self.UpdateStatusTable();
%       if ~success, error(msg); end
% 
% %       % update cached data  -- original location (does nothing)
% %       [success,msg] = self.PreLoadPeriLabelWindowData();
% %       if ~success,error(msg);end   
%       
%       % set the labels
%       self.setLabelsFromStructForAllExps(everythingParams.labels);
% 
%       % set the GT labels
%       self.setGTLabelsFromStructForAllExps(everythingParams.gtLabels);
% 
%       % Preload the first track of the first video, which sets the current
%       % experiment and track to experiment 1, track 1
%       if (self.nexps>0)
%         self.SetStatus('Pre-loading experiment %s...',self.expnames{1});
%         [success1,msg1] = self.setCurrentTarget(1,1);
%         if ~success1,
%           msg = sprintf('Error getting basic trx info: %s',msg1);
%           self.SetStatus('Error getting basic trx info for %s.',self.expnames{1});
%           uiwait(warndlg(msg));
%           self.RemoveExpDirs(1:obj.nexps);
%           self.ClearStatus();
%           return;
%         end
%       end
%                   
%       % Read certain fields out of the classifier, setting them in self
%       self.classifier = everythingParams.classifier.params;
%       self.classifiertype = everythingParams.classifier.type;
%       self.classifierTS = everythingParams.classifier.timeStamp;
%       self.windowdata.scoreNorm = everythingParams.classifier.scoreNorm;
%       self.confThresholds = everythingParams.classifier.confThresholds;
%       if isfield(everythingParams,'postprocessparams')
%         self.postprocessparams = everythingParams.classifier.postProcessParams;
%       end
%       
%       % Read the per-frame features to be used by a classifier
%       windowFeaturesParams=everythingParams.classifier.windowFeaturesParams;
%       %windowFeaturesCellParams= ...
%       %  JLabelData.convertParams2CellParams(windowFeaturesParams);
%       self.setWindowFeaturesParamsRaw(windowFeaturesParams);
%       %self.windowfeaturesparams=classifierParams.windowfeaturesparams;
%       %self.windowfeaturescellparams= ...
%       %  JLabelData.convertParams2CellParams(self.windowfeaturesparams);
%       %self.curperframefns=fieldnames(self.windowfeaturesparams);
%       self.basicFeatureTable=everythingParams.classifier.basicFeatureTable;
%       self.maxWindowRadiusCommonCached=everythingParams.classifier.maxWindowRadiusCommonCached;
%       
%       % Set the window feature names
%       feature_names = {};
%       for j = 1:numel(self.curperframefns),
%         fn = self.curperframefns{j};
%         [~,feature_names_curr_proto] = ComputeWindowFeatures([0,0],...
%                                                              self.windowfeaturescellparams.(fn){:});
%         feature_names_curr = cellfun(@(x) [{fn},x],feature_names_curr_proto,'UniformOutput',false);
%         feature_names = [feature_names,feature_names_curr]; %#ok<AGROW>
%       end
%       self.windowdata.featurenames = feature_names;
%       
%       % Read the classifier_params field out of the classifier.  This
%       % contains things like the number of iterations used for training,
%       % the number of folds used for cross-validation, etc.
%       self.classifier_params=everythingParams.classifier.trainingParams;
%       
%       % update cached data
%       [success,msg] = self.PreLoadPeriLabelWindowData();
%       if ~success,error(msg);end   
%       
%       % predict for all loaded examples
%       self.PredictLoaded();
% 
%       % SetTrainingData() does nothing
%       % % set labelidx_cur
%       % self.SetTrainingData(everythingParams.trainingdata);
% 
%       % make sure inds is ordered correctly
%       if ~isempty(self.classifier),
%         switch self.classifiertype,
%           case 'ferns',
%             waslabeled = self.windowdata.labelidx_cur ~= 0;
%             self.classifier.inds = self.predict_cache.last_predicted_inds(waslabeled,:);
%         end
%       end
% 
%       % clear the cached per-frame, trx data
%       self.ClearCachedPerExpData();
% 
%       % Set the status bar back to the default message
%       self.ClearStatus();
%       
%       % No idea what this does -- ALT, Mar 5, 2013
%       self.FindFastPredictParams();
%     end  % setLabelsAndClassifier() method

    
    % ---------------------------------------------------------------------
    function setAllLabels(self, ...
                          everythingParams)
      % MERGEST OK
      
      % AL 20141125: Unnecessary, SetExpDirs() call handles this
%       if self.nexps>0
%         self.RemoveExpDirs(1:self.nexps);
%       end

      if self.gtMode
        dirNames = everythingParams.gtExpDirNames;
        labels = everythingParams.gtLabels;
        self.otherModeLabelsEtc = struct('expDirNames',{everythingParams.expDirNames}, ...
                                       'labels',{everythingParams.labels});
      else
        % Normal labeling mode (not GT)
        dirNames = everythingParams.expDirNames;
        labels = everythingParams.labels;
        self.otherModeLabelsEtc = struct('expDirNames',{everythingParams.gtExpDirNames}, ...
                                       'labels',{everythingParams.gtLabels});
      end
      assert(numel(dirNames)==numel(labels));

      [success,msg] = self.SetExpDirs(dirNames);
      if ~success, error(msg); end
      
      [success,msg] = self.UpdateStatusTable();
      if ~success, error(msg); end

      self.setLabelsFromStructForAllExps(labels);
      
      % % set the GT labels
      % self.setGTLabelsFromStructForAllExps(everythingParams.gtLabels);

      % Preload the first track of the first video, which sets the current
      % experiment and track to experiment 1, track 1
      if (self.nexps>0)
        self.SetStatus('Pre-loading experiment %s...',self.expnames{1});
        [success1,msg1] = self.setCurrentTarget(1,1);
        if ~success1
          msg = sprintf('Error getting basic trx info: %s',msg1);
          self.SetStatus('Error getting basic trx info for %s.',self.expnames{1});
          uiwait(warndlg(msg));
          self.RemoveExpDirs(1:obj.nexps);
          self.ClearStatus();
          return;
        end
      end
                  
      % % update cached dataset
      % [success,msg] = self.PreLoadPeriLabelWindowData();  % need to move!!
      % if ~success,error(msg);end   
      
      % clear the cached per-frame, trx data
      self.ClearCachedPerExpData();
    end

    
    % ---------------------------------------------------------------------
    function setClassifierStuff(self,classifierStuff)
      % classifierStuff: array of ClassifierStuffs
      %
      % ALTODO: Seems like classifier-related properties can be
      % consolidated/cleaned up. Why not just use ClassifierStuff?
      
      %MERGESTUPDATED
      
      classifierStuff.modernize();
      
      nrealbeh = self.ntimelines;
      assert(numel(classifierStuff)==nrealbeh);
      self.classifiertype = cell(1,nrealbeh);
      self.classifier = cell(1,nrealbeh);
      self.classifier_params = cell(1,nrealbeh);
      self.classifierTS = nan(1,nrealbeh);
      self.confThresholds = nan(nrealbeh,2);
      self.postprocessparams = cell(1,nrealbeh);
      self.savewindowdata = false(1,nrealbeh);
      for iBeh = 1:nrealbeh
        cs = classifierStuff(iBeh);
        self.classifiertype{iBeh} = cs.type;
        self.classifier{iBeh} = cs.params;
        self.classifier_params{iBeh} = cs.trainingParams;
        self.classifierTS(iBeh) = cs.timeStamp;
        self.confThresholds(iBeh,:) = cs.confThresholds;
        self.windowdata(iBeh).scoreNorm = cs.scoreNorm;
        self.postprocessparams{iBeh} = cs.postProcessParams;
        self.savewindowdata(iBeh) = cs.savewindowdata;
      end
            
      % AL20141122: Why are we setting windowfeaturenames? This only
      % depends on self.curperframefns and self.windowfeaturescellparams.
      self.SetWindowFeatureNames();
      
      % AL20141126: initialization of loadwindowdata is change from earlier
      % behavior
      self.loadwindowdata = true(1,nrealbeh);
      
      % verify windowFeatureNames in classifierStuff
      for iBeh = 1:nrealbeh
        cs = classifierStuff(iBeh);
        if ~isempty(cs.featureNames) && ...
           ~isempty(cs.featureNames{1}) && ...
           ~isequal(cs.featureNames,self.windowdata(iBeh).featurenames)
          warnstr = sprintf('The feature names stored in the jab file don''t match the current feature names. The loaded classifier ''%s'' shouldn''t be used; retrain a new classifier.',...
            self.labelnames{iBeh});
          uiwait(warndlg(warnstr));
          self.loadwindowdata(iBeh) = false;
        end
      end
            
      self.trainstats = cell(1,nrealbeh);

      % Update the window data near the labels
%       [success,msg] = self.PreLoadPeriLabelWindowData();
%       if ~success,error(msg);end   

      % Move the current predictions out of the way
      self.MoveCurPredictionsToOld();
      
      if ~self.isST
        
        % Set up for fast prediction
        self.FindFastPredictParams();

        % predict for all loaded examples
        self.PredictLoaded();

      end
    end  % setClassifierStuff() method
    
    function setClassifierParams(self,params)
      %MERGESTUPDATED
      
      assert(iscell(params) && numel(params)==self.nclassifiers);
      oldParams = self.classifier_params;      
      
      for iCls = 1:self.nclassifiers
        prm0 = oldParams{iCls};
        prm1 = params{iCls};
        if prm0.numBins~=prm1.numBins
          self.windowdata(iCls).binVals = [];
          self.windowdata(iCls).bins = [];
        end
      end
      self.classifier_params = params(:)';
    end

    
    % ---------------------------------------------------------------------
    function clearClassifierProper(self)
      % Reset the classifier to a blank slate
      
%       % Get the current classifier
%       classifierStuff=self.getClassifierStuff();
% 
%       % Set the core classifier fields to default
%       classifierStuff.params=struct([]);
%       classifierStuff.timeStamp=[];
%       classifierStuff.scoreNorm=[];
% 
%       % Set the classifier in the JLabelData object
%       self.setClassifierStuff(classifierStuff);
      %self.ClearWindowData();
      self.classifier = struct('dim',{}, ...
                             'error',{}, ...
                             'dir',{}, ....
                             'tr',{}, ...
                             'alpha',{});  % 0x1 struct array
      nCls = self.nclassifiers;
      self.classifier = repmat({self.classifier},1,nCls); % ALTODO scattered classifier initialization: JLD, ProjectSetup
      self.classifier_old = self.classifier;
      self.classifierTS = zeros(1,nCls); 
      for iCls = 1:nCls
        self.windowdata(iCls).scoreNorm = 0;
      end
      self.invalidatePredictions();
      self.UpdatePredictedIdx(); % update cached predictions for current target
      self.needsave = true;
      %self.PreLoadPeriLabelWindowData();  % do we need to do this?
    end  

    
%     % ---------------------------------------------------------------------
%     function [success,msg] = SetClassifierFileNameWoExp(obj,classifierfilename)
% 
%       success = false;
%       msg = '';
%       
%       obj.classifierfilename = classifierfilename;
%       if ~isempty(classifierfilename) && exist(classifierfilename,'file'),
% %         try
% 
%           loadeddata = load(obj.classifierfilename); %,obj.classifiervars{:});
% 
%           if ~strcmp(loadeddata.labelfilename,obj.labelfilename),
%             success = false;
%             msg = ['Label files specified for the project doesn''t match the labelfiles '...
%               'used to train the classifier. Not loading the classifier'];
%             return;
%           end
%           
%           obj.SetStatus('Loading classifier from %s',obj.classifierfilename);
% 
%           % remove all experiments
%           % obj.RemoveExpDirs(1:obj.nexps);
% 
%           % set config file
% %           if ~strcmp(obj.configfilename,'configfilename'),
% %             obj.SetConfigFileName(loadeddata.configfilename);
% %           end
% 
%           % set movie
%           [success,msg] = obj.SetMovieFileName(loadeddata.moviefilename);
%           if ~success,error(msg);end
% 
%           % trx
%           [success,msg] = obj.SetTrxFileName(loadeddata.trxfilename);
%           if ~success,error(msg);end
%       
%           % label
%           [success,msg] = obj.SetLabelFileName(loadeddata.labelfilename);
%           if ~success,error(msg);end
%       
%           % perframedir
%           [success,msg] = obj.SetPerFrameDir(loadeddata.perframedir);
%           if ~success,error(msg);end
% 
%           % clipsdir
%           [success,msg] = obj.SetClipsDir(loadeddata.clipsdir);
%           if ~success,error(msg);end
% 
%           % featureparamsfilename
% %           [success,msg] = obj.SetFeatureParamsFileName(loadeddata.featureparamsfilename);
% %           if ~success,error(msg);end
% 
%           % load actual window features params instead of filename.
%           if all( isfield(loadeddata,{'windowfeaturesparams','windowfeaturescellparams',...
%               'basicFeatureTable','maxWindowRadiusCommonCached'}))
%             loadeddata.windowfeaturesparams = JLabelData.convertTransTypes2Cell(loadeddata.windowfeaturesparams);
%             loadeddata.windowfeaturescellparams = JLabelData.convertParams2CellParams(loadeddata.windowfeaturesparams);
%             if ~( isequal(obj.windowfeaturesparams,loadeddata.windowfeaturesparams) && ...
%                   isequal(obj.maxWindowRadiusCommonCached,loadeddata.maxWindowRadiusCommonCached)),
%                 str = sprintf('Window feature parameters in the configuration file');
%                 str = sprintf('%s\ndo not match the parameters saved in the classifier',str);
%                 str = sprintf('%s\nUsing parameters stored in the classifier file',str);
%                 uiwait(warndlg(str));
%                 obj.setWindowFeaturesParams(loadeddata.windowfeaturesparams,...
%                   loadeddata.basicFeatureTable,...
%                   loadeddata.maxWindowRadiusCommonCached,false);
%             else
%               obj.MoveCurPredictionsToOld();
%               
%               obj.windowdata.scoreNorm = [];
%               % To later find out where each example came from.
%               
%               %           obj.windowdata.isvalidprediction = false(numel(islabeled),1);
%               
%               obj.FindFastPredictParams();
%               obj.PredictLoaded();
% 
%             end
%           end
%           
%           if ~isfield(loadeddata,'featurenames')
%             feature_names = {};
%             for j = 1:numel(obj.curperframefns),
%               fn = obj.curperframefns{j};
%               [~,feature_names_curr] = ComputeWindowFeatures([0,0],...
%                 obj.windowfeaturescellparams.(fn){:});
%               feature_names_curr = cellfun(@(x) [{fn},x],feature_names_curr,'UniformOutput',false);
%               feature_names = [feature_names,feature_names_curr]; %#ok<AGROW>
%             end
%             obj.windowdata.featurenames = feature_names;
%           else
%             obj.windowdata.featurenames = loadeddata.featurenames;
%           end
%           
%           % rootoutputdir
% %           [success,msg] = obj.SetRootOutputDir(loadeddata.rootoutputdir);
% %           if ~success,error(msg); end
% 
%           [success,msg] = obj.UpdateStatusTable();
%           if ~success, error(msg); end
%                          
% 
%           obj.classifier = loadeddata.classifier;
%           obj.classifiertype = loadeddata.classifiertype;
%           obj.classifierTS = loadeddata.classifierTS;
%           obj.classifier_params = loadeddata.classifier_params;
%           obj.windowdata.scoreNorm = loadeddata.scoreNorm;
%           obj.confThresholds = loadeddata.confThresholds;
%           obj.classifierfilename = filename;
%           paramFields = fieldnames(loadeddata.classifier_params);
%           for ndx = 1:numel(paramFields)
%             obj.classifier_params.(paramFields{ndx}) = loadeddata.classifier_params.(paramFields{ndx});
%           end
%           % obj.ClearCachedPerExpData();
%           obj.ClearStatus();
%           obj.FindFastPredictParams();
%  
%       end
%     end

    
    % ---------------------------------------------------------------------
    function [success,msg] = SetExpDirs(obj,expdirs)
    % Changes what experiments are currently being used for this
    % classifier. This function calls RemoveExpDirs to remove all current
    % experiments not in expdirs, then calls AddExpDirs to add the new
    % experiment directories. 

      % MERGESTUPDATED
      
      success = false;
      msg = '';
      
      if isnumeric(expdirs), % AL ?
        return;
      end
      
      if nargin < 2,
        error('Usage: obj.SetExpDirs(expdirs)');
      end
                  
      oldexpdirs = obj.expdirs;
      
      % remove all oldexpdirs that aren't in expdirs
      expi = find(~ismember(oldexpdirs,expdirs));
      if ~isempty(expi)
        [success1,msg] = obj.RemoveExpDirs(expi);
        if ~success1,
          return;
        end
      end

      % add all new expdirs that weren't in oldexpdirs
      idx = find(~ismember(expdirs,oldexpdirs));
      success = true;
      for i = idx(:)'
        [success1,msg1] = obj.AddExpDir(expdirs{i});
        success = success && success1;
        if isempty(msg),
          msg = msg1;
        else
          msg = sprintf('%s\n%s',msg,msg1);
        end        
      end

    end


%     % ---------------------------------------------------------------------
%     function [success,msg] = SetExpDirs(obj,expdirs,outexpdirs,nflies_per_exp,...
%         sex_per_exp,frac_sex_per_exp,firstframes_per_exp,endframes_per_exp)
%     % [success,msg] = SetExpDirs(obj,[expdirs,outexpdirs,nflies_per_exp,firstframes_per_exp,endframes_per_exp])
%     % Changes what experiments are currently being used for this
%     % classifier. This function calls RemoveExpDirs to remove all current
%     % experiments not in expdirs, then calls AddExpDirs to add the new
%     % experiment directories. 
% 
%       success = false;
%       msg = '';
%       
%       if isnumeric(expdirs),
%         return;
%       end
%       
%       if nargin < 2,
%         error('Usage: obj.SetExpDirs(expdirs,[outexpdirs],[nflies_per_exp])');
%       end
%       
%       isoutexpdirs = nargin > 2 && ~isnumeric(outexpdirs);
%       isnflies = nargin > 3 && ~isempty(nflies_per_exp);
%       issex = nargin > 4 && ~isempty(sex_per_exp);
%       isfracsex = nargin > 5 && ~isempty(frac_sex_per_exp);
%       isfirstframes = nargin > 6 && ~isempty(firstframes_per_exp);
%       isendframes = nargin > 7 && ~isempty(endframes_per_exp);
%       
%       % check inputs
%       
%       % sizes must match
%       if isoutexpdirs && numel(expdirs) ~= numel(outexpdirs),
%         error('expdirs and outexpdirs do not match size');
%       end
%       if isnflies && numel(expdirs) ~= numel(nflies_per_exp),
%         error('expdirs and nflies_per_exp do not match size');
%       end
%       
%       oldexpdirs = obj.expdirs;
%       
%       % remove oldexpdirs
%       
%       [success1,msg] = obj.RemoveExpDirs(find(~ismember(oldexpdirs,expdirs))); %#ok<FNDSB>
%       if ~success1,
%         return;
%       end
% 
%       % add new expdirs
%       idx = find(~ismember(expdirs,oldexpdirs));
%       success = true;
%       for i = idx,
%         params = cell(1,nargin-1);
%         params{1} = expdirs{i};
%         if isoutexpdirs,
%           params{2} = outexpdirs{i};
%         end
%         if isnflies,
%           params{3} = nflies_per_exp(i);
%         end
%         if issex,
%           params{4} = sex_per_exp{i};
%         end
%         if isfracsex,
%           params{5} = frac_sex_per_exp{i};
%         end
%         if isfirstframes,
%           params{6} = firstframes_per_exp{i};
%         end
%         if isendframes,
%           params{7} = endframes_per_exp{i};
%         end
%         [success1,msg1] = obj.AddExpDir(params{:});
%         success = success && success1;
%         if isempty(msg),
%           msg = msg1;
%         else
%           msg = sprintf('%s\n%s',msg,msg1);
%         end        
%       end
% 
%     end
    
    
    
% Saving and loading    


    % ---------------------------------------------------------------------
    function allScoresCell = PredictSaveMovie(self,expi,sfn)
    % Predicts for the whole movie and saves the scores.
    % 
    % expi: scalar, index of movie to predict
    % sfn: Either cellstr of length self.nclassifiers containing score
    %   filenames, or 0, in which case scores are not saved (but are returned)
    %
    % allScoresCell: cell array of lenght self.nclassifiers containing
    % scores for each classifier
    
    % MERGESTUPDATED
          
      if nargin < 3
        sfn = self.GetFile('scores',expi);
      end
      assert(isequal(sfn,0) || iscellstr(sfn) && numel(sfn)==self.nclassifiers);
      tfSaveScores = iscellstr(sfn);

      pdExp = self.predictdata{expi};
      nFly = self.nflies_per_exp(expi);
      firstFrms = self.firstframes_per_exp{expi};
      endFrms = self.endframes_per_exp{expi};
      assert(iscell(pdExp) && numel(pdExp)==nFly);
      assert(isequal(nFly,numel(firstFrms),numel(endFrms)));
      
      tf = JLabelData.AllPredictedScoresValid(pdExp,self.nclassifiers);
      if ~all(tf)
        allScoresCell = self.PredictWholeMovie(expi);
      else        
        self.SetStatus(sprintf('Exporting existing scores for movie %d:%s...',expi,self.expnames{expi}));
                
        % compile allScores from prediction data
        allScoresCell = cell(self.nclassifiers,1);
        for iCls = 1:self.nclassifiers
          allScores = ScoreFile.allScrs(nFly);
          allScores = ScoreFile.AllScrsInitFromPredData(allScores,pdExp,iCls,firstFrms,endFrms);
          allScores.postprocessparams = self.postprocessparams{iCls};
          allScores.scoreNorm = self.windowdata(iCls).scoreNorm;
          allScoresCell{iCls} = allScores;
        end
      end
      
      if tfSaveScores
        try
          self.SaveScores(allScoresCell,sfn);
        catch ME
          if nargout > 0
            warning('Could not save scores for experiment %s: %s',self.expnames{expi},getReport(ME));
          else
            error(getReport(ME));
          end
        end
      end
      self.AddScores(expi,allScoresCell,true);
      
      if self.predictdata{expi}{1}(1).loaded_valid(1) % AL: not sure what intent is here
        self.LoadScores(expi,sfn);
      end
    end
    
% AL 20141210 appears unused, and see below for a commented (identical?) method  
%     % ---------------------------------------------------------------------
%     function SaveCurScores(self,expi,sfn)
%     % Saves the current scores to a file.
%         
%       if nargin < 3
%         sfn = self.GetFile('scores',expi);
%       end
%     
%       if ~self.HasCurrentScores(),
%         %uiwait(warndlg('No scores to save'));
%         return
%       end
%       
%       allScores = struct('scores',{{}},'tStart',[],'tEnd',[],...
%                          'postprocessed',{{}},'postprocessparams',[]);
%       scores_valid = true;
%       pdExp = self.predictdata{expi};
%       nFly = self.nflies_per_exp(expi);
%       firstFrms = self.firstframes_per_exp{expi};
%       endFrms = self.endframes_epr_exp{expi};      
%       assert(iscell(pdExp) && numel(pdExp)==nFly);
%       assert(isequal(nFly,numel(firstFrms),numel(endFrms)));
%       
%       for fly = 1:nFly
%         
%       
%       end
%       
%       if ~scores_valid,
%         % uiwait(warndlg(['Scores have not been computed for all the frames for experiment ' ...
%         %  '%s. Cannot save the scores.'],self.expnames{expi}));
%         % return;
%         error('JLabelData.scoresHaveNotBeenComputed', ...
%               ['Scores have not been computed for all the frames of experiment ' ...
%                '%s. Cannot save the scores.'],self.expnames{expi});  %#ok
%       end
%       allScores.postprocessedparams = self.postprocessparams;
%       allScores.scoreNorm = self.windowdata.scoreNorm;
%       self.SaveScores(allScores,sfn);      
%     end  % method
    
  end
  
  methods (Access=public)
    
    % ---------------------------------------------------------------------
    function AddScores(obj,expi,allScoresCell,updateCurrent) 
      % Set .predictdata from allScores
      % allScoresCell: cell array of length nclassifiers
      % 
      % This sure seems like it should be a private method, but it's called
      % by JLabelGUIData.  -- ALT, Apr 18, 2013
      
      % MERGESTUPDATED
      
      if isscalar(allScoresCell) && isstruct(allScoresCell)
        allScoresCell = {allScoresCell};
      end
      assert(iscell(allScoresCell) && numel(allScoresCell)==obj.ntimelines);
      
      obj.SetStatus('Updating Predictions ...');
        
      for ibeh = 1:obj.ntimelines
        nFly = numel(allScoresCell{ibeh}.scores);
        assert(nFly==numel(obj.predictdata{expi}));
        for ndx = 1:nFly
          tStart = allScoresCell{ibeh}.tStart(ndx);
          tEnd = allScoresCell{ibeh}.tEnd(ndx);
          curScores = allScoresCell{ibeh}.scores{ndx}(tStart:tEnd);
          Nscore = tEnd-tStart+1;
          Npredict = numel(obj.predictdata{expi}{ndx}(ibeh).loaded_valid);
          if Npredict < Nscore
            warningNoTrace('JLabelData:scoreSizeMismatch',...
              'Scores for experiment %d, behavior %d, fly %d have more elements (%d) than expected (%d). Truncating scores.',...
              expi,ibeh,ndx,Nscore,Npredict);
            curScores = curScores(1:Npredict);            
          elseif Npredict > Nscore
            warningNoTrace('JLabelData:scoreSizeMismatch',...
              'Scores for experiment %d, behavior %d, fly %d have fewer elements (%d) than expected (%d). Padding with nans.',...
              expi,ibeh,ndx,Nscore,Npredict);
            curScores(end+1:Npredict) = nan;
          end
          if updateCurrent
            obj.predictdata{expi}{ndx}(ibeh).cur(:) = curScores;
            obj.predictdata{expi}{ndx}(ibeh).cur_valid(:) = true;
          else
            obj.predictdata{expi}{ndx}(ibeh).loaded(:) = curScores;
            obj.predictdata{expi}{ndx}(ibeh).loaded_valid(:) = true;
          end
        end
      end

      if ~isempty(obj.postprocessparams)
        [success,msg] = obj.ApplyPostprocessing();
        if ~success
          uiwait(warndlg(['Couldn''t apply postprocessing to the scores: ' msg]));
        end
      elseif ~updateCurrent,
        assert(false,'Deprecated codepath');
        for ibeh = 1:obj.ntimelines 
          for ndx = 1:numel(allScoresCell{ibeh}.loaded) % Out of date fieldname
            tStart = allScoresCell{ibeh}.tStart(ndx);
            tEnd = allScoresCell{ibeh}.tEnd(ndx);
            if isfield(allScoresCell{ibeh},'postprocessedscores'); % Out of date fieldname
              obj.postprocessparams = allScoresCell{ibeh}.postprocessparams;
              curpostprocessedscores = allScoresCell{ibeh}.postprocessedscores{ndx}(tStart:tEnd);
              obj.predictdata{expi}{ndx}(ibeh).loaded_pp(:) = curpostprocessedscores;
          else
              obj.predictdata{expi}{ndx}(ibeh).loaded_pp(:) = 0;
            end
          end
        end
      end
      
      obj.UpdatePredictedIdx();
      obj.ClearStatus();
    end

    
    % ---------------------------------------------------------------------
    function LoadScores(obj,expi,scorefns)
      
      %MERGESTUPDATED 
      
      assert(iscellstr(scorefns));
      Nscore = numel(scorefns);
      assert(Nscore==obj.nclassifiers); % must be one scorefile per classifier
      
      for i = 1:Nscore
        sfn = scorefns{i};
        if ~exist(sfn,'file')
          warndlg('Score file %s does not exist. Not loading scores',sfn);
          return;
        end
      end
      
      scorefnstr = civilizedStringFromCellArrayOfStrings(scorefns);
      obj.SetStatus('Loading scores for experiment %s from %s',obj.expnames{expi},scorefnstr);
      
      behNames = Labels.verifyBehaviorNames(obj.labelnames);
      assert(numel(behNames)==Nscore);
      allScoresCell = cell(1,Nscore);

%       winDataScoreNorm = obj.windowdata.scoreNorm;
%       % Windowdata.scoreNorm will be updated from scorefiles as appropriate
%       if numel(winDataScoreNorm)>Nscore
%         warningNoTrace('JLabelData:windataScoreNormTooBig','windowdata.scoreNorm has too many elements. Truncating, then loading from scorefile(s).');
%         obj.windowdata.scoreNorm = winDataScoreNorm(1:Nscore);
%       elseif numel(winDataScoreNorm<Nscore)
%         %warningNoTrace('JLabelData:windataScoreNormTooBig','windowdata.scoreNorm has too few elements. Padding with nans, then loading from scorefile(s).');
%         obj.windowdata.scoreNorm(end+1:Nscore) = nan;
%       end        
      for i = 1:Nscore
        sfn = scorefns{i};
        S = load(sfn); % Could use ScoreFile.load here
        
        % check the behavior name
        if isfield(S,'behaviorName')
          if ~strcmp(S.behaviorName,behNames{i})
            warning('LoadScores:possibleBehaviorMismatch',...
              'Possible behavior mismatch. Behavior name in score file: %s. Expected: %s.',S.behaviorName,behNames{i});
          end
        end
        
        if ~isempty(obj.classifierTS) && obj.classifierTS(i)>0
          if S.timestamp~=obj.classifierTS(i)
            uiwait(warndlg(sprintf(['Scores were computed using a classifier trained on %s'...
              ' while the current classifier was trained on %s'],datestr(S.timestamp),...
              datestr(obj.classifierTS(i))))),
          end
        end
        % AL 20141211: classifierfilename appears to be deprecated field
        if isfield(S,'classifierfilename') %~isempty(whos('-file',sfn,'classifierfilename'))
          classifierfilename = S.classifierfilename;
        else
          classifierfilename = '';
        end
        
        % Set windowdata.scoreNorm if necessary
        %if isempty(winDataScoreNorm) || all(isnan(winDataScoreNorm)) || all(winDataScoreNorm==0),
        if isnan(obj.windowdata(i).scoreNorm) || obj.windowdata(i).scoreNorm==0
          if isfield(S.allScores,'scoreNorm')
            scoreNorm = S.allScores.scoreNorm;
          elseif isa(classifierfilename,'Macguffin')
            % AL 20141211: should be deprecated codepath
            scoreNorm = classifierfilename.classifierStuff.windowdata.scoreNorm;
          elseif exist(classifierfilename,'file') && ~isempty(whos('-file',classifierfilename,'scoreNorm'))
            scoreNorm = load(classifierfilename,'scoreNorm');
          else
            scoreNorm = 1;
            uiwait(warndlg(sprintf('Score file %s did not have the score normalization. Setting it to 1',sfn)));
          end
          
          assert(isscalar(scoreNorm),'Expected scalar scoreNorm.');
          obj.windowdata(i).scoreNorm = scoreNorm;
        end
        
        allScoresCell{i} = S.allScores;
      end
      
      obj.AddScores(expi,allScoresCell,false);
      
      obj.ClearStatus();
    end
    
    
    % ---------------------------------------------------------------------
    function LoadScoresDefault(obj,expi)
      % MERGESTUPDATED
      
      [scorefns,tffound] = obj.GetFile('scores',expi);
      assert(iscellstr(scorefns));
      if any(~tffound)
        warndlg(sprintf('Missing scorefile(s) for experiment %d:%s',expi,obj.expdirs{expi}));
      else
        obj.LoadScores(expi,scorefns);
      end
    end
    
    %----------------------------------------------------------------------
%     function SaveClassifier(obj)
%     % SaveClassifier(obj)
%     % This function saves the current classifier to the file
%     % obj.classifierfilename. It first constructs a struct representing the
%     % training data last used to train the classifier, then adds all the
%     % data described in obj.classifiervars.       
%       
%       try
%         s=obj.saveableClassifier;  %#ok
%         save(obj.classifierfilename,'-struct','s');
%       catch ME,
%         errordlg(getReport(ME),'Error saving classifier to file');
%       end      
%       
%     end


    %----------------------------------------------------------------------
    function [labels,gtLabels]=getLabelsAndGTLabels(self)
      % Returns a single structure containing all the labels, suitable for
      % saving.
    
      % % short-circuit if no labels
      %if isempty(self.labels) && isempty(self.gt_labels), 
      %  labels=self.labels;
      %  gtLabels=self.gt_labels;
      %  return; 
      %end
          
      % Take the labels currently only in labelidx, and commit them to
      % self.labels
      self.StoreLabelsForCurrentAnimal();
      
      % Put the right labels in the right place
      if self.gtMode ,
        gtLabels=self.labels;
        labels=self.otherModeLabelsEtc.labels;
      else
        labels=self.labels;
        gtLabels=self.otherModeLabelsEtc.labels;
      end
        
    end

    
%     %----------------------------------------------------------------------
%     function SaveLabels(obj,expis)
%     % SaveLabels(obj,expis)
%     % For each experiment in expis, save the current set of labels to file.
%     % A backup of old labels is made if they exist and stored in
%     % <labelfilename>~
%     
%       if isempty(obj.labels), return; end
%     
%       if nargin<2
%         expis = 1:obj.nexps;
%       end
%       
% %       if obj.labelsLoadedFromClassifier,
% %         res = questdlg(['Labels were loaded from the classifier. Saving the'...
% %           ' labels will overwrite the current labels. Overwrite?'],...
% %           'Overwrite Current Labels?','Yes','No','Cancel','No');
% %         if ~strcmpi(res,'Yes'), return, end
% %       end
%       
%       % store labels in labelidx
%       obj.StoreLabelsAndPreLoadWindowData();
%       
%       for i = expis,
%         
%         
%         lfn = GetFile(obj,'label',i,true);
%         obj.SetStatus('Saving labels for experiment %s to %s',obj.expnames{i},lfn);
% 
%         didbak = false;
%         if exist(lfn,'file'),
%           [didbak,msg] = copyfile(lfn,[lfn,'~']);
%           if ~didbak,
%             warning('Could not create backup of %s: %s',lfn,msg);  
%           end
%         end
% 
%         t0s = obj.labels(i).t0s; %#ok<NASGU>
%         t1s = obj.labels(i).t1s; %#ok<NASGU>
%         names = obj.labels(i).names; %#ok<NASGU>
%         flies = obj.labels(i).flies; %#ok<NASGU>
%         off = obj.labels(i).off; %#ok<NASGU>
%         timestamp = obj.labels(i).timestamp; %#ok<NASGU>
%         imp_t0s = obj.labels(i).imp_t0s; %#ok<NASGU>
%         imp_t1s = obj.labels(i).imp_t1s; %#ok<NASGU>
%         
%         version = obj.version; %#ok<NASGU>
%         try
%           save(lfn,'t0s','t1s','names','flies','off','timestamp','imp_t0s','imp_t1s','version');
%         catch ME,
%           if didbak,
%             [didundo,msg] = copyfile([lfn,'~'],lfn);
%             if ~didundo, warning('Error copying backup file for %s: %s',lfn,msg); end %#ok<WNTAG>
%           end
%           errordlg(sprintf('Error saving label file %s: %s.',lfn,getReport(ME)),'Error saving labels');
%         end
%       end
% 
%       
%       [success,msg] = obj.UpdateStatusTable('label');
%       if ~success,
%         error(msg);
%       end
% 
%       obj.ClearStatus();
%     end


%     %----------------------------------------------------------------------    
%     function SaveGTLabels(obj,expis)
%     % SaveGTLabels(obj,expis)
%     % For each experiment in expis, save the current set of labels to file.
%     % A backup of old labels is made if they exist and stored in
%     % <labelfilename>~
% 
%       if isempty(obj.gt_labels), return; end
%       
%       if nargin<2
%         expis = 1:obj.nexps;
%       end
%       
%       % store labels in labelidx
%       obj.StoreLabelsAndPreLoadWindowData();
%       
%       for i = expis,
% 
%         lfn = GetFile(obj,'gt_label',i,true);
%         obj.SetStatus('Saving labels for experiment %s to %s',obj.expnames{i},lfn);
% 
%         didbak = false;
%         if exist(lfn,'file'),
%           [didbak,msg] = copyfile(lfn,[lfn,'~']);
%           if ~didbak,
%             warning('Could not create backup of %s: %s',lfn,msg); %#ok<WNTAG>
%           end
%         end
% 
%         t0s = obj.gt_labels(i).t0s; %#ok<NASGU>
%         t1s = obj.gt_labels(i).t1s; %#ok<NASGU>
%         names = obj.gt_labels(i).names; %#ok<NASGU>
%         flies = obj.gt_labels(i).flies; %#ok<NASGU>
%         off = obj.gt_labels(i).off; %#ok<NASGU>
%         timestamp = obj.gt_labels(i).timestamp; %#ok<NASGU>
%         imp_t0s = obj.gt_labels(i).imp_t0s; %#ok<NASGU>
%         imp_t1s = obj.gt_labels(i).imp_t1s; %#ok<NASGU>
%         
%         version = obj.version; %#ok<NASGU>
%         try
%           save(lfn,'t0s','t1s','names','flies','off','timestamp','imp_t0s','imp_t1s','version');
%         catch ME,
%           if didbak,
%             [didundo,msg] = copyfile([lfn,'~'],lfn);
%             if ~didundo, warning('Error copying backup file for %s: %s',lfn,msg); end %#ok<WNTAG>
%           end
%           errordlg(sprintf('Error saving label file %s: %s.',lfn,getReport(ME)),'Error saving labels');
%         end
%       end
% 
%       
%       [success,msg] = obj.UpdateStatusTable('gt_label');
%       if ~success,
%         error(msg);
%       end
% 
%       obj.ClearStatus();
%     end


    
% Experiment handling

    % ---------------------------------------------------------------------
    function [success,msg] = AddExpDir(obj, ...
                                       expDirName, ...
                                       interactivemode) %#ok
      % Add a new experiment to the GUI.  This does not change self.expi,
      % and does not do any preloading.
      
      %MERGESTOK
      
      % Set default return values
      success = false; msg = '';
      
      if isnumeric(expDirName)
        return; 
      end
      
      % interactive mode is not stored in the instance vars
      if exist('interactivemode','var')
        warning(['JLabelData.AddExpDir: Whether or not the JLabelData is interactive is now stored in the object.  ' ...
                 'Setting it for the call to AddExpDir() is ignored.']);
      end
      interactivemode = obj.isInteractive;

      % make sure directory exists
      obj.SetStatus('Checking that %s exists...',expDirName);
      if ~exist(expDirName,'file'),
        error('JLabelData:expDirDoesNotExist', '%s', ...
              expDirName);
      end
      
%       % Is there an output directory?
%       isoutexpdir = false;
      
      % Did the caller provide extra information about the tracks
      %istrxinfo = false;

      [~,expName] = myfileparts(expDirName);
      
%       % expnames and rootoutputdir must match (do we still need this?)
%       if isoutexpdir,
%         [rootoutputdir,outname] = myfileparts(outexpdir);
%         if ~strcmp(expname,outname),
%           msg = sprintf('expdir and outexpdir do not match base names: %s ~= %s',expname,outname);
%           return;
%         end
%       elseif ~ischar(obj.rootoutputdir),
%         outexpdir = expdir;
%         rootoutputdir = 0;
%       else
%         rootoutputdir = obj.rootoutputdir;        
%       end
      
%       if ischar(obj.rootoutputdir) && ~isoutexpdir,
%         outexpdir = fullfile(rootoutputdir,expname);
%       end
      %outexpdir=expDirName;

%       % create missing outexpdirs
%       if ~exist(outexpdir,'dir'),
%         [success1,msg1] = mkdir(rootoutputdir,expname);
%         if ~success1,
%           msg = (sprintf('Could not create output directory %s, failed to set expdirs: %s',outexpdir,msg1));
%           return;
%         end
%       end

      % create clips dir
      clipsdir = obj.GetFileName('clipsdir');
      outclipsdir = fullfile(expDirName,clipsdir);  %#ok

      % okay, checks succeeded, start storing stuff
      %obj.nexps = obj.nexps + 1;
      obj.expdirs{end+1} = expDirName;
      %obj.expnames{end+1} = expName;
      %obj.rootoutputdir = rootoutputdir;
      %obj.outexpdirs{end+1} = outexpdir;

      % If we call remove, it's to roll-back a failed experiment add, so we
      % don't want to set needsave in this case.
      needSaveIfSuccessfulRemoval = false;
      
      % Update the status table        
      obj.SetStatus('Updating status table for %s...',expName);
      [success,msg,missingfiles] = obj.UpdateStatusTable('',obj.nexps);
      missingfiles = missingfiles{obj.nexps};
      if ~success,
        obj.SetStatus('Bad experiment directory %s...',expDirName);
        obj.RemoveExpDirs(obj.nexps,needSaveIfSuccessfulRemoval);
        return;
      end
      
      % check for existence of necessary files in this directory
      if ~obj.filesfixable,
        msg = sprintf(['Experiment %s is missing required files that cannot '...
          'be generated within this interface. Removing...'],expDirName);
        obj.SetStatus('Bad experiment directory %s...',expDirName);
        success = false;
        % undo
        obj.RemoveExpDirs(obj.nexps,needSaveIfSuccessfulRemoval);
        return;
      end
      
      % Always regenerate the score feature perframe files, to make sure
      % they're from the right classifier
      % Have to do this _before_ calling GenerateMissingFiles() so that
      % when UpdateStatusTable() gets called wihtin GenerateMissingFiles(), 
      % any score feature perframe files are already in place
      [success,msg] = obj.GenerateScoreFeaturePerframeFiles(obj.nexps);
      if ~success,
        %msg = sprintf(['Error generating missing required files %s '...
        %  'for experiment %s: %s. Removing...'],...
        %  sprintf(' %s',missingfiles{:}),expDirName,msg);
        obj.SetStatus('Error generating score feature perframe files for %s...',expName);
        obj.RemoveExpDirs(obj.nexps,needSaveIfSuccessfulRemoval);
        return
      end
      
      % If some files are missing, and we can generate them, do so
      if obj.filesfixable && ~obj.allfilesexist,
        obj.SetStatus('Some files missing for %s...',expName);
        if interactivemode && isdisplay(),
          if isempty(obj.GetGenerateMissingFiles) || ~obj.GetGenerateMissingFiles()
            if numel(missingfiles)>10,
              missingfiles = missingfiles(1:10);
              missingfiles{end+1} = ' and more ';
            end
            % Would be good to move UI stuff out of JLabelData, which is
            % essentially a model in MVC terms --ALT, Apr 30, 2013
            res = questdlg(sprintf(['Experiment %s is missing required files:%s. '...
              'Generate now?'],expDirName,sprintf(' %s',missingfiles{:})),...
              'Generate missing files?','Yes','Cancel','Yes');
            if strcmpi(res,'Yes')
              obj.SetGenerateMissingFiles();
            end
          else 
            res = 'Yes';
          end
        else
          res = 'Yes';
        end
        if strcmpi(res,'Yes'),
          obj.SetStatus('Generating missing files for %s...',expName);
          [success,msg] = obj.GenerateMissingFiles(obj.nexps);
          if ~success,
            msg = sprintf(['Error generating missing required files %s '...
              'for experiment %s: %s. Removing...'],...
              sprintf(' %s',missingfiles{:}),expDirName,msg);
            obj.SetStatus('Error generating missing files for %s...',expName);
            obj.RemoveExpDirs(obj.nexps,needSaveIfSuccessfulRemoval);
            return;
          end
        else
          obj.SetStatus('Not generating missing files for %s, not adding...',expName);
          obj.RemoveExpDirs(obj.nexps,needSaveIfSuccessfulRemoval);
          return;
        end
      end
      
%       % Convert the scores file into perframe files.      
%       for i = 1:numel(obj.scoreFeatures)
%         obj.SetStatus('Generating score-based per-frame feature file %s for %s...',obj.scoreFeatures(i).scorefilename,expName);
%         [success,msg] = obj.ScoresToPerframe(obj.nexps, ...
%                                              obj.scoreFeatures(i).scorefilename, ...
%                                              obj.scoreFeatures(i).ts);
%           if ~success,
%             obj.SetStatus('Error generating score-based per-frame file %s for %s...',obj.scoreFeatures(i).scorefilename,expName);
%             obj.RemoveExpDirs(obj.nexps,needSaveIfSuccessfulRemoval);
%             return;
%           end
%       end
      
      % Set the fields describing the tracks, either using info provided by
      % the caller, or by reading from the trx file.
%       if istrxinfo,
%         obj.nflies_per_exp(end+1) = nFlies;
%         obj.sex_per_exp{end+1} = sex;
%         obj.frac_sex_per_exp{end+1} = fracSex;
%         obj.firstframes_per_exp{end+1} = firstFrames;
%         obj.endframes_per_exp{end+1} = endFrames;
%       else
      % Read from the trx file
      obj.SetStatus('Getting basic trx info for %s...',expName);
      trxFileNameAbs = fullfile(expDirName,obj.GetFileName('trx'));
      try
        [nFlies,firstFrames,endFrames,~,hasSex,fracSex,sex,hasperframesex] = ...
          JLabelData.readTrxInfoFromFile(trxFileNameAbs);
      catch err
         if (strcmp(err.identifier,'JAABA:JLabelData:readTrxInfoFromFile:errorReadingTrxFile'))
           msg = sprintf('Error getting basic trx info: %s',msg1);
           obj.SetStatus('Error getting basic trx info for %s, not adding...',expName);
           obj.RemoveExpDirs(obj.nexps,needSaveIfSuccessfulRemoval);
           return;
         else
           rethrow(err);
         end
      end
      obj.hassex = obj.hassex || hasSex;
      obj.hasperframesex = hasperframesex;
      obj.nflies_per_exp(end+1) = nFlies;
      obj.sex_per_exp{end+1} = sex;
      obj.frac_sex_per_exp{end+1} = fracSex;
      obj.firstframes_per_exp{end+1} = firstFrames;
      obj.endframes_per_exp{end+1} = endFrames;
%       end
      
      % Initialize the labels for the current labeling mode
      iExp = obj.nexps;
      obj.labels(iExp) = Labels.labels(1);
%       obj.labels(iExp).t0s = {};
%       obj.labels(iExp).t1s = {};
%       obj.labels(iExp).names = {};
%       obj.labels(iExp).flies = [];
%       obj.labels(iExp).off = [];
%       obj.labels(iExp).timestamp = {};
%       obj.labels(iExp).timelinetimestamp = {};
%       obj.labels(iExp).imp_t0s = {};
%       obj.labels(iExp).imp_t1s = {};
      obj.labelstats(iExp).nflies_labeled = 0;
      obj.labelstats(iExp).nbouts_labeled = 0;
      
      % Initialize the prediction data, if needed (?? --ALT, Mar 5 2013)
      if numel(obj.predictdata)<obj.nexps
        obj.SetStatus('Initializing prediction data for %s...',expName);
        obj.InitPredictionData(obj.nexps);
      end
            
      % % Set the default path to the experiment directory's parent
      obj.expdefaultpath = fileparts(expDirName);

      % Update the status
      obj.SetStatus('Successfully added experiment %s...',expDirName);
      
      % Declare victory
      obj.needsave = true;
      success = true;
    end
    
    function [success,msg] = AddExpDirAndLabelsFromJab(obj,jabfilename,importlabels)
      %MERGESTUPDATED
      
      assert(obj.nclassifiers==1,'Current project must be a single-classifier project.');
      % AL 20141219: In the multiclassifier world one can imagine a
      % different merge operation, where the incoming Jab contains new
      % classifiers/behaviors to be added to the current Jab.
      
      assert(~obj.isST,'ST: unsupported.'); % AL: for no good reason
      
      success = true; 
      msg = '';
      
      try
        Q = load(jabfilename,'-mat');
      catch ME
        success = false;
        msg = ME.message;
        return;
      end
      
      assert(isscalar(Q.x.classifierStuff),...
        'Jabfile ''%s'' is not a single-classifier project.',jabfilename);
      
      if obj.IsGTMode
        origExpDirNames = Q.x.gtExpDirNames;
        origLabels = Q.x.gtLabels;
        % modernize labels?
      else
        origExpDirNames = Q.x.expDirNames;
        origLabels = Q.x.labels;
        origLabels = Labels.modernizeLabels(origLabels,Q.x.behaviors.names);
      end
      assert(numel(origExpDirNames)==numel(origLabels));
      
      for ndx = 1:numel(origExpDirNames)
        expdirname = origExpDirNames{ndx};
        labels = origLabels(ndx);
        if importlabels % Change the names
          assert(numel(Q.x.behaviors.names)==2);
          origBehName = Q.x.behaviors.names{1};
          newBehName = obj.labelnames{1};
          labels = Labels.renameBehavior(labels,origBehName,newBehName,...
            origBehName,newBehName);
        end
        
        curexp = find(strcmp(expdirname,obj.expdirs));
        if isempty(curexp)
          [success,msg] = obj.AddExpDir(expdirname);
          if ~success
            return;
          end
          if importlabels
            obj.labels(end) = labels;
          end
        elseif importlabels
          tfLabelsUpdated = false;
          if obj.haslabels(curexp)
            dlgstr = sprintf('Experiment %s already has labels. Discard the existing (current) labels and load the new ones?',...
              expdirname);
            res = questdlg(dlgstr,'Load new labels?',...
              'Keep Existing','Load New','Cancel','Keep Existing');
            if strcmp(res,'Load New')
              obj.labels(curexp) = labels;
              tfLabelsUpdated = true;
            end
          else
            obj.labels(curexp) = labels;
            tfLabelsUpdated = true;
          end
          
          if tfLabelsUpdated && curexp==obj.expi
            % initialize .labelidx from .labels
            % AL 20141219: added tfLabelsUpdated condition; seems like we
            % only want to update .labelidx (especially from .labels) if
            % the new labels were accepted
            
            labelShort = Labels.labelsShort;
            [labelsShort,tffly] = Labels.labelsShortInit(labelShort,labels,obj.flies);            
            if tffly
              T0 = max(obj.GetTrxFirstFrame(obj.expi,obj.flies));
              T1 = min(obj.GetTrxEndFrame(obj.expi,obj.flies));
              labelidx = Labels.labelIdx(obj.labelnames,T0,T1);
              labelidx = Labels.labelIdxInit(labelidx,labelsShort);
              obj.labelidx = labelidx;
            else
              % none. obj.flies not present in new labels. .labelidx not 
              % updated, so may contain bouts that differ from .labels
            end
          end          
        end
      end
    end
    
    
    % ---------------------------------------------------------------------
    function has = haslabels(obj,expnum)
      obj.StoreLabelsForCurrentAnimal();
      has = false;
      for fly = 1:numel(obj.labels(expnum).flies)
        if ~isempty(obj.labels(expnum).t0s{fly})
          has = true;
        end
      end
    end    


    % ---------------------------------------------------------------------
    function [success,msg] = RemoveExpDirs(obj,expi,needSaveIfSuccessful)
      % [success,msg] = RemoveExpDirs(obj,expi,[needSaveIfSuccessful])
      % Removes experiments in expi from the GUI. If the currently loaded
      % experiment is removed, then a different experiment may be preloaded. 
      % If needSaveIfSuccessful is defined and true, the JLabelData's
      % needsave property will be set to true if the experiment is
      % successfully removed.  If needSaveIfSuccessful is not defined, is
      % empty, or is false, needsave will not be changed.  It is useful to
      % set needSaveIfSuccessful to false if RemoveExpDirs() is being called
      % in order to roll-back the partially-completed addition of an
      % experiment.

      %MERGESTUPDATED
      
      success = false;
      msg = '';
      
      if ~exist('needSaveIfSuccessful','var') || isempty(needSaveIfSuccessful)
        needSaveIfSuccessful = true;
      end
      
      if any(obj.nexps < expi) || any(expi < 1),
        msg = sprintf('expi = %s must be in the range 1 < expi < nexps = %d',mat2str(expi),obj.nexps);
        return;
      end
      
      origNExp = obj.nexps;
      newExpNumbers = zeros(1,obj.nexps);
      for ndx = 1:obj.nexps
        if ismember(ndx,expi);
          newExpNumbers(1,ndx) = 0;
        else
          newExpNumbers(1,ndx) = ndx-nnz(expi<ndx);
        end
      end
      
      if ~(numel(obj.expdirs)<expi)
        obj.expdirs(expi) = [];   
      end
      
      assert(nnz(newExpNumbers>0)==numel(obj.expdirs));
      
      % if ~(numel(obj.expnames)<expi); obj.expnames(expi) = []; end
      %if ~(numel(obj.outexpdirs)<expi); obj.outexpdirs(expi) = []; end
      if ~(numel(obj.nflies_per_exp)<expi); obj.nflies_per_exp(expi) = []; end
      if ~(numel(obj.sex_per_exp)<expi); obj.sex_per_exp(expi) = []; end
      if ~(numel(obj.frac_sex_per_exp)<expi); obj.frac_sex_per_exp(expi) = []; end
      if ~(numel(obj.firstframes_per_exp)<expi); obj.firstframes_per_exp(expi) = []; end
      if ~(numel(obj.endframes_per_exp)<expi); obj.endframes_per_exp(expi) = []; end
      if ~(numel(obj.labels)<expi); obj.labels(expi) = []; end
      if ~(numel(obj.labelstats)<expi); obj.labelstats(expi) = []; end
      %if ~(numel(obj.gt_labels)<expi); obj.gt_labels(expi) = []; end
      %if ~(numel(obj.gt_labelstats)<expi); obj.gt_labelstats(expi) = []; end
      %obj.nexps = obj.nexps - numel(expi);
      % TODO: exp2labeloff

      % Clean window data
      for iCls = 1:numel(obj.windowdata)
        wdExp = obj.windowdata(iCls).exp;
        assert(iscolumn(wdExp) || isequal(wdExp,[]));
        newExp = newExpNumbers(wdExp);
        obj.windowdata(iCls).exp = newExp(:);
      end
      % removed exps now have obj.windowdata.exp==0
      obj.windowdata = WindowData.windowdataTrim(obj.windowdata,@(x)x.exp==0);
      % AL 20141121. There used to be some odd code here:
      % - Not all windowdata fields trimmed, eg labelidx_old
      % - Code implied that many fields (eg labelidx_cur) did not have to 
      % size consistent with windowdata.X, eg size of labelidx_cur implied
      % to be different than labelidx_new
      WindowData.windowdataVerify(obj.windowdata);      

      for curex = sort(expi(:)','descend') %#ok<UDIM>
        if numel(obj.predictdata)>=curex
          obj.predictdata(curex) = [];
        end
      end
      
      nCls = obj.nclassifiers;
      pbfnames = fieldnames(obj.predictblocks);
      for iCls = 1:nCls
        if ~isempty(obj.predictblocks(iCls).expi)
          idxcurr = ismember(obj.predictblocks(iCls).expi,expi);
          for fndx = 1:numel(pbfnames)
            obj.predictblocks(iCls).(pbfnames{fndx})(idxcurr) = [];
            % all fields of predictblocks are currently row vecs
          end
          tmp = newExpNumbers(obj.predictblocks(iCls).expi);
          obj.predictblocks(iCls).expi = tmp(:)';
        end
      end
      
      if ~isempty(obj.randomGTSuggestions)
        assert(numel(obj.randomGTSuggestions)==origNExp);
        obj.randomGTSuggestions(expi) = [];
      end
      
      if ~isempty(obj.loadedGTSuggestions) && numel(obj.loadedGTSuggestions)>=expi 
        assert(numel(obj.loadedGTSuggestions)==origNExp);
        obj.loadedGTSuggestions(expi) = [];
      end

      % update current exp, flies
      if ~isempty(obj.expi) && obj.expi > 0 
        if ismember(obj.expi,expi), % The current experiment was removed.
          newexpi = find(newExpNumbers(obj.expi+1:end),1);
          if isempty(newexpi), % No next experiment.
            newexpi = find(newExpNumbers(1:obj.expi-1),1,'last');
            if isempty(newexpi), % No previous experiment either.
              newexpi = 0;
            else
              newexpi = newExpNumbers(newexpi);
            end
          else
            newexpi = newExpNumbers(obj.expi+newexpi);
          end
          obj.expi = 0;
          obj.flies = nan(size(obj.flies));
          if obj.nexps > 0,
            obj.setCurrentTarget(newexpi,1);
          end
        else
          obj.expi = obj.expi - nnz(ismember(1:obj.expi,expi));
        end
      end
      
      % Set needsave, if called for
      if needSaveIfSuccessful
        obj.needsave = true;
      end
      
      % Declare victory
      success = true;
    end  % method

    
% File Handling 
    
    % ---------------------------------------------------------------------
    function res = GetFileName(obj,fileType)
    % res = GetFileName(obj,fileType)
    % Get base name of file of the input type fileType.
      switch fileType,
        case 'movie',
          res = obj.moviefilename;
        case 'trx',
          res = obj.trxfilename;
%         case 'label',
%           res = obj.labelfilename;
%         case 'gt_label',
%             res = obj.gt_labelfilename;            
        case {'perframedir','perframe'},
          res = obj.perframedir;
        case {'clipsdir','clips'},
          if ischar(obj.clipsdir)
            res = strtrim(obj.clipsdir);
          else
            res = 'clips';
          end            
        case 'scores',
          res = obj.scorefilename;
        case 'stfeatures',
          res = obj.stfeatures;
        otherwise
          error('Unknown file type %s',fileType);
      end
    end

    
    % ---------------------------------------------------------------------    
    function [filename,timestamp,tffound] = GetFile(obj,fileType,expi)
    % filename: full path(s). Either char or cellstr
    % timestamp: timestamps for files that exist. Size corresponding to filename.
    % tffound: logical vector. Size corresponding to filename.
    %
    % If tffound is true, filename is the full filename and timestamp is the filesystem timestamp.
    % If tffound is false, filename is the file-that-was-tried and timestamp=-inf.
    %
    % Vector output occurs eg for fileType='score' when using multiple
    % classifiers.
  
    %ST OK
    
      % base name
      fileNameLocal = obj.GetFileName(fileType);
      
      % if this is an output file, only look in output experiment directory
%       if dowrite && JLabelData.IsOutputFile(file),
%         %expdirs_try = obj.outexpdirs(expi);
%         expdirs_try = obj.expdirs(expi);
%       else
%         % otherwise, first look in output directory, then look in input
%         % directory
%         %expdirs_try = {obj.outexpdirs{expi},obj.expdirs{expi}};
%         expdirs_try = obj.expdirs(expi);
%       end
      expdirs_try = obj.expdirs(expi);
      
      % non-char or empty filename signals its absence
      if ~ischar(fileNameLocal) && ~iscellstr(fileNameLocal) || isempty(fileNameLocal)
        filename = fileNameLocal;
        timestamp = -inf;
        tffound = false;
        return
      end
      
      if ischar(fileNameLocal)
        [tffound,filename,timestamp] = JLabelData.GetFileRaw(fileType,expdirs_try,fileNameLocal);
      elseif iscellstr(fileNameLocal)
        [tffound,filename,timestamp] = cellfun(@(x)JLabelData.GetFileRaw(fileType,expdirs_try,x),fileNameLocal,'uni',0);
        timestamp = cell2mat(timestamp);
        tffound = cell2mat(tffound);
      end
    end    
  
    
    % ---------------------------------------------------------------------
    function SetGenerateMissingFiles(obj)
      obj.perframeGenerate = true;
    end
    
    
    % ---------------------------------------------------------------------
    function perframeGenerate = GetGenerateMissingFiles(obj)
      perframeGenerate = obj.perframeGenerate;
    end

    
    % ---------------------------------------------------------------------
    function [success,msg] = GenerateMissingFiles(obj,expi)
    % [success,msg] = GenerateMissingFiles(obj,expi)
    % Generate required, missing files for experiments expi. 
    % TODO: implement this!
    
    % ST OK
      
      success = true;
      msg = '';
            
      for i = 1:numel(obj.filetypes),
        file = obj.filetypes{i};
        if obj.IsRequiredFile(file) && obj.CanGenerateFile(file) && ...
            ~obj.FileExists(file,expi),
          fprintf('Generating %s for %s...\n',file,obj.expnames{expi});
          switch file
            case 'perframedir'
              [success1,msg1] = obj.GeneratePerframeFilesExceptScoreFeatures(expi);
              success = success && success1;
              if ~success1,
                msg = [msg,'\n',msg1]; %#ok<AGROW>
              end
%               [success2,msg2] = obj.GenerateScoreFeaturePerframeFiles(expi);
%               success = success && success2;
%               if ~success2,
%                 msg = [msg,'\n',msg2]; %#ok<AGROW>
%               end
          end
        end
      end
      [success1,msg1] = obj.UpdateStatusTable();
      success = success && success1;
      if isempty(msg),
        msg = msg1;
      else
        msg = sprintf('%s\n%s',msg,msg1);
      end
      
    end

    
    % ---------------------------------------------------------------------
    function RemoveArenaPFs(obj)
      %Update .allperframefns, .curperframefns, .windowfeaturesparams,
      %.windowfeaturescellparams
      
      %MERGESTUPDATED
      
      % Determine which PFFs to remove
      settings = obj.featureLexicon;
      apff = obj.allperframefns;      
      Napff = numel(apff);
      tfRm = false(Napff,1);
      for i = 1:Napff
        curpf = apff{i};
        if any(strcmp(curpf,{obj.scoreFeatures(:).scorefilename}))
          continue;
        end
        curtypes = settings.perframe.(curpf).type;
        tfRm(i) = any(strcmpi(curtypes,'arena')) || any(strcmpi(curtypes,'position'));
      end
      
      % Remove
      apffRm = apff(tfRm);
      obj.allperframefns(tfRm,:) = [];
      nCls = obj.nclassifiers;
      for iCls = 1:nCls
        fldsRm = intersect(fieldnames(obj.windowfeaturesparams{iCls}),apffRm);
        obj.windowfeaturesparams{iCls} = rmfield(obj.windowfeaturesparams{iCls},fldsRm);
        % AL 20141215: next line is legacy, don't understand why it is 
        % necessary given we are just removing fields
        obj.windowfeaturesparams{iCls} = JLabelData.convertTransTypes2Cell(obj.windowfeaturesparams{iCls});
        obj.windowfeaturescellparams{iCls} = JLabelData.convertParams2CellParams(obj.windowfeaturesparams{iCls});
        
        tf = ismember(obj.curperframefns{iCls},apffRm);
        obj.curperframefns{iCls}(tf,:) = [];
      end      
    end
    
    
    % ---------------------------------------------------------------------
    function [success,msg] = GeneratePerframeFilesExceptScoreFeatures(obj,expi)
      success = false; %#ok<NASGU>
      msg = '';

      perframedir = obj.GetFile('perframedir',expi);
      
      isInteractive=obj.isInteractive;
      if ~isInteractive,
        dooverwrite = false;
      elseif ~isempty(obj.perframeOverwrite) 
        dooverwrite = obj.perframeOverwrite;
      elseif exist(perframedir,'dir'),
        res = questdlg('Do you want to leave existing files alone or regenerate them?',...
                       'Regenerate existing files?', ...
                       'Leave Alone','Regenerate', ...
                       'Leave Alone');
        dooverwrite = strcmpi(res,'Regenerate');
        obj.perframeOverwrite = dooverwrite;
      else
        dooverwrite = true;
      end
      
      expdir = obj.expdirs{expi};
      
      hwait=-1;  % make sure hwait var exists, and is not a graphics handle
                 % unless it gets overwritten
      if isInteractive
        hwait = mywaitbar(0,sprintf('Generating perframe files for %s',expdir),'interpreter','none');
      else
        fprintf('Generating perframe files for %s\n',expdir);
      end
      
      perframetrx = Trx('trxfilestr',obj.GetFileName('trx'),...
                        'moviefilestr',obj.GetFileName('movie'),...
                        'perframedir',obj.GetFileName('perframedir'),...
                        'default_landmark_params',obj.landmark_params,...
                        'perframe_params',obj.perframe_params);
                        %'rootwritedir',expdir);
%                        'rootwritedir',obj.rootoutputdir);
      
      perframetrx.AddExpDir(expdir,'dooverwrite',dooverwrite,'openmovie',false);
      

      
      if isempty(fieldnames(obj.landmark_params)) && ~perframetrx.HasLandmarkParams && obj.arenawarn,
        if expi>1,
          success = false;
          msg = ['Landmark params were not defined in the configuration file or in the trx file for the current experiment. '...
              'Cannot compute arena perframe features for the experiment and removing it'];
          if isInteractive && ishandle(hwait),
              delete(hwait);
          end
          return;
        end

        if isInteractive,
          uiwait(warndlg(['Landmark params were not defined in the configuration file'...
            ' or in the trx file. Not computing arena features and removing them from the perframe list']));
        else
          fprintf('Landmark params were not defined in the configuration file. Not computing arena features and removing them from the perframe list.\n');
        end
        obj.RemoveArenaPFs();
        obj.arenawarn = false;
      end
      
      perframefiles = obj.GetPerframeFiles(expi);
      for i = 1:numel(obj.allperframefns),
        fn = obj.allperframefns{i};
        %ndx = find(strcmp(fn,obj.allperframefns));
        file = perframefiles{i};
        if ~dooverwrite && exist(file,'file'),
          continue;
        end
        if isInteractive
          hwait = mywaitbar(i/numel(obj.allperframefns),hwait,...
            sprintf('Computing %s and saving to file %s',fn,file));
        else
          fprintf('Computing %s and saving to file %s\n',fn,file);
        end
        
        % Generate the per-frame files that are not score features
        % Don't generate the per-frame files from scores here anymore..
        
%          try
           if isempty(obj.scoreFeatures) || ~any(strcmp(fn,{obj.scoreFeatures(:).scorefilename}))
            perframetrx.(fn);
           end        
%          catch excp
%            if isInteractive && ishandle(hwait),
%              delete(hwait);
%            end
%            if isequal(excp.identifier,'MATLAB:UndefinedFunction')
%              msg=sprintf('Unable to calculate per-frame feature %s.',fn);
%              success=false;
%              return
%           else
%              rethrow(excp);
%            end
%          end
      end
      
      if isInteractive && ishandle(hwait),
        delete(hwait);
      end
      
      success = true;
      
    end  % method

    
    % ---------------------------------------------------------------------
    function [success,msg] = GenerateScoreFeaturePerframeFiles(obj,expi)
      % MERGEST OK
      
      success = true;
      msg = '';
      % Convert the scores file into perframe files.
      for i = 1:numel(obj.scoreFeatures)
        %obj.SetStatus('Generating score-based per-frame feature file %s for %s...',obj.scoreFeatures(i).scorefilename,expName);
        [success,msg] = obj.ScoresToPerframe(expi, ...
          obj.scoreFeatures(i).scorefilename, ...
          obj.scoreFeatures(i).ts);
        if ~success,
          %obj.SetStatus('Error generating score-based per-frame file %s for %s...',obj.scoreFeatures(i).scorefilename,expName);
          %obj.RemoveExpDirs(obj.nexps,needSaveIfSuccessfulRemoval);
          return
        end
      end
    end

    
    % ---------------------------------------------------------------------
    function [success,msg,ts,projectName] = ...
        ScoresToPerframe(obj,expi,fileName,ts,projectName)
      % Create perframe file from scorefile in toplevel-dir
      %
      % ts: timestamp
      
      % MERGESTUPDATED
      
      persistent perframescoresfile_didselectyes;
      
      success = true;
      msg = '';

      outdir = obj.expdirs{expi};
      scoresFileIn = [fullfile(outdir,fileName) '.mat'];
      scoresFileOut = [fullfile(outdir,obj.GetFileName('perframe'),fileName) '.mat'];
      if ~exist(scoresFileIn,'file')
        success = false; 
        msg = sprintf('Scores file %s does not exist to be used as perframe feature',scoresFileIn);
        return;
      end
      
      Q = load(scoresFileIn);
      if obj.isInteractive
        if Q.timestamp > ts
          res = questdlg(sprintf('The timestamp for scores file %s (%s) is newer than that expected for this project (%s). Do you want to update the current project, proceed without updating, or cancel?',...
              scoresFileIn,datestr(Q.timestamp),datestr(ts)),'Scores file timestamp mismatch','Update project','Proceed without updating','Cancel','Update project');
          if strcmpi(res,'Update project')
            
            while true
              [f,p] = uigetfile('*.jab',sprintf('Choose the project corresponding to %s',fileName),projectName);
              if ~ischar(f)
                break;
              end
              newProjectName = fullfile(p,f);
              if ~exist(newProjectName,'file'),
                uiwait(warndlg(sprintf('File %s does not exist',newProjectName)));
                continue;
              end
              projectData = loadAnonymous(newProjectName);
              projectData = Macguffin(projectData);
              projectData.modernize();
              assert(isscalar(projectData.classifierStuff),...
                'Project ''%s'' is a multi-classifier project; this is currently unsupported.',newProjectName);              
              if projectData.classifierStuff.timeStamp ~= Q.timestamp
                uiwait(warndlg(sprintf('Timestamp in project file %s = %s does not match time stamp in score file %s = %s',newProjectName,datestr(projectData.classifierStuff.timeStamp),fileName,datestr(ts))));
                continue;
              end
              if ~strcmp(projectData.file.scorefilename{1},[fileName,'.mat']),
                uiwait(warndlg(sprintf('Score file name in %s = %s does not match score file name %s',newProjectName,projectData.file.scorefilename,[fileName,'.mat'])));
                continue;
              end
              projectName = newProjectName;
              ts = projectData.classifierStuff.timeStamp;
              break;
            end
            
          elseif strcmpi(res,'Proceed without updating')
            Q.timestamp = ts;
          end
        elseif Q.timestamp < ts,
          res = questdlg(sprintf('The timestamp for scores file %s (%s) is older than that expected for this project (%s). Do you want to add this experiment anyways or cancel?',...
            scoresFileIn,datestr(Q.timestamp),datestr(ts)),'Scores file timestamp mismatch','Add experiment anyway','Cancel','Cancel');
          if strcmpi(res,'Add experiment anyway'),
            Q.timestamp = ts;
          end
        end
      end
      if Q.timestamp ~= ts % check the timestamps match the classifier's timestamp.
        success = false; 
        msg = sprintf(['The scores file %s was generated using a classifier' ...
          ' that was saved on %s while the classifier chosen was saved on %s'],...
          scoresFileIn,datestr(Q.timestamp),datestr(ts));
      end
      
      OUT = struct();
      OUT.units = struct();
      OUT.units.num = {'scores'};
      OUT.units.den = {''};
      for ndx = 1:numel(Q.allScores.scores)
        t0 = Q.allScores.tStart(ndx);
        t1 = Q.allScores.tEnd(ndx);
        OUT.data{ndx} = Q.allScores.scores{ndx}(t0:t1);
      end
      try
        save(scoresFileOut,'-struct','OUT');
      catch ME,
        questmsg = sprintf('Could not write perframe file from scores file: %s.',fileName);
        if obj.isInteractive && isempty(perframescoresfile_didselectyes)
          button = questdlg([questmsg,' Continue?'],'Continue','Yes');
          if ~strcmp(button,'Yes')
            success = false;
            msg = ME.message;
          else
            perframescoresfile_didselectyes = true;
          end
        else
          warning(questmsg); %#ok<SPWRN>
        end
      end
    end

    
%     % ---------------------------------------------------------------------    
%     function [success,msg] = setFeatureLexiconAndTargetSpeciesCustom(obj,featureLexicon,animalType)
%       % This sets the feature lexicon to the given one, and stores a
%       % featureLexiconName of 'custom'.
%       
%       % Store the lexicon-associated stuff in obj
%       %[success,msg] = obj.setFeatureLexiconAndTargetSpeciesRaw(featureLexicon,animalType,'custom');
%       [success,msg] = obj.setFeatureLexiconAndFLName(featureLexicon,'custom');
%       
%       % Set the animal type
%       obj.targettype=animalType;
%     end  % method

    
%     % ---------------------------------------------------------------------    
%     function [success,msg] = setFeatureLexiconCustom(obj,featureLexicon)
%       % This sets the feature lexicon to the given one, and stores a
%       % featureLexiconName of 'custom'.
%       
%       % Store the lexicon-associated stuff in obj
%       [success,msg] = obj.setFeatureLexiconAndFLName(featureLexicon,'custom');
%     end  % method

    
%     % ---------------------------------------------------------------------
%     function [success,msg] = SetFeatureConfigFile(obj,featureConfigFileName)
%       featureConfigFileName = deployedRelative2Global(featureConfigFileName);      
%       obj.featureConfigFile = featureConfigFileName;
%       featureLexicon = ReadXMLParams(featureConfigFileName);
%       [success,msg]=obj.setFeatureLexicon(featureLexicon);
%     end
    
    
%     % ---------------------------------------------------------------------
%     function [success,msg] = SetFeatureParamsFileName(obj,featureparamsfilename)
%     % [success,msg] = SetFeatureParamsFileName(obj,featureparamsfilename)
%     % Sets the name of the file describing the features to use to
%     % featureparamsfilename. These parameters are read in. Currently, the
%     % window data and classifier, predictions are not changed. (TODO)
% 
%     success = false;
%       msg = '';
%       
%       if ischar(obj.featureparamsfilename) && strcmp(featureparamsfilename,obj.featureparamsfilename),
%         success = true;
%         return;
%       end
%       
%       if obj.nexps > 0,
%         msg = 'Currently, feature params file can only be changed when no experiments are loaded';
%         return;
%       end
%       
%       if ~exist(featureparamsfilename,'file'),
%         success = true; 
%         msg = '';
%         return;
%       end
% 
%       
% %       try
%         [windowfeaturesparams,~,basicFeatureTable,maxWindowRadiusCommonCached] = ...
%           ReadPerFrameParams(featureparamsfilename,obj.featureConfigFile); %#ok<PROP>
%         % 2nd return above used to be windowfeaturescellparams
% %       catch ME,
% %         msg = sprintf('Error reading feature parameters file %s: %s',...
% %           params.featureparamsfilename,getReport(ME));
% %         return;
% %       end
%       windowfeaturesparams = JLabelData.convertTransTypes2Cell(windowfeaturesparams);
%       %windowfeaturescellparams = JLabelData.convertParams2CellParams(windowfeaturesparams);
% 
%       obj.setWindowFeaturesParamsRaw(windowfeaturesparams);
%       obj.featureparamsfilename = featureparamsfilename;
%       obj.basicFeatureTable = basicFeatureTable;
%       obj.maxWindowRadiusCommonCached = maxWindowRadiusCommonCached;
%       success = true;
%     end
    
    
%     % ---------------------------------------------------------------------
%     function setWindowFeaturesParamsRaw(obj,windowFeaturesParams)
%       obj.windowfeaturesparams = windowFeaturesParams;
%       windowFeaturesCellParams= ...
%         JLabelData.convertParams2CellParams(windowFeaturesParams);
%       obj.windowfeaturescellparams = windowFeaturesCellParams;
%       obj.curperframefns = fieldnames(windowFeaturesParams);
%     end  
    
    
    % ---------------------------------------------------------------------
%     function ret = NeedSaveProject(obj)
%       ret = obj.savewindowfeatures;
%     end
%     
%     function ResetSaveProject(obj)
%       obj.savewindowfeatures = false;
%     end

    %----------------------------------------------------------------------
    
%     function SaveProject(obj)
%       configfilename = obj.configfilename;
%       [~,~,ext] = fileparts(configfilename);
%       if strcmp(ext,'.xml'),
%         uiwait(warndlg('Project file is saved in the old format. Cannot save the window features to the project file'));
%         return;
%       end
%       windowfeatures = struct();
%       windowfeatures.windowfeaturesparams = obj.windowfeaturesparams;
%       windowfeatures.windowfeaturescellparams = obj.windowfeaturescellparams;
%       windowfeatures.basicFeatureTable = obj.basicFeatureTable;
%       windowfeatures.maxWindowRadiusCommonCached=obj.maxWindowRadiusCommonCached;  %#ok<STRNU>
%       if exist(configfilename,'file')
%         [didbak,msg] = copyfile(configfilename,[configfilename '~']);
%         if ~didbak,
%           warning('Could not create backup of %s: %s',configfilename,msg);  
%         end
%       end
%       
%       save(configfilename,'windowfeatures','-append');
%       %obj.ResetSaveProject();
%     end
    
    
    % ---------------------------------------------------------------------
    function [windowfeaturesparams,windowfeaturescellparams] = GetPerframeParams(obj)
      windowfeaturesparams = obj.windowfeaturesparams; 
      windowfeaturescellparams = obj.windowfeaturescellparams; 
    end  
    
    
    % ---------------------------------------------------------------------
    function [filenames,timestamps] = GetPerframeFiles(obj,expi)
    % [filenames,timestamps] = GetPerFrameFiles(obj,file,expi)
    % Get the full path to the per-frame mat files for experiment expi
      
%       if nargin < 3,
%         dowrite = false;
%       end
      
      fn = obj.GetFileName('perframedir');
      
      % if this is an output file, only look in output experiment directory
%       if dowrite && JLabelData.IsOutputFile('perframedir'),
%         %expdirs_try = obj.outexpdirs(expi);
%         expdirs_try = obj.expdirs(expi);
%       else
%         % otherwise, first look in output directory, then look in input
%         % directory
%         %expdirs_try = {obj.outexpdirs{expi},obj.expdirs{expi}};
%         expdirs_try = obj.expdirs(expi);
%       end
      expdirs_try = obj.expdirs(expi);
      
      filenames = cell(1,numel(obj.allperframefns));
      timestamps = -inf(1,numel(obj.allperframefns));
      
      for i = 1:numel(obj.allperframefns),

        % loop through directories to look in
        for j = 1:numel(expdirs_try),
          expdir = expdirs_try{j};
%           perframedir = fullfile(expdir,fn);  % BJA: slow by 10x
          perframedir = [expdir filesep fn];
          if ispc && ~exist(perframedir,'dir'),
            [actualperframedir,didfind] = GetPCShortcutFileActualPath(perframedir);
            if didfind,
              perframedir = actualperframedir;
            end
          end
%           filename = fullfile(perframedir,[obj.allperframefns{i},'.mat']);  % BJA: slow by 10x
          filename = [perframedir filesep obj.allperframefns{i} '.mat'];
          if ispc && ~exist(filename,'file'),
            [actualfilename,didfind] = GetPCShortcutFileActualPath(filename);
            if didfind,
              filename = actualfilename;
            end
          end
          
          if exist(filename,'file'),
            filenames{i} = filename;
            tmp = dir(filename);
            timestamps(i) = tmp.datenum;
          elseif j == 1,
            filenames{i} = filename;
          end
          
        end
      end
    end
    
    
    % ---------------------------------------------------------------------
    function [fe,ft] = FileExists(obj,fileType,expi)
    % [fe,ft] = FileExists(obj,file,expi)
    % Returns whether the input file exists for the input experiment. 
      filei = find(strcmpi(fileType,obj.filetypes),1);
      if isempty(filei),
        error('file type %s does not match any known file type',fileType);
      end
      if nargin < 3,
        expi = 1:obj.nexps;
      end
      fe = obj.fileexists(expi,filei);
      ft = obj.filetimestamps(expi,filei);
    end  % method
    
    
% Tracking information   


    % --------------------------------------------------------------------------
    function [success,msg] = GetTrxInfo(obj,expi,canusecache,trx)
    % [success,msg] = GetTrxInfo(obj,expi)
    % Fills in nflies_per_exp, firstframes_per_exp, and endframes_per_exp
    % for experiment expi. This may require loading in trajectories. 
      success = true;
      msg = '';
      if nargin < 3,
        canusecache = true;
      end
%       canusecache = false;
      istrxinput = nargin >= 4;
      
      obj.SetStatus('Reading trx info for experiment %s',obj.expdirs{expi});
      if numel(obj.nflies_per_exp) < expi || ...
          numel(obj.sex_per_exp) < expi || ...
          numel(obj.frac_sex_per_exp) < expi || ...
          numel(obj.firstframes_per_exp) < expi || ...
          numel(obj.endframes_per_exp) < expi || ...
          isnan(obj.nflies_per_exp(expi)),
        if ~istrxinput,

          trxfile = fullfile(obj.expdirs{expi},obj.GetFileName('trx'));
          if ~exist(trxfile,'file'),
            msg = sprintf('Trx file %s does not exist, cannot count flies',trxfile);
            success = false;
            return;
          else
          
            if isempty(obj.expi) || obj.expi == 0,
              % TODO: make this work for multiple flies
              obj.setCurrentTarget(expi,1);
              trx = obj.trx;
            elseif canusecache && expi == obj.expi,
              trx = obj.trx;
            else
%               try
                % REMOVE THIS
                global CACHED_TRX; %#ok<TLEV>
                global CACHED_TRX_EXPNAME; %#ok<TLEV>
                if isempty(CACHED_TRX) || isempty(CACHED_TRX_EXPNAME) || ...
                    ~strcmp(obj.expnames{expi},CACHED_TRX_EXPNAME),
                  hwait = mywaitbar(0,sprintf('Loading trx to determine number of flies for %s',...
                    obj.expnames{expi}),'interpreter','none');
                  trx = load_tracks(trxfile);
                  if ishandle(hwait), delete(hwait); end
                  CACHED_TRX = trx;
                  CACHED_TRX_EXPNAME = obj.expnames{expi};
                else
                  fprintf('DEBUG: Using CACHED_TRX. REMOVE THIS\n');
                  trx = CACHED_TRX;
                end
%               catch ME,
%                 msg = sprintf(['Could not load trx file for experiment %s '...
%                     'to count flies: %s'],obj.expdirs{expi},getReport(ME));
%               end
            end
          end
        end
        
        obj.nflies_per_exp(expi) = numel(trx);
        obj.firstframes_per_exp{expi} = [trx.firstframe];
        obj.endframes_per_exp{expi} = [trx.endframe];

        obj.hassex = obj.hassex || isfield(trx,'sex');
        
        % store sex info
        tmp = repmat({nan},[1,numel(trx)]);
        obj.frac_sex_per_exp{expi} = struct('M',tmp,'F',tmp);
        obj.sex_per_exp{expi} = repmat({'?'},[1,numel(trx)]);
        if isfield(trx,'sex'),
          obj.hasperframesex = iscell(trx(1).sex);
          if obj.hasperframesex,
            for fly = 1:numel(trx),
              n = numel(trx(fly).sex);
              nmale = nnz(strcmpi(trx(fly).sex,'M'));
              nfemale = nnz(strcmpi(trx(fly).sex,'F'));
              obj.frac_sex_per_exp{expi}(fly).M = nmale/n;
              obj.frac_sex_per_exp{expi}(fly).F = nfemale/n;
              if nmale > nfemale,
                obj.sex_per_exp{expi}{fly} = 'M';
              elseif nfemale > nmale,
                obj.sex_per_exp{expi}{fly} = 'F';
              else
                obj.sex_per_exp{expi}{fly} = '?';
              end
            end
          else
            for fly = 1:numel(trx),
              obj.sex_per_exp{expi}{fly} = trx(fly).sex;
              if strcmpi(trx(fly).sex,'M'),
                obj.frac_sex_per_exp{expi}(fly).M = 1;
                obj.frac_sex_per_exp{expi}(fly).F = 0;
              elseif strcmpi(trx(fly).sex,'F'),
                obj.frac_sex_per_exp{expi}(fly).M = 0;
                obj.frac_sex_per_exp{expi}(fly).F = 1;
              end
            end
          end
        end
      end
      if isfield(trx,'arena')
        obj.hasarenaparams(expi) = true;
      else
        obj.hasarenaparams(expi) = false;
      end
      
      obj.ClearStatus();
      
    end

    
    % --------------------------------------------------------------------------
    function out = GetTrxValues(obj,infoType,expi,flies,ts)
    % A generic function that return track info.

      if numel(expi) ~= 1,
        error('expi must be a scalar');
      end
      
      if expi ~= obj.expi,
        % TODO: generalize to multiple flies
        [success,msg] = obj.setCurrentTarget(expi,1);
        if ~success,
          error('Error loading trx for experiment %d: %s',expi,msg);
        end
      end

      if nargin < 4,     % No flies given
        switch infoType
          case 'Trx'
            out = obj.trx;
          case 'X'
            out = {obj.trx.x};
          case 'Y'
            out = {obj.trx.y};
          case 'A'
            out = {obj.trx.a};
          case 'B'
            out = {obj.trx.b};
          case 'Theta'
            out = {obj.trx.theta};
          otherwise
            error('Incorrect infotype requested from GetTrxValues with less than 4 arguments');
        end
        return;

      
      elseif nargin < 5, % No ts given
        switch infoType
          case 'Trx'
            out = obj.trx(flies);
          case 'X'
            out = {obj.trx(flies).x};
          case 'Y'
            out = {obj.trx(flies).y};
          case 'A'
            out = {obj.trx(flies).a};
          case 'B'
            out = {obj.trx(flies).b};
          case 'Theta'
            out = {obj.trx(flies).theta};
          case 'X1'
            out = [obj.trx(flies).x];
          case 'Y1'
            out = [obj.trx(flies).y];
          case 'A1'
            out = [obj.trx(flies).a];
          case 'B1'
            out = [obj.trx(flies).b];
          case 'Theta1'
            out = [obj.trx(flies).theta];
          otherwise
            error('Incorrect infotype requested from GetTrxValues');
        end
        return
      else               % Everything is given
        nflies = numel(flies);
        fly = flies(1);
        switch infoType
          case 'Trx'
            c = cell(1,nflies);
            trx = struct('x',c,'y',c,'a',c,'b',c,'theta',c,'ts',c,'firstframe',c,'endframe',c);
            for i = 1:numel(flies),
              fly = flies(i);
              js = min(obj.trx(fly).nframes,max(1,ts + obj.trx(fly).off));
              trx(i).x = obj.trx(fly).x(js);
              trx(i).y = obj.trx(fly).y(js);
              trx(i).a = obj.trx(fly).a(js);
              trx(i).b = obj.trx(fly).b(js);
              trx(i).theta = obj.trx(fly).theta(js);
              trx(i).ts = js-obj.trx(fly).off;
              trx(i).firstframe = trx(i).ts(1);
              trx(i).endframe = trx(i).ts(end);
            end
            out = trx;
          case 'X'
            x = cell(1,nflies);
            for i = 1:numel(flies),
              fly = flies(i);
              js = min(obj.trx(fly).nframes,max(1,ts + obj.trx(fly).off));
              x{i} = obj.trx(fly).x(js);
            end
            out = x;
          case 'Y'
            x = cell(1,nflies);
            for i = 1:numel(flies),
              fly = flies(i);
              js = min(obj.trx(fly).nframes,max(1,ts + obj.trx(fly).off));
              x{i} = obj.trx(fly).y(js);
            end
            out = x;
          case 'A'
            x = cell(1,nflies);
            for i = 1:numel(flies),
              fly = flies(i);
              js = min(obj.trx(fly).nframes,max(1,ts + obj.trx(fly).off));
              x{i} = obj.trx(fly).a(js);
            end
            out = x;
          case 'B'
            x = cell(1,nflies);
            for i = 1:numel(flies),
              fly = flies(i);
              js = min(obj.trx(fly).nframes,max(1,ts + obj.trx(fly).off));
              x{i} = obj.trx(fly).b(js);
            end
            out = x;
          case 'Theta'
            x = cell(1,nflies);
            for i = 1:numel(flies),
              fly = flies(i);
              js = min(obj.trx(fly).nframes,max(1,ts + obj.trx(fly).off));
              x{i} = obj.trx(fly).theta(js);
            end
            out = x;
          case 'X1'
            out = obj.trx(fly).x(ts + obj.trx(fly).off);
          case 'Y1'
            out = obj.trx(fly).y(ts + obj.trx(fly).off);
          case 'A1'
            out = obj.trx(fly).a(ts + obj.trx(fly).off);
          case 'B1'
            out = obj.trx(fly).b(ts + obj.trx(fly).off);
          case 'Theta1'
            out = obj.trx(fly).theta(ts + obj.trx(fly).off);
          otherwise
            error('Incorrect infotype requested from GetTrxValues');
         end
      end
      
    end
    
    
    % ---------------------------------------------------------------------
    function pos = GetTrxPos1(varargin)
    % [x,y,theta,a,b] = GetTrxPos1(obj,expi,fly,ts)
    % Returns the position for the input experiment, SINGLE fly, and
    % frames. If ts is not input, then all frames are returned. 

      % moved to separate file so that function could be easily modified
      pos = JLabelData_GetTrxPos(varargin{:});

    end

    
    % ---------------------------------------------------------------------
    function sex = GetSex(obj,expi,fly,ts,fast)
    % x = GetSex(obj,expi,fly,ts)
    % Returns the sex for the input experiment, SINGLE fly, and
    % frames. If ts is not input, then all frames are returned. 

      if ~obj.hassex,
        sex = '?';
        return;
      end
      
      if nargin < 5,
        fast = false;
      end
      
      if ~obj.hasperframesex || fast,
        sex = obj.sex_per_exp{expi}(fly);
        return;
      end
      
      if expi ~= obj.expi,
        % TODO: generalize to multiple flies
        [success,msg] = obj.setCurrentTarget(expi,fly);
        if ~success,
          error('Error loading trx for experiment %d: %s',expi,msg);
        end
      end
      
      if nargin < 4,
        sex = obj.trx(fly).sex;
        return;
      end
      
      sex = obj.trx(fly).sex(ts + obj.trx(fly).off);

    end

    
    % ---------------------------------------------------------------------
    function sex = GetSex1(obj,expi,fly,t)
    % x = GetSex1(obj,expi,fly,t)
    % Returns the sex for the input experiment, SINGLE fly, and
    % SINGLE frame. 

      if ~obj.hassex,
        sex = '?';
        return;
      end
            
      if ~obj.hasperframesex,
        sex = obj.sex_per_exp{expi}(fly);
        if iscell(sex),
          sex = sex{1};
        end
        return;
      end
      
      if expi ~= obj.expi,
        % TODO: generalize to multiple flies
        [success,msg] = obj.setCurrentTarget(expi,fly);
        if ~success,
          error('Error loading trx for experiment %d: %s',expi,msg);
        end
      end
            
      sex = obj.trx(fly).sex{t + obj.trx(fly).off};

    end
    
    
    % ---------------------------------------------------------------------
    function sexfrac = GetSexFrac(obj,expi,fly)
    % x = GetSexFrac(obj,expi,fly)
    % Returns a struct indicating the fraction of frames for which the sex
    % of the fly is M, F

      sexfrac = obj.frac_sex_per_exp{expi}(fly);

    end
    
    
    % ---------------------------------------------------------------------
    function t0 = GetTrxFirstFrame(obj,expi,flies)
    % t0 = GetTrxFirstFrame(obj,expi,flies)
    % Returns the firstframes for the input experiment and flies. If flies
    % is not input, then all flies are returned. 
      if numel(expi) ~= 1,
        error('expi must be a scalar');
      end
      
      if nargin < 3,
        t0 = obj.firstframes_per_exp{expi};
        return;
      end

      t0 = obj.firstframes_per_exp{expi}(flies);
      
    end

    
    % ---------------------------------------------------------------------
    function t1 = GetTrxEndFrame(obj,expi,flies)
    % t1 = GetTrxEndFrame(obj,expi,flies)
    % Returns the endframes for the input experiment and flies. If flies
    % is not input, then all flies are returned. 

      if numel(expi) ~= 1,
        error('expi must be a scalar');
      end
      
      if nargin < 3,
        t1 = obj.endframes_per_exp{expi};
        return;
      end

      t1 = obj.endframes_per_exp{expi}(flies);
      
    end

    
    % ---------------------------------------------------------------------
    function SetConfidenceThreshold(obj,thresholds,ndx)
      assert(obj.nclassifiers==1);
      assert(isscalar(ndx) && any(ndx==[1 2]));
      obj.confThresholds(1,ndx) = thresholds;
    end
    
    
    % ---------------------------------------------------------------------
    function t = GetConfidenceThreshold(obj,ndx)
      % thresholds = GetConfidenceThreshold(obj,ndx)
      % ndx: indices into handles.data.labelnames      
      
      t = obj.confThresholds(ndx); 
    end
    
    
% Labels and predictions    
    

    % ---------------------------------------------------------------------
    function [success,msg] = setCurrentTarget(obj,expi,flies,force)
      % This is the method formerly known as PreLoad(). Sets the current
      % target to experiment expi, animal flies.  This implies preloading
      % data associated with the input experiment and flies. If neither the
      % experiment nor flies are changing, then we do nothing. If there is
      % currently a preloaded experiment, then we store the labels in
      % labelidx into labels using StoreLabels. We then load from labels into
      % labelidx for the new experiment and flies. We load the per-frame data
      % for this experiment and flies. If this is a different experiment,
      % then we load in the trajectories for this experiment.
      
      success = false;
      msg = '';
      
      if ~exist('force','var')
        force=false;
      end
      
      if numel(expi) ~= 1,
        error('expi must be a scalar');
      end

      if numel(unique(flies)) ~= numel(flies),
        msg = 'flies must all be unique';
        return;
      end
      
      diffexpi = isempty(obj.expi) || expi ~= obj.expi;
      diffflies = diffexpi || numel(flies) ~= numel(obj.flies) || ~all(flies == obj.flies);
      % nothing to do
      if ~diffflies && ~force,
        success = true;
        return;
      end

      if ~isempty(obj.expi) && obj.expi > 0,
        % store labels currently in labelidx to labels
        obj.StoreLabelsAndPreLoadWindowData();
      end
      
      if diffexpi || force,
        
        % load trx
%         try
          trxfilename = obj.GetFile('trx',expi);
          if ~exist(trxfilename,'file')
            msg = sprintf('Trx file %s does not exist',trxfilename);
            success = false;
            return;
          end
          
          obj.SetStatus('Loading trx for experiment %s',obj.expnames{expi});
                    
          % TODO: remove this
          global CACHED_TRX; %#ok<TLEV>
          global CACHED_TRX_EXPNAME; %#ok<TLEV>
          if isempty(CACHED_TRX) || isempty(CACHED_TRX_EXPNAME) || ...
              ~strcmp(obj.expnames{expi},CACHED_TRX_EXPNAME),
            trx = load_tracks(trxfilename);
            ff = fieldnames(trx);
            for fnum = 1:numel(ff)
              if numel(trx(1).(ff{fnum})) == trx(1).nframes && ~strcmpi(ff{fnum},'sex');
                for fly = 1:numel(trx)
                  trx(fly).(ff{fnum}) = trx(fly).(ff{fnum})(:)';
                end
              end
            end

            obj.trx = trx;
            CACHED_TRX = obj.trx;
            CACHED_TRX_EXPNAME = obj.expnames{expi};
          else
            fprintf('DEBUG: Using CACHED_TRX. REMOVE THIS\n');
            obj.trx = CACHED_TRX;
          end
          % store trx_info, in case this is the first time these trx have
          % been loaded
          [success,msg] = obj.GetTrxInfo(expi,true,obj.trx);
          if ~success,
            return;
          end
          
%         catch ME,
%           msg = sprintf('Error loading trx from file %s: %s',trxfilename,getReport(ME));
%           if ishandle(hwait),
%             delete(hwait);
%             drawnow;
%           end
%           return;
%         end
 
      end  % if diffexpi

      % set labelidx from labels
      obj.SetStatus('Caching labels for experiment %s, flies%s',obj.expnames{expi},sprintf(' %d',flies));
      [obj.labelidx,obj.t0_curr,obj.t1_curr] = obj.GetLabelIdx(expi,flies);
      obj.labelidx_off = 1 - obj.t0_curr;
      
      % load perframedata
      obj.SetStatus('Loading per-frame data for %s, flies %s',obj.expdirs{expi},mat2str(flies));
      [success,msg]=obj.loadPerframeData(expi,flies);
      if ~success, return;  end
      
      obj.expi = expi;
      obj.flies = flies;

      if numel(obj.predictdata)<obj.expi
        obj.InitPredictionData(obj.expi);
      end
      obj.UpdatePredictedIdx();
      obj.ClearStatus();
           
      success = true;
    end
    
    
    % ---------------------------------------------------------------------
    function unsetCurrentTarget(obj)
      % Sets the object to a state where no target is currently selected.
      % This also clears the cached data for the currently loaded
      % experiment.
      obj.StoreLabelsForCurrentAnimal();
      obj.trx = {};
      obj.expi = 0;
      obj.flies = [];
      obj.perframedata = {};
      obj.labelidx = struct('vals',[],'imp',[],'timestamp',[]);
      obj.labelidx_off = 0;
      obj.t0_curr = 0;
      obj.t1_curr = 0;
      obj.predictedidx = [];
      obj.scoresidx = [];
      obj.scoresidx_old = [];
      obj.erroridx = [];
      obj.suggestedidx = [];
    end
    
    
    % ---------------------------------------------------------------------
    function timestamp = GetLabelTimestamps(obj,expis,flies,ts)      
      timestamp = nan(size(ts));      
      for expi = 1:obj.nexps,
        expidx = expis == expi;
        if ~any(expidx),
          continue;
        end
        % TODO: extend to multiple flies
        for fly = 1:obj.nflies_per_exp(expi),
          flyidx = expidx & flies == fly;
          if ~any(flyidx),
            continue;
          end
          [labelidx,T0] = obj.GetLabelIdx(expi,fly);
          timestamp(flyidx) = labelidx.timestamp(ts(flyidx)-T0+1);
        end
      end
    end
    
    
    % -----------------------------------------------------------
    function [labelidx,T0,T1] = GetLabelIdx(obj,expi,flies,T0,T1)
    % Returns the labelidx for the input experiment and flies read from
    % labels. 
    
      % Access labelidx cache if appropriate
      if ~isempty(obj.expi) && numel(flies)==numel(obj.flies) && obj.IsCurFly(expi,flies)
        if nargin < 4
          labelidx = obj.labelidx;
          T0 = obj.t0_curr;
          T1 = obj.t1_curr;
        else
          idx = T0+obj.labelidx_off:T1+obj.labelidx_off;
          labelidx = struct();
          labelidx.vals = obj.labelidx.vals(:,idx);
          labelidx.imp = obj.labelidx.imp(:,idx);
          labelidx.timestamp = obj.labelidx.timestamp(:,idx);
        end
        return;
      end
      
      if nargin < 4
        T0 = max(obj.GetTrxFirstFrame(expi,flies));
        T1 = min(obj.GetTrxEndFrame(expi,flies));
      end
      
      labelsShort = obj.GetLabels(expi,flies);
      assert(obj.nbehaviors==numel(obj.labelnames));
      labelidx = Labels.labelIdx(obj.labelnames,T0,T1);
      labelidx = Labels.labelIdxInit(labelidx,labelsShort);
    end

    
    % ---------------------------------------------------------------------
    function [perframedata,T0,T1] = GetPerFrameData(obj,expi,flies,prop,T0,T1)
    % [perframedata,T0,T1] = GetPerFrameData(obj,expi,flies,prop,T0,T1)
    % Returns the per-frame data for the input experiment, flies, and
    % property. 

      if ischar(prop),
        prop = find(strcmp(prop,obj.allperframefns),1);
        if isempty(prop),
          error('Property %s is not a per-frame property');
        end
      end
      
      if obj.IsCurFly(expi,flies) 
        if nargin < 5,
          perframedata = obj.perframedata{prop};
          T0 = obj.t0_curr;
          T1 = obj.t0_curr + numel(perframedata) - 1;
        else
          T0 = max(T0,obj.t0_curr);
          T1 = min(T1,obj.t0_curr+numel(obj.perframedata{prop})-1);
          i0 = T0 - obj.t0_curr + 1;
          i1 = T1 - obj.t0_curr + 1;
          perframedata = obj.perframedata{prop}(i0:i1);
        end
        return;
      end
      
      perframedir = obj.GetFile('perframedir',expi);
      tmp = load(fullfile(perframedir,[obj.allperframefns{prop},'.mat']));
      if nargin < 5,
        T0 = max(obj.GetTrxFirstFrame(expi,flies));
        % TODO: generalize to multi-fly
        perframedata = tmp.data{flies(1)};
        T1 = T0 + numel(perframedata) - 1;
        return;
      end
      off = 1 - obj.GetTrxFirstFrame(expi,flies);
      i0 = T0 + off;
      i1 = T1 + off;
      perframedata = tmp.data{flies(1)}(i0:i1);

    end

    
    % ---------------------------------------------------------------------
    function perframedata = GetPerFrameData1(obj,expi,flies,prop,t)
    % perframedata = GetPerFrameData1(obj,expi,flies,prop,t)
    % Returns the per-frame data for the input experiment, flies, and
    % property. 

%       if ischar(prop),
%         prop = find(strcmp(prop,handles.perframefn),1);
%         if isempty(prop),
%           error('Property %s is not a per-frame property');
%         end
%       end
      
      if ~isempty(obj.expi) && expi == obj.expi && numel(flies) == numel(obj.flies) && all(flies == obj.flies),
        is = t-obj.t0_curr+1;
        badidx = is > numel(obj.perframedata{prop});
        if any(badidx),
          perframedata = nan(size(is));
          perframedata(~badidx) = obj.perframedata{prop}(is(~badidx));
        else
          perframedata = obj.perframedata{prop}(is);
        end
        return;
      end
      
      perframedir = obj.GetFile('perframedir',expi);
      tmp = load(fullfile(perframedir,[obj.allperframefns{prop},'.mat']));
      off = 1 - obj.GetTrxFirstFrame(expi,flies);
      perframedata = tmp.data{flies(1)}(t+off);

    end
    
    
    % ---------------------------------------------------------------------
    function [prediction,T0,T1] = GetPredictedIdx(obj,expi,flies,T0,T1)
      % Get the prediction for experiment expi, target flies, over the time
      % span from T0 to T1.  The returned prediction variable is a scalar
      % structure with two fields: predictedidx and scoresidx, both with
      % nclassifiers rows.
      % - scoresidx holds the raw score output from the classifier.  
      % - predictedidx holds the index of the predicted behavior:
      %    * 1 represents the behavior
      %    * 2 represents no-behavior
      %    * 1.5 represents undecided between beh and no-beh
      %    * 0 indicates no/invalid/out-of-date prediction
      
      if ~isempty(obj.expi) && numel(flies) == numel(obj.flies) && obj.IsCurFly(expi,flies),
        assert(size(obj.predictedidx,1)==obj.ntimelines);
        assert(size(obj.scoresidx,1)==obj.ntimelines);
        if nargin < 4,
          prediction = struct('predictedidx',obj.predictedidx,...
                              'scoresidx', obj.scoresidx);
          T0 = obj.t0_curr;
          T1 = obj.t1_curr;
        else
          if T0<obj.t0_curr || T1>obj.t1_curr
            T0 = max(obj.t0_curr,T0);
            T1 = min(obj.t1_curr,T1);
          end
          prediction = struct(...
            'predictedidx', obj.predictedidx(:,T0+obj.labelidx_off:T1+obj.labelidx_off),...
            'scoresidx',  obj.scoresidx(:,T0+obj.labelidx_off:T1+obj.labelidx_off));
        end
        return;
      end
      
      if nargin < 4,
        T0 = max(obj.GetTrxFirstFrame(expi,flies));
        T1 = min(obj.GetTrxEndFrame(expi,flies));
      end
      
      n = T1-T0+1;
      off = 1 - T0;
      prediction = struct('predictedidx',zeros(obj.ntimelines,n),...
                         'scoresidx',zeros(obj.ntimelines,n));      
      for iTL = 1:obj.ntimelines
        idxcurr = obj.predictdata{expi}{flies}(iTL).cur_valid & ...
                  obj.predictdata{expi}{flies}(iTL).t>=T0 & ...
                  obj.predictdata{expi}{flies}(iTL).t<=T1;
      
        prediction.predictedidx(iTL,obj.predictdata{expi}{flies}(iTL).t(idxcurr)+off) = ...
          -sign(obj.predictdata{expi}{flies}(iTL).cur(idxcurr))*0.5+1.5;
        prediction.scoresidx(iTL,obj.predictdata{expi}{flies}(iTL).t(idxcurr)+off) = ...
          obj.predictdata{expi}{flies}(iTL).cur(idxcurr);
      end
    end
    
    function predictions = GetPredictionsAllFlies(obj,expi,curt,fliesinrange)
      % curt: scalar, time desired
      
      %MERGESTUPDATED
      
      % ALTODO: currently always returning prediction for first
      % behavior/classifier
      iCls = 1;
      
      predictions = zeros(1,numel(fliesinrange));
      
      count = 1;
      for curfly = fliesinrange(:)'
        idxcurr = obj.predictdata{expi}{curfly}(iCls).cur_valid & ...
                  obj.predictdata{expi}{curfly}(iCls).t==curt;
        if ~any(idxcurr)
          % ALTODO: this branch causes predictions vector to not
          % correspond element-per-element to fliesinrange
          continue; 
        end
        predictions(count) = 2-obj.predictdata{expi}{curfly}(iCls).cur_pp(idxcurr);
        count = count+1;
      end
    end
    
    
    % ---------------------------------------------------------------------
    function scores = GetValidatedScores(obj,expi,flies,T0,T1)
      % scores: nclassifier-by-(T1-T0+1) array
      
      %MERGESTUPDATED
      
      if nargin<4
        T0 = max(obj.GetTrxFirstFrame(expi,flies));
        T1 = min(obj.GetTrxEndFrame(expi,flies));
      end
      
      n = T1-T0+1;
      off = 1 - T0;
      scores = zeros(obj.nclassifiers,n);
      for iCls = 1:obj.nclassifiers
        wd = obj.windowdata(iCls);
        if ~isempty(wd.scores_validated)
          idxcurr = obj.FlyNdx(expi,flies,iCls) & wd.t>=T0 & wd.t<=T1;
          scores(iCls,wd.t(idxcurr)+off) = wd.scores_validated(idxcurr);
        end
      end      
    end
 
  
    % ---------------------------------------------------------------------
    function [scores,predictions] = GetLoadedScores(obj,expi,flies,T0,T1)      
      %MERGESTUPDATED      
      if nargin<4
        T0 = max(obj.GetTrxFirstFrame(expi,flies));
        T1 = min(obj.GetTrxEndFrame(expi,flies));
      end  
      [scores,predictions] = obj.GetScoresCore(expi,flies,...
        'loaded','loaded_valid','loaded_pp',T0,T1);
    end
    
    
    % ---------------------------------------------------------------------
    function [scores,predictions] = GetPostprocessedScores(obj,expi,flies,T0,T1)
      %MERGESTUPDATED
      if nargin<4
        T0 = max(obj.GetTrxFirstFrame(expi,flies));
        T1 = min(obj.GetTrxEndFrame(expi,flies));
      end
            
      if obj.HasCurrentScores
        [scores,predictions] = obj.GetScoresCore(expi,flies,...
          'cur','cur_valid','cur_pp',T0,T1);
      else
        [scores,predictions] = obj.GetLoadedScores(expi,flies,T0,T1);
      end      
    end
        
    
    % ---------------------------------------------------------------------
    function scores = GetOldScores(obj,expi,flies)
      %MERGESTUPDATED
      T0 = max(obj.GetTrxFirstFrame(expi,flies));
      T1 = min(obj.GetTrxEndFrame(expi,flies));
      scores = obj.GetScoresCore(expi,flies,'old','old_valid','old_valid',T0,T1);
      % Using arbitrary/random field old_valid for fldPP; this arg only
      % used for computing predictions, which we are not using
    end
    
    
%     ---------------------------------------------------------------------
%     function [idx,T0,T1] = IsBehavior(obj,behaviori,expi,flies,T0,T1)
%     [idx,T0,T1] = IsBehavior(obj,behaviori,expi,flies,T0,T1)
%     Returns whether the behavior is labeled as behaviori for experiment
%     expi, flies from frames T0 to T1. If T0 and T1 are not input, then
%     firstframe to endframe are used. 
% 
%           
%       if ~isempty(obj.expi) && expi == obj.expi && numel(flies) == numel(obj.flies) && all(flies == obj.flies),
%         if nargin < 4,
%           idx = obj.labelidx.vals == behaviori;
%           T0 = obj.t0_curr;
%           T1 = obj.t1_curr;
%         else
%           idx = obj.labelidx.vals(T0+obj.labelidx_off:T1+obj.labelidx_off) == behaviori;
%         end
%         return;
%       end
%       
%       if nargin < 4,
%         T0 = max(obj.GetTrxFirstFrame(expi,flies));
%         T1 = min(obj.GetTrxEndFrame(expi,flies));
%       end
%       n = T1-T0+1;
%       off = 1 - T0;
%       labels_curr = obj.GetLabels(expi,flies);
%       idx = false(1,n);
%       for j = find(strcmp(labels_curr.names,obj.labelnames{behaviori})),
%         t0 = labels_curr.t0s(j);
%         t1 = labels_curr.t1s(j);
%         idx(t0+off:t1-1+off) = true;
%       end
%       
%     end

    
    % ---------------------------------------------------------------------
    function labels_curr = GetLabels(obj,expi,flies)
      % Returns the labels for the given experiment index, fly(s) index.
      % This takes into account the current GT mode (normal/GT), and
      % returns the appropriate labels.
      %
      % labels_curr: a 'labelsShort', see Labels.m

      % MERGESTUPDATED
      
      labels_curr = Labels.labelsShort();
              
      if nargin < 2 || isempty(expi)
        expi = obj.expi;
      end
      if expi < 1
        % AL: questionable legacy codepath
        return;
      end
      
      if nargin < 3 || isempty(flies)
        flies = obj.flies;
      end

      % cache these labels if current experiment and flies selected
      if expi == obj.expi && all(flies == obj.flies)
        %obj.StoreLabelsAndPreLoadWindowData();  % seems wrong
        obj.StoreLabelsForCurrentAnimal();
      end
      
      [labels_curr,tffly] = Labels.labelsShortInit(labels_curr,obj.labels(expi),flies);
      if ~tffly
        t0_curr = max(obj.GetTrxFirstFrame(expi,flies));
        labels_curr.off = 1-t0_curr;
      end
    end
    
    
    % ---------------------------------------------------------------------
%     function isstart = IsLabelStart(obj,expi,flies,ts)
%       % AL: appears to be useless
%       
%       if obj.expi == expi && all(flies == obj.flies),
%         isstart = obj.labelidx.vals(ts+obj.labelidx_off) ~= 0 & ...
%           obj.labelidx.vals(ts+obj.labelidx_off-1) ~= obj.labelidx.vals(ts+obj.labelidx_off);
%       else
%         
% %         if obj.IsGTMode(),
% %           labelsToUse = 'gt_labels';
% %         else
% %           labelsToUse = 'labels';
% %         end
% 
%         if isempty(obj.labels(expi).flies)
%           ism = false;
%         else
%           [ism,fliesi] = ismember(flies,obj.labels(expi).flies,'rows');
%         end
% 
%         if ism,
%           isstart = ismember(ts,obj.labels(expi).t0s{fliesi});
%         else
%           isstart = false(size(ts));
%         end
%       end
%       
%         end

    
%     % ---------------------------------------------------------------------
%     function ClearLabels(obj,expi,flies)
%       
%       
%       if obj.nexps == 0,
%         return;
%       end
%       
% %       if obj.IsGTMode()
% %         labelsToUse = 'gt_labels';
% %         labelstatsToUse = 'gt_labelstats';
% %       else
% %         labelsToUse = 'labels';
% %         labelstatsToUse = 'labelstats';
% %       end
%       
%       %timestamp = now;
%       
%       % use all experiments by default
%       if nargin < 2,
%         expi = 1:obj.nexps;
%       end
%       
%       % delete all flies by default
%       if nargin < 3,
%         for i = expi(:)',
%           obj.labels(expi).t0s = {};
%           obj.labels(expi).t1s = {};
%           obj.labels(expi).names = {};
%           obj.labels(expi).flies = [];
%           obj.labels(expi).off = [];
%           obj.labels(expi).timestamp = {};
%           obj.labelstats(expi).nflies_labeled = 0;
%           obj.labelstats(expi).nbouts_labeled = 0;
%           obj.labels(expi).imp_t0s = {};
%           obj.labels(expi).imp_t1s = {};
%         end
%       else
%         if numel(expi) > 1,
%           error('If flies input to ClearLabels, expi must be a single experiment');
%         end
%         % no labels
%         if numel(obj.labels) < expi,
%           return;
%         end
%         % which index of labels
%         [~,flyis] = ismember(obj.labels(expi).flies,flies,'rows');
%         for flyi = flyis(:)',
%           % keep track of number of bouts so that we can update stats
%           ncurr = numel(obj.labels(expi).t0s{flyi});
%           obj.labels(expi).t0s{flyi} = [];
%           obj.labels(expi).t1s{flyi} = [];
%           obj.labels(expi).names{flyi} = {};
%           obj.labels(expi).timestamp{flyi} = [];
%           obj.labels(expi).imp_t0s{flyi} = [];
%           obj.labels(expi).imp_t1s{flyi} = [];
%           % update stats
%           obj.labelstats(expi).nflies_labeled = obj.labelstats(expi).nflies_labeled - 1;
%           obj.labelstats(expi).nbouts_labeled = obj.labelstats(expi).nbouts_labeled - ncurr;
%         end
%       end
%       
%       % clear labelidx if nec
%       if ismember(obj.expi,expi) && ((nargin < 3) || ismember(obj.flies,flies,'rows')),
%         obj.labelidx.vals(:) = 0;
%         obj.labelidx.imp(:) = 0;
%         obj.labelidx.timestamp(:) = 0;
%       end
%       
%       % clear windowdata labelidx_new
%       for i = expi(:)',
%         if nargin < 3,
%           idx = obj.windowdata.exp == i;
%         else
%           idx = obj.windowdata.exp == i & ismember(obj.windowdata.flies,flies,'rows');
%         end
%         obj.windowdata.labelidx_new(idx) = 0;
%         obj.windowdata.labelidx_imp(idx) = 0;
%         obj.UpdateErrorIdx();
%       end
%       
%     end

    
    % ---------------------------------------------------------------------
    function SetLabel(obj,expi,flies,ts,behaviori,important)
    % SetLabel(obj,expi,flies,ts,behaviori)
      % Set label for experiment expi, flies, and frames ts. If
    % expi, flies match current expi, flies, then we only set labelidx.
      % Otherwise, we set labels.
      
      % behaviori, same as JLabel/SetLabelPlot:
      % - If greater than 0, behavior index to label. Valid vals: [1..numbehaviors]
      % - If == 0, clear labels for all timelines/behaviors.
      % - If < 0, timeline index to clear. Valid vals: [1..numtimelines]
      
      if behaviori<=0 % clear labels
        assert(important==0);        
        if behaviori==0
          iTL = 1:obj.ntimelines;
        else
          iTL = -behaviori;
        end  
        lblVal = 0;
      else % label
        iTL = obj.labelidx.idxBeh2idxTL(behaviori);
        lblVal = behaviori;
      end
      if obj.IsCurFly(expi,flies),
        obj.labelidx.vals(iTL,ts+obj.labelidx_off) = lblVal;
        obj.labelidx.imp(iTL,ts+obj.labelidx_off) = important;
        obj.labelidx.timestamp(iTL,ts+obj.labelidx_off) = now;
      else
        [labelidx,T0] = obj.GetLabelIdx(expi,flies); %#ok<*PROP>
        labelidx.vals(iTL,ts+1-T0) = lblVal;
        labelidx.imp(iTL,ts+1-T0) = important;
        labelidx.timestamp(iTL,ts+1-T0) = now;
        obj.StoreLabelsForGivenAnimal(expi,flies,labelidx,1-T0);
      end
      obj.UpdateErrorIdx();
      obj.needsave=true;
    end
    
    
    % ---------------------------------------------------------------------
%     function SetLabel_KB(obj,expi,flies,ts,behaviori,important)
% 
%       % SetLabel_KB(obj,expi,flies,ts,behaviori)
%       % Set label for experiment expi, flies, and frames ts to behaviori.
%       % Store everywhere.
%       
%       % store in labelidx
%       if obj.IsCurFly(expi,flies),
%         obj.labelidx.vals(ts+obj.labelidx_off) = behaviori;
%         obj.labelidx.imp(ts+obj.labelidx_off) = important;
%         obj.labelidx.timestamp(ts+obj.labelidx_off) = now;
%       end      
% 
%       % store in labels
%       [labelidx,T0] = obj.GetLabelIdx(expi,flies);
%       labelidx.vals(ts+1-T0) = behaviori;
%       labelidx.imp(ts+1-T0) = important;
%       labelidx.timestamp(ts+1-T0) = now;
%       obj.StoreLabels1(expi,flies,labelidx,1-T0);
%       
%       % store in windowdata
%       idxcurr = obj.windowdata.exp == expi & obj.windowdata.flies == flies & ismember(obj.windowdata.t,ts);
%       obj.windowdata.labelidx_new(idxcurr) = behaviori;
%       obj.windowdata.labelidx_imp(idxcurr) = important;
%       
%     end
    
    
    % ---------------------------------------------------------------------
    function setWindowFeaturesParams(obj,windowFeaturesParams)
      % Updates the feature params.  Called after user clicks Done in 
      % Select Features...
      
      % MERGESTUPDATED
      
      if iscell(windowFeaturesParams)
        assert(numel(windowFeaturesParams)==obj.nclassifiers);
      else
        % convenience API, 'scalar expansion'
        assert(isstruct(windowFeaturesParams) && isscalar(windowFeaturesParams));
        windowFeaturesParams = repmat({windowFeaturesParams},1,obj.nclassifiers);
      end
            
      % obj.setWindowFeaturesParamsRaw(params);
      obj.windowfeaturesparams = windowFeaturesParams;
      obj.windowfeaturescellparams = cellfun(...
        @JLabelData.convertParams2CellParams,windowFeaturesParams,'uni',0);
      obj.curperframefns = cellfun(@fieldnames,windowFeaturesParams,'uni',0);
      oldScoreNorm = {obj.windowdata.scoreNorm};

      obj.clearClassifierProper();
      obj.initWindowData();
      obj.SetWindowFeatureNames();
%       [success,msg]=obj.PreLoadPeriLabelWindowData();
%       if ~success, 
%         error('JLabelData:unableToLoadPerLabelWindowData',msg);
%       end
      obj.needsave = true;
      
      for iCls = 1:obj.nclassifiers
        if obj.HasLoadedScores(iCls)
            obj.windowdata(iCls).scoreNorm = oldScoreNorm{iCls};
        end
      end
    end
    
    
% Training and prediction.
    

    % ---------------------------------------------------------------------
    function Train(obj,doFastUpdates,timerange)
    % Train(obj)
    % Updates the classifier to reflect the current labels. This involves
    % first loading/precomputing the training features. Then, the clasifier
    % is trained/updated. Finally, predictions for the currently loaded
    % window data are updated. Currently, the only implemented classifier is 
    % boosting. If the classifier exists, then it is updated instead of
    % retrained from scratch. This involves three steps -- replacing labels
    % for frames which have changed label, removing examples for frames
    % which have been removed the training set, and adding new examples for
    % newly labeled frames. If the classifier has not yet been trained, it
    % is trained from scratch. 
      
    % MERGEST UPDATED
    
      assert(~obj.isST);
    
      obj.StoreLabelsAndPreLoadWindowData();
      
      % load all labeled data
      [success,msg] = obj.PreLoadPeriLabelWindowData();
      if ~success
        error('JLabelData:unableToLoadPerLabelWindowData',msg);
      end
      
      if nargin<2
        % ALTODO: Looks like doFastUpdates input arg can be removed
        doFastUpdates = false;
      end
      assert(nargin<3,'Unexpected call arguments.');      
%       if nargin >= 3 && ~isempty(timerange),
%         label_timestamp = obj.GetLabelTimestamps(obj.windowdata.exp(islabeled),...
%           obj.windowdata.flies(islabeled,:),obj.windowdata.t(islabeled));
%         islabeled(islabeled) = label_timestamp >= timerange(1) & label_timestamp < timerange(2);
%       end

      cls2IdxBeh = obj.iCls2iLbl;
      assert(numel(cls2IdxBeh)==obj.nclassifiers);
      assert(iscell(obj.trainstats) && numel(obj.trainstats)==obj.nclassifiers);
      for iCls = 1:obj.nclassifiers
        islabeled = obj.windowdata(iCls).labelidx_new~=0 & obj.windowdata(iCls).labelidx_imp;
        if ~any(islabeled)
          continue;
        end

        switch obj.classifiertype{iCls}
          case {'boosting','fancyboosting'}
            %fprintf('!!REMOVE THIS: resetting the random number generator for repeatability!!\n');
            %stream = RandStream.getGlobalStream;
            %reset(stream);

            if obj.DoFullTraining(doFastUpdates)
              obj.SetStatus('Training boosting classifier from %d examples...',nnz(islabeled));

              % form label vec that has 1 for 'behavior present'
              labelidxnew = obj.windowdata(iCls).labelidx_new(islabeled);
              assert(numel(cls2IdxBeh{iCls})==2);
              valBeh = cls2IdxBeh{iCls}(1);
              valNoBeh = cls2IdxBeh{iCls}(2);
              assert(all(labelidxnew==valBeh | labelidxnew==valNoBeh));
              labels12 = 2*ones(size(labelidxnew));
              labels12(labelidxnew==valBeh) = 1;
              % check for presence of both positive and negative labels
              npos = nnz(labels12==1);
              nneg = nnz(labels12~=1);
              if npos < 1 || nneg < 1
                warnstr = sprintf('Classifier %s: Only behavior or nones have been labeled. Not training classifier.',...
                  obj.labelnames{iCls});
                uiwait(warndlg(warnstr));
                continue;
              end
              
              obj.classifier_old{iCls} = obj.classifier{iCls};
              [obj.windowdata(iCls).binVals] = findThresholds(...
                obj.windowdata(iCls).X(islabeled,:),...
                obj.classifier_params{iCls},'deterministic',obj.deterministic);
              bins = findThresholdBins(obj.windowdata(iCls).X(islabeled,:),...
                obj.windowdata(iCls).binVals);
              
              %fprintf('!!REMOVE THIS: resetting the random number generator for repeatability!!\n');
              %stream = RandStream.getGlobalStream;
              %reset(stream);

             if strcmp(obj.classifiertype,'boosting'),
                [obj.classifier{iCls},~,trainstats] =...
                  boostingWrapper(obj.windowdata(iCls).X(islabeled,:), ...
                                  labels12,obj,...
                                  obj.windowdata(iCls).binVals,...
                                  bins, ...
                                  obj.classifier_params{iCls});
              else
                [obj.classifier{iCls}] = ...
                  fastBag(obj.windowdata(iCls).X(islabeled,:),...
                          labels12,...
                          obj.windowdata(iCls).binVals,...
                          bins, ...
                          obj.classifier_params{iCls});
                trainstats = struct;
              end
              obj.lastFullClassifierTrainingSize = nnz(islabeled);

            else
              assert(false,'MERGE unreachable codepath not updated.');
%               oldNumPts = nnz(obj.windowdata.labelidx_cur ~= 0 & obj.windowdata.labelidx_imp );
%               newNumPts = nnz(obj.windowdata.labelidx_new ~= 0 & obj.windowdata.labelidx_imp );
%               newData = newNumPts - oldNumPts;
%               obj.SetStatus('Updating boosting classifier with %d examples...',newData);
% 
%               bins = findThresholdBins(obj.windowdata.X(islabeled,:),obj.windowdata.binVals);
% 
%               obj.classifier_old = obj.classifier;
%               if strcmp(obj.classifiertype,'boosting'),
%                 [obj.classifier, ~, trainstats] = ...
%                   boostingUpdate(obj.windowdata.X(islabeled,:),...
%                                  obj.windowdata.labelidx_new(islabeled),...
%                                  obj.classifier, ...
%                                  obj.windowdata.binVals,...
%                                  bins, ...
%                                  obj.classifier_params);
%               else
%                 error('Fast updates not defined for fancy boosting.');
%               end
            end
            
            obj.classifierTS(iCls) = now();

            % store training statistics
            if isempty(obj.trainstats{iCls})
              obj.trainstats{iCls} = trainstats;
              obj.trainstats{iCls}.timestamps = obj.classifierTS(iCls);
            else
              assert(isstruct(obj.trainstats{iCls}));
              trainstatfns = fieldnames(trainstats);
              for fn = trainstatfns(:)',fn=fn{1}; %#ok<FXSET>
                val = trainstats.(fn);
                if isempty(val)
                  val = nan;
                end
                obj.trainstats{iCls}.(fn)(end+1) = val;
              end
              obj.trainstats{iCls}.timestamps(end+1) = obj.classifierTS(iCls);
            end

            obj.windowdata(iCls).labelidx_old = obj.windowdata(iCls).labelidx_cur;
            obj.windowdata(iCls).labelidx_cur = obj.windowdata(iCls).labelidx_new;
            obj.windowdata(iCls).scoreNorm = nan;
            
            % To later find out where each example came from.
            
  %           obj.windowdata.isvalidprediction = false(numel(islabeled),1);
        end
      end
      
      obj.MoveCurPredictionsToOld();
      obj.FindFastPredictParams();
      obj.PredictLoaded();
 
      obj.needsave = true;
      obj.ClearStatus();      
    end 
    
    function TrainST(obj)
      assert(obj.isST);
      
      % Right now working off the jab, presumably better to just use obj
      Q = loadAnonymous(obj.everythingFileNameAbs);
      
      % Figure out which classifiers are out of date
      timelineTSes = Labels.mostRecentTimelineTimestamps(Q.labels);
      classifierTSes = getstructarrayfield(Q.classifierStuff,'timeStamp',...
        'numericscalar',true);
      
      [realbehnames,nobehnames] = Labels.verifyBehaviorNames(Q.behaviors.names);
      Nrealbeh = numel(realbehnames);
      assert(all(ismember(fieldnames(timelineTSes),realbehnames)));
      assert(Nrealbeh==numel(classifierTSes));
      
      deltaTS = nan(Nrealbeh,1);
      for iBeh = 1:Nrealbeh
        bname = realbehnames{iBeh};
        if isfield(timelineTSes,bname)
          lblTS = timelineTSes.(bname);
        else
          lblTS = inf;
        end
        clsTS = classifierTSes(iBeh);
        deltaTS(iBeh) = lblTS-clsTS;
      end
      trainTS = deltaTS>0;
      
      % Train
      if isfield(Q.extra,'usePastOnly'),
        usePastOnly = Q.extra.usePastOnly;
      else
        usePastOnly = false;
      end
      trainIdx = find(trainTS);
      trainIdx = trainIdx(:)';
      if ~isempty(trainIdx)
        for tIdx = trainIdx
          fprintf('Training classifier ''%s'', %s out of date.\n',...
            realbehnames{tIdx},deltadatenumstr(deltaTS(tIdx)));
        end
      else
        fprintf('All classifiers up-to-date, no training necessary.\n');
      end
      pause(2.0);
      for tIdx = trainIdx
        obj.classifier{tIdx} = trainDetectorSTCore(Q.expDirNames,Q.labels,realbehnames{tIdx},nobehnames{tIdx},usePastOnly);
        obj.classifierTS(tIdx) = now;
      end
      
      obj.needsave = true;
    end
    
    
    % ---------------------------------------------------------------------
    function predictForCurrentTargetAndTimeSpan(obj)
      obj.Predict(obj.expi,obj.flies,obj.t0_curr,obj.t1_curr)
    end
      
    % ---------------------------------------------------------------------
    function Predict(obj,expi,flies,t0,t1)
    % Predict(obj,expi,flies,ts)
    % Runs the behavior classifier on the input experiment, flies, and
    % frames. This involves first precomputing the window data for these
    % frames, then applying the classifier. 
     
      %MERGESTUPDATED
      
      % TODO: don't store window data just because predicting. 

      if isempty(t0) || t0>t1
        return;
      end
            
      % Get the relevant window data in main memory so that we can predict on it
      % [success,msg] = obj.PreLoadWindowData(expi,flies,t0:t1);
      % if ~success ,
      % error('JLabelData:unableToLoadWindowDataForPrediction',msg);
      % end
            
      didpredict = false(obj.nclassifiers,1);
      for iCls = 1:obj.nclassifiers
        if isempty(obj.classifier{iCls})
          continue;
        end
        
        switch obj.classifiertype{iCls}
          case {'boosting','fancyboosting'}
            if obj.nclassifiers==1
              obj.SetStatus('Updating Predictions ...');
            else
              obj.SetStatus('Updating Predictions for %s...',obj.labelnames{iCls});
            end
            didpredict(iCls) = obj.PredictFast(expi,flies,t0,t1,iCls);
            if didpredict(iCls)
              obj.SetStatus('Predictions updated, applying postprocessing...\n');
            end
        end        
      end
      
      if any(didpredict)
        obj.ApplyPostprocessing(expi,flies);
        obj.UpdatePredictedIdx();
      end
      obj.ClearStatus();
    end
      
    
    % ---------------------------------------------------------------------
    function allScoresCell = PredictWholeMovie(obj,expi)
      % Predict entire movie: all classifiers, all files
      %
      % allScoresCell: cell array of length nclassifiers
      
      % MERGESTUPDATED
      
      if isempty(obj.classifier)
        return;
      end
           
      numFlies = obj.GetNumFlies(expi);
      tStartAll = obj.GetTrxFirstFrame(expi);
      tEndAll = obj.GetTrxEndFrame(expi);
      perframefile = obj.GetPerframeFiles(expi);
      allperframefns = obj.allperframefns;
      clsNames = obj.classifiernames;
      allScoresCell = cell(obj.nclassifiers,1);

      for iCls = 1:obj.nclassifiers
      
        obj.SetStatus(sprintf('Classifying movie %d:%s, %s...',expi,...
          obj.expnames{expi},clsNames{iCls}));

        windowfeaturescellparams = obj.fastPredict(iCls).windowfeaturescellparams;
        curperframefns = obj.fastPredict(iCls).pffs;
        classifier = obj.fastPredict(iCls).classifier;
        if ~obj.fastPredict(iCls).wfidx_valid
          [~,feature_names] = JLabelData.ComputeWindowDataChunkStatic(curperframefns,...
            allperframefns,perframefile,1,windowfeaturescellparams,1,1);
          obj.fastPredict(iCls) = Predict.fastPredictFindWfidx(...
            obj.fastPredict(iCls),feature_names);
        end
        wfidx = obj.fastPredict(iCls).wfidx;
        
        %       tfile = tempname();
        %       wbar = waitbar(0,'Predicting..');
        %       pause(0.01);
        scoresA = cell(1,numFlies);
        postprocessedscoresA = cell(1,numFlies);
        parfor flies = 1:numFlies
          blockSize = 5000*2;
          tStart = tStartAll(flies);
          tEnd = tEndAll(flies);
          
          scores = nan(1,tEnd);
          
          if tEnd-tStart < 3,
            scores(tStart:tEnd) = -1;
            fprintf('Not predicting for %d fly, Trajectory is too short\n',flies);
          else            
            for curt0 = tStart:blockSize:tEnd
              curt1 = min(curt0+blockSize-1,tEnd);
              X = JLabelData.ComputeWindowDataChunkStatic(curperframefns,...
                allperframefns,perframefile,flies,windowfeaturescellparams,curt0-tStart+1,curt1-tStart+1);
              
              scores(curt0:curt1) = myBoostClassify(X(:,wfidx),classifier);
            end
            %         fid = fopen(tfile,'a');
            %         fprintf(fid,'.');
            %         fclose(fid);
            %         fid = fopen(tfile,'r');
            %         xx = fgetl(fid);
            %         fclose(fid);
            %         numdone = numel(xx);
            %         waitbar(numdone/numFlies,wbar);
            fprintf('Prediction done for %s: %d fly, total number of flies:%d\n',clsNames{iCls},flies,numFlies);
          end
          scoresA{flies} = scores;
        end        
        for flies = 1:numFlies
          % AL: not sure why this isn't in the parfor
          postprocessedscoresA{flies} = nan(1,tEndAll(flies));
          postprocessedscoresA{flies}(tStartAll(flies):tEndAll(flies)) = ...
            PostProcessor.PostProcess(scoresA{flies}(tStartAll(flies):tEndAll(flies)),...
            obj.postprocessparams{iCls},obj.windowdata(iCls).scoreNorm);
        end
        
        allScores = struct; % See ScoreFile.allScrs
        allScores.scores = scoresA;
        allScores.tStart = tStartAll;
        allScores.tEnd = tEndAll;
        allScores.postprocessed = postprocessedscoresA;
        allScores.postprocessparams = obj.postprocessparams{iCls};
        for flies = 1:numFlies
          [i0s,i1s] = get_interval_ends(allScores.postprocessed{flies}>0);
          allScores.t0s{flies} = i0s;
          allScores.t1s{flies} = i1s;
        end
        allScores.scoreNorm = obj.windowdata(iCls).scoreNorm;
        
        allScoresCell{iCls} = allScores;
      end
      
      obj.ClearStatus();
    end
    
    % ---------------------------------------------------------------------
    function PredictWholeMovieNoSave(obj,expi)
      allScores = obj.PredictWholeMovie(expi);
      obj.AddScores(expi,allScores,true);
    end
    
  end
  
  methods % Evaluating performance

    % ---------------------------------------------------------------------
    function [success,msg,crossErrorCell,tlabels] = CrossValidate(obj,varargin)
    % Cross validate on bouts.
    %
    % success: nclassifier-by-1 logical
    % msg: nclassifier-by-1 cellstr
    % crossErrorCell: nclassifier-by-1 cell
    % tlabels: nclassifier-by-1 cell
      
    %MERGESTUPDATED
    
      nCls = obj.nclassifiers;
      success = false(nCls,1);
      msg = repmat({''},nCls,1);
      crossErrorCell = cell(nCls,1);
      tlabels = cell(nCls,1);
      
      obj.StoreLabelsAndPreLoadWindowData();      
      
      tmpsuccess = obj.PreLoadPeriLabelWindowData();
      if ~tmpsuccess        
        return;
      end
      
      [setidx,byexp] = myparse(varargin,'setidx',[],'byexp',false);
      
      for iCls = 1:nCls
        
        wd = obj.windowdata(iCls);
        islabeled = wd.labelidx_new~=0 & wd.labelidx_imp;
        if ~any(islabeled)
%           ce = struct;
%           ce.numbers = zeros(4,3);
%           ce.frac = zeros(4,3);
%           ce.oldNumbers = zeros(4,3);
%           ce.oldFrac = zeros(4,3);
%           crossErrorCell{iCls} = ce;
          msg{iCls} = 'No Labeled Data';
          continue;
        end
        
        if ~strcmp(obj.classifiertype{iCls},'boosting'); 
          msg{iCls} = 'Not boosting classifier';
          continue;
        end        
        
        obj.SetStatus('Cross-validating classifier ''%s'' for %d examples...',...
          obj.classifiernames{iCls},nnz(islabeled));
        
        obj.UpdateBoostingBins(iCls);
        
        bouts = obj.getLabeledBouts(iCls);
        
        if byexp && isempty(setidx)
          [~,~,setidx] = unique(wd.exp);
        end
        
        % Don't use unimportant labels
        labels = wd.labelidx_new;
        labels(~wd.labelidx_imp) = 0;
        iLbl = obj.iCls2iLbl{iCls};
        iLblPos = iLbl(1);
        iLblNeg = iLbl(2);
        labels012 = Labels.labelVec2label012(labels,iLblPos,iLblNeg);
                
        [success(iCls),msg{iCls},crossScores,tlabels{iCls}] = ...
          obj.crossValidateBout(iCls,labels012,bouts,true,setidx);        
        if ~success(iCls)
%           crossError.numbers = zeros(4,3);
%           crossError.frac = zeros(4,3);
%           crossError.oldNumbers = zeros(4,3);
%           crossError.oldFrac = zeros(4,3);
%           tlabels = {};
          continue;          
        end
        
        %{
%       crossScores=...
%         crossValidate( obj.windowdata.X(islabeled,:), ...
%         obj.windowdata.labelidx_cur(islabeled,:),obj,...
%         obj.windowdata.binVals,...
%         obj.windowdata.bins(:,islabeled),obj.classifier_params);
        %}
        
        obj.windowdata(iCls).scores_validated = zeros(numel(islabeled),1);
        obj.windowdata(iCls).scores_validated(islabeled) = crossScores(1,:);
        
        % AL: various versions of label-vectors here and above presumably
        % redundant
        labelsLabeled = wd.labelidx_new(islabeled);
        labelsImpLabeled = wd.labelidx_imp(islabeled);
        assert(all(labelsImpLabeled==1));
        labelsLabeled12 = Labels.labelVec2label012(labelsLabeled,iLblPos,iLblNeg);        
        assert(all(labelsLabeled12==1 | labelsLabeled12==2));
        % modLabels: 1==positive+important; 3==negative+important
        modLabels = 2*labelsLabeled12 - labelsImpLabeled;
        
        %crossError=zeros(1,size(crossScores,1));
        nSomething = size(crossScores,1);
        crossError = struct('numbers',cell(1,nSomething),...
          'frac',cell(1,nSomething));
        for tndx = 1:nSomething
          crossError(tndx) = obj.createConfMat(iCls,crossScores(tndx,:),modLabels);
        end
        
        waslabeled = false(numel(islabeled),1);
        waslabeled(1:numel(wd.labelidx_old)) = wd.labelidx_old~=0 & wd.labelidx_imp;
        oldSelect = waslabeled(islabeled);
        oldScores = crossScores(oldSelect);
        tfWasIsLbled = waslabeled(:)&islabeled(:);
        labelsCur = wd.labelidx_cur(tfWasIsLbled);
        labelsImp = wd.labelidx_imp(tfWasIsLbled);
        assert(all(labelsImp==1));
        labelsCur12 = Labels.labelVec2label012(labelsCur,iLblPos,iLblNeg);
        
        oldLabels = 2*labelsCur12 - labelsImp;
        oldError = obj.createConfMat(iCls,oldScores,oldLabels);
        crossError(1).oldNumbers = oldError.numbers;
        crossError(1).oldFrac = oldError.frac;
        
        crossErrorCell{iCls} = crossError;
      end
      
      obj.ClearStatus();
    end

    
    % ---------------------------------------------------------------------    
    function [success,msg,scores,tlabels] = ...
        crossValidateBout(obj,iCls,labels,bouts,timed,setidx)
      %
      % Let windowdata have length nsamp, ie nsamp = numel(obj.windowdata(iCls).t)
      %
      % iCls: classifier index
      % labels: vector of length nsamp. Values are 1/2 for pos/neg labels, 
      %   resp. Conceptually like obj.windowdata(iCls).labelidx; can 
      %   contain 0 (?).
      % bouts: see getLabeledBouts()
      % timed: scalar logical. Currently ignored/set to false
      % setidx: integer grouping vector, length nsamp. Values in range 1:k. 
      %   Partitions windowdata for k-fold crossvalidation.
      %
      % scores: vector of classification scores. Length nsamp, except 
      %  indices for labels==0 removed.
      % tlabels: Currently unused (for timed)
      
      %MERGESTUPDATED
      
      data = obj.windowdata(iCls).X;
      binVals = obj.windowdata(iCls).binVals;
      params = obj.classifier_params{iCls};
      
      [nsamp,nftrs] = size(data);
      assert(size(binVals,2)==nftrs);
      assert(isvector(labels) && numel(labels)==nsamp);
      assert(all(labels==0 | labels==1 | labels==2)); % AL: are there labels==0?
      assert(size(bouts.ndx,2)==nsamp);      

      modLabels = sign((labels==1)-0.5); % labels==0?

      if exist('timed','var') && timed
        fprintf('WARNING: setting timed = false in crossValidateBout, even though the input is true. FIX THIS!\n');
      end
      timed = false;

      if exist('setidx','var') && ~isempty(setidx)
        validateattributes(setidx,{'numeric'},{'integer' 'vector' 'numel' nsamp});
      else
        setidx = [];
      end
      issetidx = ~isempty(setidx);
      
      if issetidx
        k = max(setidx);
      else
        k = params.CVfolds;
      end

      % choose sets to hold out together
      if ~issetidx
        assert(all(bouts.label==1 | bouts.label==2));
        posBouts = bouts.label==1;
        negBouts = ~posBouts;

        numPosBouts = nnz(posBouts);
        numNegBouts = nnz(negBouts);

        if numPosBouts<k || numNegBouts<k
          scores = zeros(1,nsamp);
          scores(labels==0) = []; 
          tlabels = {};
          success = false;

          if numPosBouts<k
            msg = 'Too few bouts of behavior to do cross-validation';
          end
          if numNegBouts <k
            msg = 'Too few bouts of not behavior to do cross-validation';
          end

          return;
        end

        posBlocks = linspace(0,numPosBouts+1,k+1);
        negBlocks = linspace(0,numNegBouts+1,k+1);
        posCum = cumsum(posBouts);
        negCum = cumsum(negBouts);
        % Randomly permute the bouts.
        % ALXXX NEEDS REVIEW
        % Looks like a bug based on subsequent usage
        posCum = posCum(randperm(numel(posCum)));
        negCum = negCum(randperm(numel(negCum)));
      end

      tlabels = {};
      if timed
        assert(false,'Currently unreachable codepath.');
%         tpoints(1) = max(bouts.timestamp);  %#ok
%         tlabels{1} = datestr(tpoints(1));
%         tpoints(end+1) = addtodate(tpoints(1),-5,'minute');
%         tlabels{end+1} = '-5m';
%         tpoints(end+1) = addtodate(tpoints(1),-10,'minute');
%         tlabels{end+1} = '-10m';
%         tpoints(end+1) = addtodate(tpoints(1),-15,'minute');
%         tlabels{end+1} = '-15m';
%         tpoints(end+1) = addtodate(tpoints(1),-20,'minute');
%         tlabels{end+1} = '-20m';
%         tpoints(end+1) = addtodate(tpoints(1),-25,'minute');
%         tlabels{end+1} = '-25m';
%         tpoints(end+1) = addtodate(tpoints(1),-30,'minute');
%         tlabels{end+1} = '-30m';
%         tpoints(end+1) = addtodate(tpoints(1),-45,'minute');
%         tlabels{end+1} = '-45m';
%         tpoints(end+1) = addtodate(tpoints(1),-1,'hour');
%         tlabels{end+1} = '-1h';
%         tpoints(end+1) = addtodate(tpoints(1),-2,'hour');
%         tlabels{end+1} = '-2h';
%         tpoints(end+1) = addtodate(tpoints(1),-3,'hour');
%         tlabels{end+1} = '-3h';
%         tpoints(end+1) = addtodate(tpoints(1),-4,'hour');
%         tlabels{end+1} = '-4h';
%         tpoints(end+1) = addtodate(tpoints(1),-1,'day');
%         tlabels{end+1} = '-1d';
%         tpoints(end+1) = addtodate(tpoints(1),-2,'day');
%         tlabels{end+1} = '-2d';
%         tpoints(end+1) = addtodate(tpoints(1),-3,'day');
%         tlabels{end+1} = '-3d';
%         tpoints(end+1) = addtodate(tpoints(1),-7,'day');
%         tlabels{end+1} = '-1w';
%         tpoints(end+1) = addtodate(tpoints(1),-7*2,'day');
%         tlabels{end+1} = '-2w';
%         tpoints(end+1) = addtodate(tpoints(1),-1,'month');
%         tlabels{end+1} = '-1mo';
%         tpoints(end+1) = addtodate(tpoints(1),-2,'month');
%         tlabels{end+1} = '-2mo';
%         tpoints(end+1) = addtodate(tpoints(1),-6,'month');
%         tlabels{end+1} = '-6mo';
%         tpoints(end+1) = addtodate(tpoints(1),-1,'year');
%         tlabels{end+1} = '-1y';
%         tpoints(end+1) = addtodate(tpoints(1),-2,'year');
%         tlabels{end+1} = '-2y';
%         tpoints(end+1) = addtodate(tpoints(1),-10,'year');
%         tlabels{end+1} = '-10y';
% 
%         tooOld = tpoints< min(bouts.timestamp) ;
%         tpoints(tooOld) = [];
%         tlabels(tooOld) = [];
      else
        tpoints = now;
      end

      scores = zeros(numel(tpoints),nsamp);
      bins = findThresholdBins(data,binVals);

      for bno = 1:k
        % generate curTestNdx, indicator vector for test set
        if ~issetidx
          % AL 20141216: Looks like intent is, give me bno'th block of 
          % positive bouts, suitably randomized; and similarly for negative
          % bouts. However, seems unlikely that random permutation of 
          % pos/negCum above has the desired effect. Eg consider 
          % negBouts = [1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 ... many zeros]. 
          % In this case negCum is dominated by the value 4 and after
          % randomization the likely effect is that whichever block
          % contains 4 will contain all bouts.
          curPosTest = posCum >= posBlocks(bno) & posCum < posBlocks(bno+1) & posBouts;
          curNegTest = negCum >= negBlocks(bno) & negCum < negBlocks(bno+1) & negBouts;
          curTestNdx = false(1,nsamp);
          assert(isrow(curPosTest));
          assert(isrow(curNegTest));
          for posNdx = find(curPosTest)
            curTestNdx = curTestNdx | bouts.ndx(posNdx,:);
          end          
          for negNdx = find(curNegTest)
            curTestNdx = curTestNdx | bouts.ndx(negNdx,:);
          end          
        else          
          curTestNdx = setidx==bno;          
        end

        for tndx = 1:numel(tpoints)
          % find curTrainNdx, indicator vector for train set
          if ~issetidx
            curPosTrain = find(~curPosTest & posBouts & bouts.timestamp<=tpoints(tndx));
            curNegTrain = find(~curNegTest & negBouts & bouts.timestamp<=tpoints(tndx));
            curTrainNdx = false(1,nsamp);
            assert(isrow(curPosTrain));
            assert(isrow(curNegTrain));
            for posNdx = curPosTrain
              curTrainNdx = curTrainNdx | bouts.ndx(posNdx,:);
            end
            for negNdx = curNegTrain
              curTrainNdx = curTrainNdx | bouts.ndx(negNdx,:);
            end            
          else            
            curTrainNdx = bno~=setidx;            
          end
          
          assert(~any(curTestNdx & curTrainNdx),'Training/testing sets are not disjoint.');

          curTrainLabels = modLabels(curTrainNdx);

          wt = getWeights(curTrainLabels);  
          tt = tic;
          curbins = curTrainNdx;
          [~,curModel] = loglossboostLearnRandomFeatures(data(curTrainNdx,:),curTrainLabels,...
            params.iter,wt,binVals,bins(:,curbins),params);
          tScores = myBoostClassify(data(curTestNdx,:),curModel);
          scores(tndx,curTestNdx) = tScores;
          etime = toc(tt);
          done = ((bno-1)*numel(tpoints) + tndx);
          obj.SetStatus('%d%% cross-validation done.  Time Remaining: %d s ',...
            round( done/(numel(tpoints)*k)*100), ...
            round( ((numel(tpoints)*k)-done)*etime));
          drawnow();
        end
      end

      scores(:,labels==0) = [];
      success = true;
      msg = '';
    end
    
    
    % ---------------------------------------------------------------------
    function [curScores,modLabels] = getCurrentScoresForROCCurve(obj,iCls)
      %MERGESTUPDATED
      
      if ~obj.classifierIsPresent()
        error('JLabelData:noClassifier', ...
              'No classifier has been trained to set the confidence thresholds.');
      end
      
      clsfr = obj.classifier{iCls};
      windata = obj.windowdata(iCls);
      labels = windata.labelidx_new;
      iLbls = obj.iCls2iLbl{iCls};
      
      curNdx = labels~=0;
      curLabels = labels(curNdx);
      curLabels12 = Labels.labelVec2label012(curLabels,iLbls(1),iLbls(2));
      modLabels = ((curLabels12==1)-0.5)*2;
      curScores = myBoostClassify(windata.X(curNdx,:),clsfr);
    end
        
    
    % ---------------------------------------------------------------------
    function newError = TestOnNewLabels(obj,iCls)
      %MERGESTUPDATED
      
      obj.StoreLabelsAndPreLoadWindowData();
      [success,msg] = obj.PreLoadPeriLabelWindowData();
      if ~success
        warning(msg);
        return;
      end
            
      newError = struct();
      
      windata = obj.windowdata(iCls);

      prevLabeled = windata.labelidx_cur~=0;
      Nprev = numel(prevLabeled);
      newLabels = windata.labelidx_new~=0;
      tOld = newLabels(1:Nprev);
      tOld(prevLabeled) = false;
      newLabels(1:Nprev) = tOld;
      
      if ~nnz(newLabels)
        fprintf('No new labeled data\n');
        return;
      end
      
      % Find out the index of scores with the same exp, flynum and time as
      % the newly labeled data.
      
      orderedScores = [];
      orderedLabels = [];
      orderedLabels_imp = [];
      nlexp = windata.exp(newLabels);
      nlflies = windata.flies(newLabels);
      nlt = windata.t(newLabels);
      nlLabels = windata.labelidx_new(newLabels);
      iLbls = obj.iCls2iLbl{iCls};
      nlLabels012 = Labels.labelVec2label012(nlLabels,iLbls(1),iLbls(2));
      nlLabels_imp = windata.labelidx_imp(newLabels);
      
      classifierfilename = 'None';
      %setClassifierfilename = 1;
      unNLExp = unique(nlexp);
      for curExp = unNLExp(:)'
        curNLexpNdx = nlexp==curExp;
        unFlies = unique(nlflies(curNLexpNdx));
        for curFly = unFlies(:)'
          tfExpFly = nlexp==curExp & nlflies==curFly;
          curT = nlt(tfExpFly);
          curLabels = nlLabels012(tfExpFly);
          curLabels_imp = nlLabels_imp(tfExpFly);
          
          pd = obj.predictdata{curExp}{curFly}(iCls);
          curScoreNdx = find(pd.cur_valid);
          scoresT = pd.t(curScoreNdx);
          [curValidScoreNdx,loc] = ismember(scoresT,curT);
          if nnz(curValidScoreNdx)~=numel(curT)
            warndlg('Scores are missing for some labeled data');
            newError = struct();
            return;
          end
          
          orderedLabels = [orderedLabels; curLabels(loc(loc~=0))];  %#ok
          orderedLabels_imp = [orderedLabels_imp; curLabels_imp(loc(loc~=0))];  %#ok
          orderedScores = [orderedScores; pd.cur(curScoreNdx(curValidScoreNdx~=0))'];  %#ok
        end
%         if setClassifierfilename,
%           classifierfilename = obj.windowdata.classifierfilenames{curExp};
%           setClassifierfilename = 0;
%         elseif strcmp(classifierfilename,'multiple'),
%         elseif ~strcmp(classifierfilename,obj.windowdata.classifierfilenames{curExp}),
%           classifierfilename = 'multiple';
%         end
          
      end
      
      modLabels = 2*orderedLabels - orderedLabels_imp;      
      newError = obj.createConfMat(iCls,orderedScores,modLabels);
      newError.classifierfilename = classifierfilename;      
    end
    
%     % ---------------------------------------------------------------------
%     function ROCCurve(obj,JLabelHandle)
%     % This now shows histogram, apt naming be damned.
%     
%       if isempty(obj.classifier),
%           uiwait(warndlg('No classifier has been trained to set the confidence thresholds.'));
%           return;
%       end
%       curNdx = obj.windowdata.labelidx_new~=0;
%       curLabels = obj.windowdata.labelidx_new(curNdx);
%       modLabels = ((curLabels==1)-0.5)*2;
% 
%       curScores = myBoostClassify(obj.windowdata.X(curNdx,:),obj.classifier);
%       
%       ShowROCCurve(modLabels,curScores,obj,JLabelHandle);
%       
%     end
    
  end
  
  methods % Show similar frames
    
    % ---------------------------------------------------------------------
    function DoFastBagging(obj)
      
      assert(false,'ALXXX EXPANDED');
      
      obj.StoreLabelsForCurrentAnimal();
      [success,msg] = obj.PreLoadPeriLabelWindowData();
      if ~success, warning(msg);return;end

      islabeled = obj.windowdata.labelidx_new ~= 0;

      if ~any(islabeled),                        return; end
      if ~strcmp(obj.classifiertype,'boosting'); return; end
      if isempty(obj.classifier), obj.Train;             end

      if isempty(obj.windowdata.binVals),
        obj.windowdata.binVals = findThresholds(obj.windowdata.X(islabeled,:),obj.classifier_params,'deterministic',obj.deterministic);
      end
      
      bins = findThresholdBins(obj.windowdata.X(islabeled,:),obj.windowdata.binVals);

      bmodel = fastBag(obj.windowdata.X(islabeled,:),...
        obj.windowdata.labelidx_new(islabeled),... %LABELIDX
        obj.windowdata.binVals,bins,obj.classifier_params,obj);
      
      obj.bagModels = bmodel;
%       obj.bagModels = obj.classifier;

      obj.SetStatus('Computing parameters for fast distance computation..');
      % Find the parameters for fast prediction.
      feature_names = obj.windowdata.featurenames;
      
      % which features are actually used
      dims = [obj.bagModels(:).dim];


      wfidxcurr = unique(dims,'stable');
      wfs = feature_names(wfidxcurr);
      feature_names = feature_names(dims);
            
      wf2pff = cellfun(@(x)x{1},wfs,'UniformOutput',false);
      [pffs,~,wf2pffidx] = unique(wf2pff);
      
      windowfeaturescellparams = struct;
      for pfi = 1:numel(pffs),
        pf = pffs{pfi};
        wfidx_cur = wf2pffidx==pfi;
        windowfeaturescellparams.(pf) = WindowFeatureName2Params(wfs(wfidx_cur));
      end
      
      classifiers_indexed = obj.bagModels;
      for j = 1:numel(classifiers_indexed),
        classifiers_indexed(j).dim = j;
      end
      
      obj.fastPredictBag.classifier = classifiers_indexed;
      obj.fastPredictBag.windowfeaturescellparams = windowfeaturescellparams;
      obj.fastPredictBag.wfs = feature_names;
      obj.fastPredictBag.pffs = pffs;
      obj.fastPredictBag.ts = obj.classifierTS;
      obj.fastPredictBag.tempname = tempname;
 
      features_names_sel = {};
      for ndx = 1:numel(pffs)
        [~,curf] = ComputeWindowFeatures([0,0],...
          windowfeaturescellparams.(pffs{ndx}){:});
        feature_names_curr = cellfun(@(x) [{pffs{ndx}},x],curf,'UniformOutput',false);  %#ok
        features_names_sel = [features_names_sel,feature_names_curr]; %#ok<AGROW>
      end
      
      
      ttt = tic;
      wfidx = nan(1,numel(feature_names));
      matched = false(1,numel(dims));
      for j = 1:numel(feature_names),
        if matched(j), continue, end
        
        idxcurr = find(WindowFeatureNameCompare(feature_names{j},features_names_sel));
        if numel(idxcurr) ~= 1,
          error('Error matching wfs for classifier with window features computed');
        end
        curidx = dims==dims(j);
        matched(curidx) = true;
        wfidx(curidx) = idxcurr;
        if(mod(j,100)==0)
          telapsed = toc(ttt);
          obj.SetStatus('Indexing the feature names ... %d%% done: Time Remaining:%ds',...
            round(nnz(matched)/numel(matched)*100),round(telapsed/nnz(matched)*(numel(matched)-nnz(matched))));
        end
      end
  
%       ttt = tic;
%       wfidx = nan(1,numel(feature_names));
%       for j = 1:numel(feature_names),
%         
%         idxcurr = find(WindowFeatureNameCompare(feature_names{j},features_names_sel));
%         if numel(idxcurr) ~= 1,
%           error('Error matching wfs for classifier with window features computed');
%         end
%         wfidx(j) = idxcurr;
%         if(mod(j,100)==0)
%           telapsed = toc(ttt);
%           obj.SetStatus('Indexing the feature names ... %d%% done: Time Remaining:%ds',...
%             round(j/numel(feature_names)*100),round(telapsed/j*(numel(feature_names)-j)));
%         end
%       end

      obj.fastPredictBag.wfidx = wfidx;

      
      obj.fastPredictBag.dist = cell(1,obj.nexps);
      obj.ClearStatus();
      
    end  % method
    

    % ---------------------------------------------------------------------
    function [success,msg] = SetCurrentFlyForBag(obj,exp,fly,t)
      obj.fastPredictBag.curexp = exp;
      obj.fastPredictBag.fly = fly;
      obj.fastPredictBag.t = t;
      
      [success,msg,t0,t1,X] = obj.ComputeWindowDataChunk(exp,fly,t,'center',true);
      
      curX = X((t0:t1)==t,:);
      curF = zeros(1,numel(obj.bagModels));
      for ndx = 1:numel(obj.bagModels);
        curWk = obj.bagModels(ndx);
        dd = curX(:,curWk.dim)*curWk.dir;
        tt = curWk.tr*curWk.dir;
        curF(ndx) = sign( (dd>tt) - 0.5) * curWk.alpha;
      end
      obj.fastPredictBag.curF = curF;
      obj.fastPredictBag.dist = {};
      obj.fastPredictBag.trainDist = {};
    end
    
    function [success,msg] = UnsetCurrentFlyForBag(obj)
      success=true;
      msg='';
      obj.fastPredictBag.curexp = [];
      obj.fastPredictBag.fly = [];
      obj.fastPredictBag.t = [];
      obj.fastPredictBag.dist = {};
      obj.fastPredictBag.trainDist = {};
      obj.fastPredictBag.curF = [];
      
    end

    
    % ---------------------------------------------------------------------
    function dist = GetDistance(obj,expi,flies)
      %ALXXX EXPANDED
      
      if obj.HasDistance(expi,flies)
        obj.ComputeBagDistanceTraining();
        distNorm = median(obj.fastPredictBag.trainDist);
        dist = obj.fastPredictBag.dist{expi}{flies};
        dist = dist/distNorm;
        dist(dist>1) = 1;
      elseif ~isempty(obj.bagModels) && ~isempty(obj.fastPredictBag.curexp),
        obj.ComputeBagDistanceTraining();
        distNorm = median(obj.fastPredictBag.trainDist);
        T0 = obj.firstframes_per_exp{expi}(flies);
        T1 = obj.endframes_per_exp{expi}(flies);
        dist = nan(1, T1- T0 +1);
        idx = obj.FlyNdx(expi,flies);
        t = obj.windowdata.t(idx);
        dist(t-T0+1) = obj.fastPredictBag.trainDist(idx);
        dist = dist/distNorm;
        dist(dist>1) = 1;
      else
        T0 = obj.firstframes_per_exp{expi}(flies);
        T1 = obj.endframes_per_exp{expi}(flies);
        dist = nan(1, T1- T0 +1);
      end
      
    end
    
    
    % ---------------------------------------------------------------------
    function [nextT, distT] = NextClosestBagFly(obj,dir,curt,expi,flies,curV,ignore,jumpList,jumpRestrict)
      
      assert(false,'ALXXX EXPANDED');
            
      nextT = []; distT =[];
      if  isempty(obj.fastPredictBag.dist) || ...
          isempty(obj.fastPredictBag.dist{expi}) || ...
         numel(obj.fastPredictBag.dist{expi})<flies || ...
         isempty(obj.fastPredictBag.dist{expi}{flies}) 
        [success,msg] = obj.ComputeBagDistFly(expi,flies);
        if ~success,
          uiwait(warndlg(msg)); 
          return;
        end
      end
      dist = obj.fastPredictBag.dist{expi}{flies};
      
      T0 = obj.firstframes_per_exp{expi}(flies);
      T1 = obj.endframes_per_exp{expi}(flies);
      if isempty(curV)
        curV = dist(curt-T0+1);
      end
      
      for ndx = 1:numel(jumpList)
        if jumpList(ndx).exp ~= expi || jumpList(ndx).fly ~= flies
          continue;
        end
        idx = jumpList(ndx).t -T0 + 1 + (-ignore:ignore);
        idx(idx<0) = [];
        idx(idx>numel(dist)) = [];
        dist(idx) = inf;
      end
      
      if strcmp(jumpRestrict,'behavior')
        obj.PredictFast(expi,flies,T0,T1); %ALXXX API
        dist(obj.predictdata{expi}{flies}.cur < 0) = inf;
      elseif strcmp(jumpRestrict,'none')
        obj.PredictFast(expi,flies,T0,T1); %ALXXX API
        dist(obj.predictdata{expi}{flies}.cur > 0) = inf;        
      end
      
      [nextT, distT] = obj.FindNextClosest(dist,curV,dir);
      nextT= nextT+T0-1;
    end
    
    
    % ---------------------------------------------------------------------
    function [bestnextT,bestdistT,bestfly] = NextClosestBagExp(obj,dir,curt,expi,flies,ignore,jumpList,jumpRestrict)
      
      bestnextT = []; bestfly = [];
      switch dir
        case 'next'
          bestdistT = inf;
        case 'prev' 
          bestdistT = -inf;
        otherwise
          uiwait(warndlg('Undefined direction'));
          bestdistT = [];
          return;
      end
      
      if isempty(obj.fastPredictBag.dist) || ...
          isempty(obj.fastPredictBag.dist{expi}) || ...
          numel(obj.fastPredictBag.dist{expi})<flies || ...
          isempty(obj.fastPredictBag.dist{expi}{flies})
        [success,msg] = obj.ComputeBagDistFly(expi,flies);
        if ~success,
          uiwait(warndlg(msg));
          return;
        end
      end

      T0 = obj.firstframes_per_exp{expi}(flies);
      curV = obj.fastPredictBag.dist{expi}{flies}(curt-T0+1);
      
      for fly = 1:obj.nflies_per_exp(expi)
        [nextT, distT] = obj.NextClosestBagFly(dir,curt,expi,fly,curV,ignore,jumpList,jumpRestrict);
        if strcmp(dir,'next')
          if distT < bestdistT
            bestdistT = distT;
            bestnextT = nextT;
            bestfly = fly;
          end
        else
          if distT > bestdistT
            bestdistT = distT;
            bestnextT = nextT;
            bestfly = fly;
          end
          
        end
      end
      
    end
    
    
    % ---------------------------------------------------------------------
    function [nextT, distT, fly, exp ] = ...
        NextClosestBagTraining(obj,jtype,curT,curExp,curFly,ignore,jumpList,jumpRestrict)
      
      %ALXXX EXPANDED
      
      nextT = []; distT = []; fly = []; exp = [];
      
      obj.ComputeBagDistanceTraining();
      
      dist = obj.fastPredictBag.trainDist;
      
      curndx = find(obj.FlyNdx(curExp,curFly) & obj.windowdata.t == curT);
      if isempty(curndx)
        curV = 0;
      else
        curV = dist(curndx);
      end
      
      % Ignore close by bouts to previously seen examples
      for ndx = 1:numel(jumpList)
        idx = obj.FlyNdx(jumpList(ndx).exp,jumpList(ndx).fly) & ...
              (abs(obj.windowdata.t - jumpList(ndx).t)<=ignore );
        dist(idx) = inf;
      end
      
      labels = obj.windowdata.labelidx_new; %LABELIDX
      if strcmp(jumpRestrict,'behavior')
        dist(labels ~= 1) = inf;
      elseif strcmp(jumpRestrict,'none')
        dist(labels ~= 2) = inf;
      end
      
      nextNdx = [];
      switch jtype
        case 'next'
          
          if max(dist) > curV,
            tt = dist-curV;
            tt(tt<=0) = inf;
            [~,nextNdx] = min(tt);
            distT = dist(nextNdx);
          end
          
        case 'prev'

          if min(dist) < curV,
            tt = dist-curV;
            tt(tt>=0) = -inf;
            [~,nextNdx] = max(tt);
            distT = dist(nextNdx);
          end
        
      end
      
      if ~isempty(nextNdx)
        fly = obj.windowdata.flies(nextNdx);
        exp = obj.windowdata.exp(nextNdx);
        nextT = obj.windowdata.t(nextNdx);
      end
    end
    
    
    % ---------------------------------------------------------------------
    function DoBagging(obj)
      
      obj.StoreLabelsForCurrentAnimal();
      [success,msg] = obj.PreLoadPeriLabelWindowData();
      if ~success, warning(msg);return;end
      
      islabeled = obj.windowdata.labelidx_new ~= 0;
      
      if ~any(islabeled),                        return; end
      if ~strcmp(obj.classifiertype,'boosting'); return; end
      if isempty(obj.classifier), obj.Train;             end
      
      bouts = obj.getLabeledBouts(); %ALXXX API change
      
      obj.SetStatus('Bagging the classifier with %d examples...',nnz(islabeled));
      
      obj.windowdata.binVals = findThresholds(obj.windowdata.X(islabeled,:),obj.classifier_params,'deterministic',obj.deterministic);
      
      [obj.bagModels, obj.distMat] =...
        doBaggingBouts( obj.windowdata.X, ...
        obj.windowdata.labelidx_new,obj,... %LABELIDX
        obj.windowdata.binVals,...
        obj.classifier_params,bouts);
      
      obj.windowdata.distNdx.exp = obj.windowdata.exp(islabeled);
      obj.windowdata.distNdx.flies = obj.windowdata.flies(islabeled);
      obj.windowdata.distNdx.t = obj.windowdata.t(islabeled);
      obj.windowdata.distNdx.labels = obj.windowdata.labelidx_new(islabeled); %LABELIDX
      
      obj.ClearStatus();
    end
    
    
    % ---------------------------------------------------------------------
    function SimilarFrames(obj,curTime,JLabelHandles)
      if isempty(obj.frameFig) || ~ishandle(obj.frameFig),
        obj.InitSimilarFrames(JLabelHandles),
      end
      
      distNdx = find( (obj.windowdata.distNdx.exp == obj.expi) & ...
        (obj.windowdata.distNdx.flies == obj.flies) & ...
        (obj.windowdata.distNdx.t == curTime) ,1);
      
      windowNdx = find( (obj.windowdata.exp == obj.expi) & ...
        (obj.windowdata.flies == obj.flies) & ...
        (obj.windowdata.t == curTime) ,1);      
      
      if isempty(distNdx) % The example was not part of the training data.
        outOfTraining = 1;
        [~,~,t0,~,curX] = obj.ComputeWindowDataChunk(obj.expi,obj.flies,curTime);

        curX = curX(curTime-t0+1,:);
        curD = zeros(1,length(obj.bagModels)*length(obj.bagModels{1}));
        count = 1;
        for bagNo = 1:length(obj.bagModels)
          curModel = obj.bagModels{bagNo};
          for j = 1:length(curModel)
            curWk = curModel(j);
            dd = curX(curWk.dim)*curWk.dir;
            tt = curWk.tr*curWk.dir;
            curD(count) = (dd>tt)*curWk.alpha;
            count = count+1;
          end
        end
      else
        outOfTraining = 0;
        curD = obj.distMat(distNdx,:);
      end

      % Compute the distance 
      diffMat = zeros(size(obj.distMat));
      for ndx = 1:size(diffMat,2);
        diffMat(:,ndx) = abs(obj.distMat(:,ndx)-curD(ndx));
      end
      dist2train = nanmean(diffMat,2)*200;
      [rr,rrNdx] = sort(dist2train,'ascend');
      
      if~outOfTraining
        rr = rr(2:end);  %#ok
        curEx = rrNdx(1); rrNdx = rrNdx(2:end);  %#ok
      else
        curEx = [];  %#ok
      end
      
      % Find 5 closest pos and neg examples.
      % This looks complicated then it should be.
      % DEBUG: find values of actual labels 
     
      trainLabels =  obj.windowdata.distNdx.labels;
      allPos = rrNdx(trainLabels(rrNdx)>1.5);
      allNeg = rrNdx(trainLabels(rrNdx)<1.5);
      
      
      curP = zeros(1,5);
      curN = zeros(1,5);
      count = 0;
      for ex = allPos'
        if count>4; break; end;
        isClose = 0;
        if ~outOfTraining && ...
          obj.windowdata.exp(windowNdx) == obj.windowdata.distNdx.exp(ex) &&...
           obj.windowdata.flies(windowNdx) == obj.windowdata.distNdx.flies(ex) && ...
           abs( obj.windowdata.t(windowNdx) - obj.windowdata.distNdx.t(ex) )<5,
           continue; 
        end
        
        for used = curP(1:count)
          if obj.windowdata.distNdx.exp(used) == obj.windowdata.distNdx.exp(ex) &&...
             obj.windowdata.distNdx.flies(used) == obj.windowdata.distNdx.flies(ex) && ...
             abs( obj.windowdata.distNdx.t(used) - obj.windowdata.distNdx.t(ex) )<5,
             isClose = 1; 
             break; 
          end
        end
        
        if isClose; continue; end;
        count = count+1;
        curP(count) = ex;
      end
      
      count = 0;
      for ex = allNeg'
        if count>4; break; end;
        isClose = 0;
        if ~outOfTraining && ...
          obj.windowdata.exp(windowNdx) == obj.windowdata.distNdx.exp(ex) &&...
           obj.windowdata.flies(windowNdx) == obj.windowdata.distNdx.flies(ex) && ...
           abs(obj.windowdata.t(windowNdx) - obj.windowdata.distNdx.t(ex))<5,
           continue; 
        end
        
        for used = curN(1:count)
          if obj.windowdata.distNdx.exp(used) == obj.windowdata.distNdx.exp(ex) &&...
             obj.windowdata.distNdx.flies(used) == obj.windowdata.distNdx.flies(ex) && ...
             abs(obj.windowdata.distNdx.t(used) - obj.windowdata.distNdx.t(ex))<5,
             isClose = 1; 
             break; 
          end
        end
        
        if isClose; continue; end;
        count = count+1;
        curN(count) = ex;
      end
      
      varForSSF.curFrame.expNum = obj.expi;
      varForSSF.curFrame.flyNum = obj.flies;
      varForSSF.curFrame.curTime = curTime;
      
      for k = 1:4
        varForSSF.posFrames(k).expNum = obj.windowdata.distNdx.exp(curP(k));
        varForSSF.posFrames(k).flyNum = obj.windowdata.distNdx.flies(curP(k));
        varForSSF.posFrames(k).curTime = obj.windowdata.distNdx.t(curP(k));
        varForSSF.negFrames(k).expNum = obj.windowdata.distNdx.exp(curN(k));
        varForSSF.negFrames(k).flyNum = obj.windowdata.distNdx.flies(curN(k));
        varForSSF.negFrames(k).curTime = obj.windowdata.distNdx.t(curN(k));
      end
      showSimilarFrames('setFrames',obj.frameFig,varForSSF);
    end  % method
    
  end
  
  methods % Fly and exp statistics
    
    % ---------------------------------------------------------------------
    function [stats,flyStats] = GetFlyStats(obj,expi,flyNum)
      % Calculates statistics such as number of labeled bouts, predicted bouts
      % and change in scores.
      %
      % stats: scalar struct, overall stats for exp/fly 
      % flyStats: nclassifier-by-1 struct array classifier-specific stats
            
      % MERGESTUPDATED
      
      obj.SetStatus('Computing stats for %s, target %d',obj.expnames{expi},flyNum);
      
      stats = struct();
      flyStats = cell2struct(cell(0,obj.nclassifiers),{});
      
      % General stats
      stats.endframe = obj.endframes_per_exp{expi}(flyNum);
      stats.firstframe = obj.firstframes_per_exp{expi}(flyNum);
      stats.trajLength = stats.endframe-stats.firstframe+1;      
      if obj.hassex
        if obj.hasperframesex
          sexfrac = obj.GetSexFrac(expi,flyNum);
          stats.sexfrac = round(100*sexfrac.M);
        else
          stats.sexfrac = 100*strcmpi(obj.GetSex(expi,flyNum),'M');
        end
      else
        stats.sexfrac = [];
      end
      
      % Compile frames/labels for this fly
      obj.StoreLabelsAndPreLoadWindowData();

      lblIdx2ClsIdx = obj.iLbl2iCls;
      clsIdx2LblIdx = obj.iCls2iLbl;      
      curbouts = zeros(1,0); % bout counter, one element per bout, values are CLASSIFIER indices (in 1:nclassifier)
      curts = zeros(1,0); % all labeled frame indices for this fly (may contain repeats)
      curlabels = zeros(1,0); % label vector for curts; values are LABEL indices (in 1:2*nclassifier)
      lblsExp = obj.labels(expi);
      [tf,iFly] = ismember(flyNum,lblsExp.flies,'rows');
      if tf
        nBouts = numel(lblsExp.t0s{iFly});
        for iBout = 1:nBouts
          t0 = lblsExp.t0s{iFly}(iBout);
          t1 = lblsExp.t1s{iFly}(iBout);
          name = lblsExp.names{iFly}{iBout};
          lblIdx = find(strcmp(name,obj.labelnames));
          assert(isscalar(lblIdx));
          numFrames = t1-t0;
          
          curts(1,end+1:end+numFrames) = t0:(t1-1);
          curlabels(1,end+1:end+numFrames) = lblIdx;
          curbouts(1,end+1) = lblIdx2ClsIdx(lblIdx); %#ok<AGROW>
        end
      end
      
      % General label stats
      nCls = obj.nclassifiers;
      stats.nbouts = numel(curbouts);
      stats.posframes = nnz(curlabels<=nCls);
      stats.negframes = nnz(curlabels>nCls); 
      stats.totalframes = numel(curts); % with multiple classifiers, this could exceed number of frames in track 
      
      for iCls = 1:nCls
        % label stats
        tmp = clsIdx2LblIdx{iCls};
        posLblIdx = tmp(1);
        negLblIdx = tmp(2);

        tmp = struct();
        tmp.nBouts = nnz(curbouts==iCls);        
        tmp.posframes = nnz(curlabels==posLblIdx);
        tmp.negframes = nnz(curlabels==negLblIdx);
        tmp.totalframes = tmp.posframes + tmp.negframes;        
        prefix = fif(obj.gtMode,'gt_','');
        flds = fieldnames(tmp);
        for f = flds(:)', f=f{1}; %#ok<FXSET>
          flyStats(iCls).([prefix f]) = tmp.(f);
        end
        
        pd = obj.predictdata{expi}{flyNum}(iCls);
        
        if pd.loaded_valid(1)
          idxcurr = pd.loaded_valid;
          flyStats(iCls).nscoreframes_loaded = nnz(idxcurr);
          flyStats(iCls).nscorepos_loaded = nnz(pd.loaded(idxcurr)>0);
          flyStats(iCls).nscoreneg_loaded = nnz(pd.loaded(idxcurr)<0);
        else
          flyStats(iCls).nscoreframes_loaded = [];
          flyStats(iCls).nscorepos_loaded = [];
          flyStats(iCls).nscoreneg_loaded = [];
        end
        
        tfCls = curlabels==posLblIdx | curlabels==negLblIdx;
        curtsCls = curts(tfCls);
        curlabelsCls = curlabels(tfCls);
        assert(numel(unique(curtsCls))==numel(curtsCls),...
          'For a given classifier each frame may be labeled at most once.');
        curNdx = pd.cur_valid;
        if any(curNdx) && ~isempty(obj.classifier)
          
          % Ignore labels that don't have predicted scores.
          haveScores = curNdx(curtsCls - obj.GetFirstFrames(expi,flyNum)+1); 
          curtsCls(~haveScores) = [];
          curlabelsCls(~haveScores) = [];
          
          if ~isempty(curlabelsCls)
            curWScores = pd.cur(curtsCls - obj.GetFirstFrames(expi,flyNum)+1);
            curPosMistakes = nnz( curWScores<0 & curlabelsCls==posLblIdx );
            curNegMistakes = nnz( curWScores>0 & curlabelsCls==negLblIdx );
          else
            curPosMistakes = [];
            curNegMistakes = [];
          end
          
          curScores = pd.cur(curNdx);          
          flyStats(iCls).nscoreframes = nnz(curNdx);
          flyStats(iCls).nscorepos = nnz(curScores>0);
          flyStats(iCls).nscoreneg = nnz(curScores<0);
          flyStats(iCls).errorsPos = curPosMistakes;
          flyStats(iCls).errorsNeg = curNegMistakes;
        else
          flyStats(iCls).nscoreframes = [];
          flyStats(iCls).nscorepos = [];
          flyStats(iCls).nscoreneg = [];
          flyStats(iCls).errorsPos = [];
          flyStats(iCls).errorsNeg = [];
        end
        
        flyStats(iCls).one2two = [];
        flyStats(iCls).two2one = [];
        if ~isempty(obj.classifier_old{iCls})
          curNdx = pd.old_valid;
          if nnz(curNdx)
            flyStats(iCls).one2two = nnz(pd.cur(curNdx)<0 & pd.old(curNdx)>0);
            flyStats(iCls).two2one = nnz(pd.cur(curNdx)>0 & pd.old(curNdx)<0);
          end
        end
        
        flyStats(iCls).validatedErrorsPos = [];
        flyStats(iCls).validatedErrorsNeg = [];
        if ~isempty(obj.windowdata(iCls).scores_validated)
          curNdx = obj.FlyNdx(expi,flyNum,iCls);
          if nnz(curNdx)
            curScores = obj.windowdata(iCls).scores_validated(curNdx);
            curLabels = obj.windowdata(iCls).labelidx_new(curNdx);
            assert(all(curLabels==posLblIdx | curLabels==negLblIdx));
            
            curPosMistakes = nnz( curScores(:)<0 & curLabels(:)==posLblIdx );
            curNegMistakes = nnz( curScores(:)>0 & curLabels(:)==negLblIdx );
            
            flyStats(iCls).validatedErrorsPos = curPosMistakes;
            flyStats(iCls).validatedErrorsNeg = curNegMistakes;
          end
        end
        
        flyStats(iCls).gt_suggestion_frames = nnz(obj.GetGTSuggestionIdx(expi,flyNum));
        
        %       if ~isempty(obj.windowdata.X)
        %         idxcurr = obj.windowdata.exp==expi & obj.windowdata.flies == flyNum;
        %         flyStats.npredictframes = nnz(idxcurr);
        %         flyStats.npredictfrac = nnz(obj.windowdata.scores(idxcurr)>0)/flyStats.nscoreframes;
        %
        %       else
        %         flyStats.npredictframes = [];
        %         flyStats.npredictfrac = [];
        %       end
      end
      
      obj.ClearStatus();
    end

   
    % ---------------------------------------------------------------------
    function scores = NormalizeScores(obj,scores)
      % Normalize the given scores, using the scoreNorm value in self.
      % Seems like it might make sense to add an option to all the
      % methods that get scores out of the JLabelData option, so that
      % callers can request normalized scores, and then make this a private
      % function.  --ALT, Apr 19, 2013   
      %
      % Effect: scores normalized. Each row scores(iCls,:) normalized by
      % obj.windowdata(iCls).scoreNorm.
      %
      % Side effect: obj.windowdata(:).scoreNorm initialized if necessary,
      % using obj.windowdata(:).X and current classifiers
      
      %MERGESTUPDATED
      
      nCls = obj.nclassifiers;
      assert(isequal(nCls,size(scores,1),numel(obj.windowdata),numel(obj.classifier)));

      for iCls = 1:nCls
        cls = obj.classifier{iCls};
        
        if isempty(obj.windowdata(iCls).scoreNorm) || isnan(obj.windowdata(iCls).scoreNorm)
          % Need to initialize scoreNorm
          
          if isempty(obj.windowdata(iCls).X) || isempty(cls)
            % Can't compute scoreNorm

            % Old comment:
            % Just return the unaltered scores in this case
            % Note that these unaltered scores can have elements outside of
            % [-1,+1].
            % Is this really what we want in this case?
            
            obj.windowdata(iCls).scoreNorm = nan;
          else
            wScores = myBoostClassify(obj.windowdata(iCls).X,cls);
            obj.windowdata(iCls).scoreNorm = prctile(abs(wScores),80);
          end
        end

        scoreNorm = obj.windowdata(iCls).scoreNorm;
        tfSm = scores(iCls,:)<-scoreNorm;
        tfLg = scores(iCls,:)>scoreNorm;
        scores(iCls,tfSm) = -scoreNorm;
        scores(iCls,tfLg) = scoreNorm;
        scores(iCls,:) = scores(iCls,:)/scoreNorm;
        % isnan(scoreNorm) => scores(iCls,:) is nan
      end
    end  % method
    
    
    %     % ---------------------------------------------------------------------
%     function expStats = GetExpStats(obj,expi)
%       % Calculates statistics such as number of labeled bouts, predicted bouts
%       % and change in scores.
%       
%       expStats.name = obj.expnames{expi};
%       expStats.nflies = obj.nflies_per_exp(expi);
%       expStats.nlabeledbouts = obj.labelstats(expi).nbouts_labeled;
%       expStats.nlabeledflies = obj.labelstats(expi).nflies_labeled;
%       
%       
%       if ~isempty(obj.predictdata.exp==expi)
%         expid = obj.predictdata.exp==expi;
%         expStats.nscoreframes = nnz(expid);
%         expStats.nscorepos = nnz(obj.predictdata.loaded(expid)>0);
% %         if ~isempty(obj.predictdata.classifierfilenames) && ...
% %             numel(obj.predictdata.classifierfilenames)>=expi
% %           expStats.classifierfilename = obj.predictdata.classifierfilenames{expi};
% %         else
% %           expStats.classifierfilename = '';
% %         end
%       else
%         expStats.nscoreframes = [];
%         expStats.nscorefrac = [];
%         expStats.classifierfilename = '';
%       end
%       
%     end

    
  end
  
  methods % Ground truthing.

    % ---------------------------------------------------------------------
    function [success,msg] = setGTSuggestionMode(obj,modeString,varargin)
      % Sets the ground-truth suggestion mode. This determines how things
      % returned by GetGTSuggestionIdx() are calculated.
      
      %MERGEST OK
      
      switch modeString,
        case 'Random'
          [success,msg] = obj.SuggestRandomGT(varargin{:});
        case 'Balanced'
          [success,msg] = obj.SuggestBalancedGT(varargin{:});
        case 'Imported'
          [success,msg] = obj.SuggestLoadedGT(varargin{:});
        case 'Threshold'
          [success,msg] = obj.SuggestThresholdGT(varargin{:});
        otherwise
          error('JLabelData:noSuchGTSuggestionMode', ...
                'Internal error: No such ground-truth suggestion mode');
      end
    end


    % ---------------------------------------------------------------------
    function avgBoutLen = GetAverageLoadedPredictionBoutLength(obj)
      %MERGEST OK
      assert(obj.nclassifiers==1,'Only supported for single classifiers.');
      
      if ~obj.HasLoadedScores(1)
        error('JLabelData:noLoadedScores','No scores have been loaded.');
      end
      
      blen = [];
      for endx = 1:obj.nexps
        for flies = 1:obj.nflies_per_exp(endx)
          curidx = obj.predictdata{endx}{flies}.loaded_valid;
          posts = obj.predictdata{endx}{flies}.loaded(curidx)>0;
          labeled = bwlabel(posts);
          aa = regionprops(labeled,'Area'); %#ok
          blen = [blen [aa.Area]]; %#ok
        end
      end
      avgBoutLen = mean(blen);
      
    end
    
    
    % ---------------------------------------------------------------------
    function SaveSuggestionGT(obj,filename)
      
      %MERGEST OK
      
      assert(obj.nclassifiers==1,'Only supported for single classifiers.');

      fid = fopen(filename,'w');
      switch obj.GTSuggestionMode
        case 'Random'
          for expi = 1:obj.nexps
            for fly = 1:obj.nflies_per_exp(expi)
              start = obj.randomGTSuggestions{expi}(fly).start;
              last = obj.randomGTSuggestions{expi}(fly).end;
              fprintf(fid,'exp:%s,fly:%d,start:%d,end:%d\n',obj.expnames{expi},fly,start,last);
            end
          end
        case 'Threshold'
          for expi = 1:obj.nexps
            if obj.predictdata{expi}{1}.loaded_valid(1)
              for fly = 1:obj.nflies_per_exp(expi)
                T1 = obj.GetTrxEndFrame(expi,fly);
                suggestedidx = zeros(1,T1);
                suggestedidx(obj.predictdata{expi}{fly}.t) = ...
                  obj.NormalizeScores(obj.predictdata{expi}{fly}.loaded) > ...
                  -obj.thresholdGTSuggestions;
                [t0s,t1s] = get_interval_ends(suggestedidx);
                for ndx = 1:numel(t0s)
                  if t1s(ndx)< T0, continue; end
                  fprintf(fid,'exp:%s,fly:%d,start:%d,end:%d\n',obj.expnames{expi}.fly,t0s(ndx),t1s(ndx));
                end
              end
            end
          end
        case 'Balanced'
          for ndx = 1:numel(obj.balancedGTSuggestions)
%             if obj.balancedGTSuggestions(ndx).exp ~= expi
%               continue;
%             end
            start = obj.balancedGTSuggestions(ndx).start;
            last = obj.balancedGTSuggestions(ndx).end;
            fprintf(fid,'exp:%s,fly:%d,start:%d,end:%d\n',...
              obj.expnames{obj.balancedGTSuggestions(ndx).exp},...
              obj.balancedGTSuggestions(ndx).flies,start,last);
          end
        case 'Imported'
          for expi = 1:obj.nexps
            for fly = 1:obj.nflies_per_exp(expi)
              start = obj.loadedGTSuggestions{expi}(fly).start;
              last = obj.loadedGTSuggestions{expi}(fly).end;
              if numel(start) == 1 && last < start,
                continue;
              end
              for ndx = 1:numel(start)
                fprintf(fid,'exp:%s,fly:%d,start:%d,end:%d\n',obj.expnames{expi},fly,start(ndx),last(ndx));
              end
            end
          end
      end
      fclose(fid);

    end

    
    % ---------------------------------------------------------------------
    function suggestedidx = GetGTSuggestionIdx(obj,expi,flies,T0,T1)

      % MERGEST OK
      
      assert(obj.nclassifiers==1,'Only supported for single classifiers.');

      % Get the indices of gt suggestion  
      if nargin<4
        T0 = obj.GetTrxFirstFrame(expi,flies);
        T1 = obj.GetTrxEndFrame(expi,flies);
      end
      n = T1-T0+1;
      off = 1 - T0;
      
      if isempty(obj.GTSuggestionMode)
        suggestedidx = false(1,n);
        return;
      end
      
      suggestedidx = false(1,n);
      
      switch obj.GTSuggestionMode,
        case 'Random'
          start = obj.randomGTSuggestions{expi}(flies).start;
          last = obj.randomGTSuggestions{expi}(flies).end;
          range = start+off:last+off;
          selIdx = range(range>0);
          suggestedidx(selIdx) = true;
        
        case 'Imported'
          if numel(obj.loadedGTSuggestions)<expi || isempty(obj.loadedGTSuggestions{expi}),
            suggestedidx = false(1,n);
            return;
          end
          suggestedidx = false(1,n);
          for ndx = 1:numel(obj.loadedGTSuggestions{expi}(flies).start)
            start = obj.loadedGTSuggestions{expi}(flies).start(ndx);
            last = obj.loadedGTSuggestions{expi}(flies).end(ndx);
            range = start+off:last+off;
            selIdx = range(range>0);
            suggestedidx(selIdx) = true;
          end
          suggestedidx(n+1:end) = [];

        case 'Threshold'
          if (obj.predictdata{expi}{flies}.loaded_valid(1))
            suggestedidx = ...
              obj.NormalizeScores(obj.predictdata{expi}{flies}.loaded) > ...
              -obj.thresholdGTSuggestions;
          elseif any(obj.predictdata{expi}{flies}.cur_valid)
            idxcurr = obj.predictdata{expi}{flies}.cur_valid;
            suggestedidx = false(size(idxcurr));
            suggestedidx(idxcurr) = obj.NormalizeScores(obj.predictdata{expi}{flies}.cur(idxcurr)) > ...
              -obj.thresholdGTSuggestions;
          end
          
        case 'Balanced'
          suggestedidx = false(1,n);
          for ndx = 1:numel(obj.balancedGTSuggestions)
            if obj.balancedGTSuggestions(ndx).exp ~= expi ||...
              obj.balancedGTSuggestions(ndx).flies ~= flies
              continue;
            end
            start = obj.balancedGTSuggestions(ndx).start;
            last = obj.balancedGTSuggestions(ndx).end;
            if start>T1 || last <T0, continue ;end
            start = max(start,T0); last = min(last,T1);
            range = start+off:last+off;
            selIdx = range(range>0);
            suggestedidx(selIdx) = true;
          end
      end
      
    end

    
    % ---------------------------------------------------------------------
    function has = HasCurrentScores(obj)
      % has: scalar logical. If true, at least one
      % experiment/fly/classifier has a valid predicted score (for at least
      % one frame)
      
      %MERGEST UPDATED
      
      has = false;
      for expi = 1:obj.nexps
        for flies = 1:obj.nflies_per_exp(expi)
          for ibeh = 1:obj.ntimelines
            if any(obj.predictdata{expi}{flies}(ibeh).cur_valid)
              has = true;
              return;
            end
          end
        end
      end
    end
    
    
    % ---------------------------------------------------------------------
    function crossError = GetGTPerformance(obj)
      % Computes classifier performance on the GT data.
      
      %MERGEST UPDATED
      
      assert(obj.nclassifiers==1,'Only supported for single classifiers.');
      assert(obj.gtMode,'JLabelData:wrongMode',...
              'Can only call GetGTPerformance() in ground-truthing mode.');

      obj.StoreLabelsAndPreLoadWindowData();
      
      hasloaded = obj.HasLoadedScores(1);
      if ~hasloaded
        for expi = 1:obj.nexps
          for i = 1:size(obj.labels(expi).flies,1)
            flies = obj.labels(expi).flies(i,:);
            labels_curr = obj.GetLabels(expi,flies);
%             ts = [];            
            for j = 1:numel(labels_curr.t0s)
%               ts = [ts,labels_curr.t0s(j):(labels_curr.t1s(j)-1)]; %#ok<AGROW>
              obj.PredictFast(expi,flies,labels_curr.t0s(j),labels_curr.t1s(j)-1,1);
            end
            
            % assumes that if have any loaded score for an experiment we
            % have scores for all the flies and for every frame.
%             [success1,msg] = obj.PreLoadWindowData(expi,flies,ts);
%             if ~success1,
%               warndlg(msg);
%               return;
%             end
          end
        end
%        obj.PredictLoaded();
      end
      
      gt_scores =[];
      gt_labels = [];
      
      for expi = 1:obj.nexps,
        for i = 1:size(obj.labels(expi).flies,1),
          
          flies = obj.labels(expi).flies(i,:);
          labels_curr = obj.GetLabels(expi,flies);
          
          % Find the important labels
          labels_imp = [];
          for j = 1:numel(labels_curr.imp_t0s),
            t0 = labels_curr.imp_t0s(j);
            t1 = labels_curr.imp_t1s(j);
            labels_imp = [labels_imp t0:t1-1];  %#ok
          end
          
          for j = 1:numel(labels_curr.t0s),
            t0 = labels_curr.t0s(j);
            t1 = labels_curr.t1s(j);
            
            curLabel = 2*repmat(find(strcmp(labels_curr.names{j},obj.labelnames)),1,t1-t0); 
            % single classifier: 2 for beh, 4 for no-beh
            curLabel(ismember(t0:t1-1,labels_imp)) = curLabel(ismember(t0:t1-1,labels_imp))-1;
            % now, 1/2/3/4 <-> behImp/behNotImp/noBehImp/noBehNotImp
            
            gt_labels = [gt_labels curLabel]; %#ok
            
            if hasloaded,
              idx = obj.predictdata{expi}{flies}.t(:) >=t0 & obj.predictdata{expi}{flies}.t(:) <t1;
              ts = obj.predictdata{expi}{flies}.t(idx);
              scores = obj.predictdata{expi}{flies}.loaded_pp(idx)-0.5;
              [check,ndxInLoaded] = ismember(t0:(t1-1),ts);
              if any(check==0), warndlg('Loaded scores are missing scores for some loaded frames'); end
              gt_scores = [gt_scores scores(ndxInLoaded)];  %#ok
            else
              idx = obj.predictdata{expi}{flies}.t(:) >=t0 & obj.predictdata{expi}{flies}.t(:) <t1;
              ts = obj.predictdata{expi}{flies}.t(idx);
              scores = obj.predictdata{expi}{flies}.cur_pp(idx)-0.5;
              [check,ndxInLoaded] = ismember(t0:(t1-1),ts);
              if any(check==0), warndlg('calculated scores are missing for some labeled frames'); end
              gt_scores = [gt_scores scores(ndxInLoaded)];  %#ok
            end
          end
          
        end
      end

      crossError = obj.createConfMat(1,gt_scores,gt_labels);
    end
    
    
    % ---------------------------------------------------------------------
    function gtMode = IsGTMode(obj)
      gtMode = obj.gtMode;
    end
    
  end
    
  methods
    
% Status display
    

    % ---------------------------------------------------------------------
    function SetStatusFn(obj,statusfn)
      obj.setstatusfn = statusfn;
    end

    
    % ---------------------------------------------------------------------
    function SetClearStatusFn(obj,clearfn)
      obj.clearstatusfn = clearfn;
    end   
    

% Post Processing functions

    % ---------------------------------------------------------------------
    function params = GetPostprocessingParams(obj)
      params = obj.postprocessparams;
    end
    
    
    % ---------------------------------------------------------------------
    function [success,msg] = SetPostprocessingParams(obj,params)
      assert(iscell(params) && numel(params)==obj.nclassifiers);
      obj.postprocessparams = params;
      [success,msg] = obj.ApplyPostprocessing();
    end
    
    
    % ---------------------------------------------------------------------
    function blen = GetPostprocessedBoutLengths(obj,iCls)
      % blen: row vector, bout length for classifier iCls over all
      % exps/flies
      
      %MERGESTUPDATED
      
      blen = zeros(1,0);
           
      if obj.HasCurrentScores()
        % For predicted scores.
        for endx = 1:obj.nexps
          for flies = 1:obj.nflies_per_exp(endx)
            pd = obj.predictdata{endx}{flies}(iCls);
            idx = find(pd.cur_valid); % AL20141215 
            ts = pd.t(idx);            
            [sortedts,idxorder] = sort(ts);
            % AL 20141215: added +1 to next line, cf ApplyPostProcessing
            gaps = find((sortedts(2:end) - sortedts(1:end-1))>1)+1; 
            gaps = [1;gaps';numel(ts)+1];
            for ndx = 1:numel(gaps)-1
              % loop over 'contiguous' segments of time
              curidx = idx(idxorder(gaps(ndx):gaps(ndx+1)-1)); % indices into pd.t, pd.cur_valid, pd.cur_pp for current time segment
              assert(isequal(size(pd.t),size(pd.cur_valid),size(pd.cur_pp)));
              posts = pd.cur_pp(curidx); 
              labeled = bwlabel(posts);
              aa = regionprops(labeled,'Area');  %#ok
              blen = [blen [aa.Area]];  %#ok
            end
          end
        end        
      else        
        % For loaded scores.
        for endx = 1:obj.nexps
          for flies = 1:obj.nflies_per_exp(endx)
            pd = obj.predictdata{endx}{flies}(iCls);
            curidx = pd.loaded_valid;
            curt = pd.t(curidx);
            if any(curt(2:end)-curt(1:end-1) ~= 1)
              warning('JLabelData:bouts','Scores are not in order');
              return;
            end
            posts = pd.loaded_pp(curidx);
            labeled = bwlabel(posts);
            aa = regionprops(labeled,'Area');  %#ok
            blen = [blen [aa.Area]];  %#ok
          end
        end        
      end
    end

    
    % ---------------------------------------------------------------------
    function [labels,labeledscores,allScores,scoreNorm] = GetAllLabelsAndScores(obj,iCls)
      % labels: current labels for classifier iCls, row vector of -1/1 for no-beh/beh resp
      % labeledscores: row vector same size as labels
      % allScores: row vector, predicted scores for iCls over all exps/flies
      % scoreNorm: scalar
      
      %MERGESTUPDATED
      
      wd = obj.windowdata(iCls);      
      if isempty(wd.exp)
        labels = zeros(1,0);
        labeledscores = zeros(1,0);
      else
        curNdx = wd.labelidx_cur~=0;
        origlabels = wd.labelidx_cur(curNdx);
        
        lblPosNeg = obj.iCls2iLbl{iCls};
        assert(all(origlabels==lblPosNeg(1) | origlabels==lblPosNeg(2)));
        labels = ((origlabels==lblPosNeg(1))-0.5)*2;
        labeledscores = myBoostClassify(wd.X(curNdx,:),obj.classifier{iCls});
      end
      
      allScores = zeros(1,0);
      for expi = 1:obj.nexps
        for flies = 1:obj.nflies_per_exp(expi)
          pd = obj.predictdata{expi}{flies}(iCls);
          curidx = pd.cur_valid;
          allScores = [allScores pd.cur(curidx)]; %#ok<AGROW>
        end
      end
      scoreNorm = wd.scoreNorm;
    end
    
  % Random stuff

    
    % ---------------------------------------------------------------------
    % function specifyEverythingFileNameFromUser(self,fileNameAbs)
    %   self.everythingFileName=fileNameAbs;
    %   self.userHasSpecifiedEverythingFileName=true;
    % end
    
    
    % ---------------------------------------------------------------------
    % function saveEverything(self,fileNameAbs)
    %   s=struct;
    %   s.featureLexicon=self.featureLexicon;
    %   s.saveableClassifier=self.getSaveableClassifier();
    %   [s.labels,s.gtLabels]=self.storeAndGetLabelsAndGTLabels();
    %   s.configParams=self.getConfigParams();  %#ok
    %   save(fileNameAbs,'-struct','s');
    % end

    
    % ---------------------------------------------------------------------    
    function cs = getClassifierStuff(self)
      
      %MERGEST UPDATED
        
      % make sure current labels are committed
      self.StoreLabelsForCurrentAnimal();
      
      cs = ClassifierStuff.empty(0,1);
      for iCls = self.nclassifiers:-1:1
        csArgs = { ...
            'type',self.classifiertype{iCls}, ...
            'params',self.classifier{iCls}, ...
            'trainingParams',self.classifier_params{iCls}, ...
            'timeStamp',self.classifierTS(iCls), ...
            'confThresholds',self.confThresholds(iCls,:), ...
            'scoreNorm',self.windowdata(iCls).scoreNorm, ...
            'postProcessParams',self.postprocessparams{iCls}, ...
            'featureNames',self.windowdata(iCls).featurenames,...
            'savewindowdata',self.savewindowdata(iCls)};
        if self.savewindowdata(iCls) && ~self.IsGTMode()
          csArgs(end+1:end+2) = {'windowdata',self.windowdata(iCls)};
        end          
        cs(iCls,1) = ClassifierStuff(csArgs{:});
      end
    end
      
    
%     % ---------------------------------------------------------------------
%     function projectParams=getProjectParams(self)
%       projectParams=struct();
%       projectParams.behaviors.type=self.targettype;
%       projectParams.behaviors.names=self.labelnames;
%       projectParams.behaviors.labelcolors=self.labelcolors;
%       projectParams.behaviors.unknowncolor=self.unknowncolor;
%       projectParams.file=struct();
%       projectParams.file.moviefilename=self.moviefilename;
%       projectParams.file.trxfilename=self.trxfilename;
%       projectParams.file.scorefilename=self.scorefilename;
%       projectParams.file.clipsdir=self.clipsdir;                  
%       projectParams.file.perframedir=self.perframedir;                  
%       projectParams.scoresinput = self.scoreFeatures ;
%       projectParams.labels=self.labelGraphicParams;
%       projectParams.trx=self.trxGraphicParams;
%     end  % method
  
    
%     % ---------------------------------------------------------------------
%     function initEverything(self,everythingParams)  % this should really be private
%       if isfield(everythingParams,'configParams')
%         self.SetConfigParams(everythingParams.configParams);
%       end
%     end
    

%     % ---------------------------------------------------------------------
%     function setLabelingMode(self,modeString)
%       switch modeString,
%         case 'Advanced',
%           self.SetAdvancedMode(true);
%           self.SetGTMode(false);
%         case 'Normal'
%           self.SetAdvancedMode(false);
%           self.SetGTMode(false);
%         case 'Ground Truthing',
%           self.SetAdvancedMode(false);
%           self.SetGTMode(true);
%         case 'Ground Truthing Advanced',
%           self.SetAdvancedMode(true);
%           self.SetGTMode(true);
%       end
%       self.SetMode();
%     end


    % ---------------------------------------------------------------------
    function tf = getPerFrameFeatureSetIsNonEmpty(self)
      % tf: nclassifiers-by-1 logical vec, true iff the current set of 
      % per-frame features in use is non-empty, i.e. contains at least one per-frame feature.
      tf = ~cellfun(@isempty,self.curperframefns);
    end
    
    % ---------------------------------------------------------------------
    function classifierExists = getClassifierExists(self)      
      classifierExists = ~isempty(self.classifier);      
    end
    
    
%     % ---------------------------------------------------------------------
%     function atLeastOneNormalLabelExists=getAtLeastOneNormalLabelExists(self)
%       % Returns true iff at least one normal (non-GT) label exists.
%       atLeastOneNormalLabelExists=false;
%       for i=1:self.nexps
%         if ~isempty(self.labels(i).t0s)
%           atLeastOneNormalLabelExists=true;
%           break
%         end
%       end
%       % If we haven't found any labels yet, check labelidx
%       if ~atLeastOneNormalLabelExists,
%         if any(self.labelidx.vals),
%           atLeastOneNormalLabelExists=true;
%         end
%       end
%     end
    
    
    % ---------------------------------------------------------------------
    function tf = getAtLeastOneNormalLabelOfEachClassExists(self,labelNames)
      % Returns true iff at least one normal (non-GT) label exists for each
      % member of labelNames. 
      %
      % labelNames: cellstr, subset of self.labelnames. Defaults to
      % self.labelnames
      %
      % tf: scalar logical

      %MERGESTUPDATED
      
      if ~exist('labelNames','var') || isempty(labelNames)
        labelNames = self.labelnames;
      else
        assert(iscellstr(labelNames) && all(ismember(labelNames,self.labelnames)));
      end
      
      tf = Labels.labelsSeen(self.labels,labelNames);      
      if ~all(tf)
        % Haven't seen all labels yet, check labelidx
        iLbl = unique(self.labelidx.vals(:)); % indices into self.labelnames (or 0)
        iLbl = iLbl(iLbl>0);
        names = self.labelnames(iLbl); % all unique names seen in .labelidx      
        tf = tf | ismember(labelNames,names);
      end
      
      tf = all(tf);      
    end
    
    function res = HasWindowdata(self,iCls)
      %MERGESTUPDATED
      names = self.iCls2LblNames{iCls};
      res = self.getAtLeastOneNormalLabelOfEachClassExists(names) && ...
            ~isempty(self.windowdata(iCls).X);
    end
    
    
    % ---------------------------------------------------------------------
    function everythingParams = getMacguffin(self)
      % Construct the object that will be saved in the everything file
      everythingParams = Macguffin(self);
    end

    
    % ---------------------------------------------------------------------
    function setScoreFeatures(obj,varargin)
      % Update obj.scoreFeatures, preserving invariants. If an exception
      % occurs, this function will roll back the object to its original
      % state.
      
      %MERGEST OK

      % Process arguments
      if length(varargin)==1
        scoreFeaturesNew = varargin{1};
      elseif length(varargin)==3
        % collect the args into a scorefeatures struct array
        scoreFeaturesFileNameListNew = varargin{1};
        timeStampListNew = varargin{2};
        scoreFileBaseNameListNew = varargin{3};
        scoreFeaturesNew = ...
          collectScoreFeatures(scoreFeaturesFileNameListNew, ...
                               timeStampListNew, ...
                               scoreFileBaseNameListNew);
      else
        error('JLabelData:internalError', ...
              'Internal error: Wrong number of arguments to JLabelData.setScoreFeatures()');
      end
      
      scoreFeaturesOld = obj.scoreFeatures;
      featureNamesInSubdialectOld = obj.allperframefns;
      % Get some other things, in case we need to roll-back
      perframeDataOld = obj.perframedata;
      perframeUnitsOld = obj.perframeunits;

      % Use try block, so we can easily roll back if anything goes amiss
      try 
        % determine which elements of each are kept, added
        [kept,added] = ...
          setDifferencesScoreFeatures(scoreFeaturesOld,scoreFeaturesNew);
        deleted = ~kept;

        % delete each of the deleted score features
        scoreFeaturesDeleted = scoreFeaturesOld(deleted);
        nDeleted = length(scoreFeaturesDeleted);
        for i = 1:nDeleted
          obj.deleteSingleScoreFeature(scoreFeaturesDeleted(i));
        end

        % add each of the added score features
        scoreFeaturesAdded = scoreFeaturesNew(added);
        nAdded = length(scoreFeaturesAdded);
        for i = 1:nAdded
          obj.addSingleScoreFeature(scoreFeaturesAdded(i));
        end

        % Re-load the perframe feature signals, since the PFFs may have changed
        [success,msg] = obj.loadPerframeData(obj.expi,obj.flies);
        if ~success
          error('JLabelData:unableToSetScoreFeatures',msg);
        end
      catch excp
        if isequal(excp.identifier,'JLabelData:unableToSetScoreFeatures') || ...
           isequal(excp.identifier,'JLabelData:errorGeneratingPerframeFileFromScoreFile')
          % unroll changes
          obj.scoreFeatures = scoreFeaturesOld;
          obj.allperframefns = featureNamesInSubdialectOld;
          obj.perframedata = perframeDataOld;
          obj.perframeunits = perframeUnitsOld;
        end
        % We always rethrow the exception, so the caller can inform the user
        rethrow(excp);
      end
      
      obj.clearClassifierProper();
      
      % note that we now have unsaved changes
      obj.needsave = true;
    end
    
    
    % ---------------------------------------------------------------------
    function result = classifierIsPresent(obj)
      result = ~isempty(obj.classifier);
    end
    
    
    % ---------------------------------------------------------------------
    function someExperimentIsCurrent = getSomeExperimentIsCurrent(self)
      if self.thereIsAnOpenFile
        nExp = self.nexps;
        someExperimentIsCurrent = (1<=self.expi) && ...
                                  (self.expi<=nExp);
      else
        someExperimentIsCurrent = false;
      end
    end
    
    
    % ---------------------------------------------------------------------
    function openJabFile(self, ...
                         fileNameAbs, ...
                         groundTruthingMode, ...
                         originalExpDirNames, ...
                         substituteExpDirNames) 
                       
      %MERGESTUPDATED
      
      % originalExpDirNames and substituteExpDirNames are optional.
      % If given, they should be cell arrays of the same length, each
      % element a string giving an absolute path to an experiment
      % directory.  Each element of originalExpDirNames should be an
      % experiment directory in the .jab file, and the corresponding
      % element of substitureExpDirNames gives an experiment dir name to be
      % used in place of the original one.  This is to enable the user to
      % manually locate exp dir names that are missing.  Whether these
      % experiment dir names are treated as normal exp dir names or
      % ground-truthing exp dir names depends on groundTruthingMode.
                       
      % process the args
      if ~exist('originalExpDirNames','var')
        originalExpDirNames = cell(0,1);
      end
      if ~exist('substituteExpDirNames','var')
        substituteExpDirNames = cell(0,1);
      end
      assert(numel(originalExpDirNames)==numel(substituteExpDirNames));
      
      self.gtMode = groundTruthingMode;

      % Open the file
      macguffin = loadAnonymous(fileNameAbs);
      if isstruct(macguffin)
        macguffin = Macguffin(macguffin);
      end
      macguffin.modernize(true);
      
      % Do the substiutions, if any
      substitutionsMade = false;
      if groundTruthingMode
        expDirNames = macguffin.gtExpDirNames;
        labels = macguffin.gtLabels;
      else
        expDirNames = macguffin.expDirNames;
        labels = macguffin.labels;
      end
      newExpDirNames = cell(1,0);
      newLabels = Labels.labels(0);
      for i = 1:length(expDirNames)
        expDirName = expDirNames{i};
        j = whichstr(expDirName,originalExpDirNames);
        if isempty(j)
          newExpDirNames{end+1} = expDirNames{i};  %#ok
          newLabels(end+1) = labels(i);  %#ok
        else
          newExpDirName = substituteExpDirNames{j};
          if ~isempty(newExpDirName)
            newExpDirNames{end+1} = substituteExpDirNames{j};  %#ok
            newLabels(end+1) = labels(i);  %#ok
          else
            % AL 20140908 
            % Empty new name for this experiment; experiment will not be added
            % Is this the intent or should this be asserted false?
          end
          substitutionsMade = true;
        end
      end
      if groundTruthingMode
        macguffin.gtExpDirNames = newExpDirNames;
        macguffin.gtLabels = newLabels;
      else
        macguffin.expDirNames = newExpDirNames;
        macguffin.labels = newLabels;
      end
      
      % Set the JLD to match the Macguffin
      self.setMacguffin(macguffin,true);
      
      % Store file-related stuff
      self.thereIsAnOpenFile = true;
      self.everythingFileNameAbs = fileNameAbs;
      self.userHasSpecifiedEverythingFileName = true;
      self.needsave = substitutionsMade; % Only need save if substitutions were made
      self.defaultpath = fileparts(fileNameAbs);
     
      % initialize the status table describing what required files exist
      [success,msg] = self.UpdateStatusTable();
      if ~success,
        error('JLabelData:unableToUpdateStatusTable',msg);
      end
      
      % Load windowdata if appropriate
      cs = macguffin.classifierStuff;
      assert(isequal(self.nclassifiers,numel(cs),numel(self.windowdata)));
      perframeNdx = find(strcmp('perframedir',self.filetypes));
      for iCls = 1:self.nclassifiers
        if ~substitutionsMade && ...
            ~self.IsGTMode() && ... 
            self.loadwindowdata(iCls) && ...
            isprop(cs(iCls),'windowdata') && ...
            isstruct(cs(iCls).windowdata) && ...
            ~isempty(cs(iCls).savewindowdata) && ...
            cs(iCls).savewindowdata
          
          % determine whether to load windowdata for this classifier
          tfLoadWinData = true;
          if self.isInteractive
            isPerframeNewer = false;
            for ndx = 1:self.nexps
              if self.classifierTS(iCls) < self.filetimestamps(ndx,perframeNdx);
                isPerframeNewer = true;
                expnamenewer = self.expnames{ndx};
                perframeTS = self.filetimestamps(ndx,perframeNdx);
                break;
              end
            end
            
            if isPerframeNewer
              qstr{1} = sprintf('One of the perframe files (Generated on %s) ',...
                datestr(perframeTS));
              qstr{end+1} = sprintf('is newer than the classifier (Trained on %s)',datestr(self.classifierTS(iCls))); %#ok<AGROW>
              qstr{end+1} = sprintf('for the experiment %s.',expnamenewer); %#ok<AGROW>
              qstr{end+1} = ' Still load the windowdata stored in the jab file?'; %#ok<AGROW>
              res = questdlg(qstr, ...
                'Load Window Data?', ...
                'Yes','No', ...
                'No');
              tfLoadWinData = strcmpi(res,'Yes');
            end
          end
          % If ~self.isInteractive, or classifiers newer than all PF
          % dirs, then tfLoadWinData true by default
          
          if tfLoadWinData
            oldScoreNorm = self.windowdata(iCls).scoreNorm;
            oldfeaturenames = self.windowdata(iCls).featurenames;
            self.windowdata(iCls) = cs(iCls).windowdata;
            if isempty(self.windowdata(iCls).scoreNorm) && ~isempty(oldScoreNorm)
              self.windowdata(iCls).scoreNorm = oldScoreNorm;
            end
            if isempty(self.windowdata(iCls).featurenames) && ~isempty(oldfeaturenames)
              self.windowdata(iCls).featurenames = oldfeaturenames;
            end
          end
        end
      end
    end
    
    
    % ---------------------------------------------------------------------
    function openJabFileNoExps(self, ...
        fileNameAbs, ...
        groundTruthingMode)
      
      % originalExpDirNames and substituteExpDirNames are optional.
      % If given, they should be cell arrays of the same length, each
      % element a string giving an absolute path to an experiment
      % directory.  Each element of originalExpDirNames should be an
      % experiment directory in the .jab file, and the corresponding
      % element of substitureExpDirNames gives an experiment dir name to be
      % used in place of the original one.  This is to enable the user to
      % manually locate exp dir names that are missing.  Whether these
      % experiment dir names are treated as normal exp dir names of
      % ground-truthing exp dir names depends on groundTruthingMode.
      
      
      % Set the ground-truthing mode
      self.gtMode=groundTruthingMode;
      
      %
      % Open the file
      %
      
      % get just the relative file name
      fileDirPathAbs=fileparts(fileNameAbs);
      %[fileDirPathAbs,baseName,ext]=fileparts(fileNameAbs);
      %fileNameRel=[baseName ext];
      
      % load the file
      macguffin=loadAnonymous(fileNameAbs);
      % if we get here, file was read successfully
      macguffin.modernize(true);
      
      % Set the JLD to match the Macguffin
      self.setMacguffin(macguffin,false);
      
      % Store file-related stuff
      self.thereIsAnOpenFile=true;
      self.everythingFileNameAbs=fileNameAbs;
      self.userHasSpecifiedEverythingFileName=true;
      self.needsave=false;
      self.defaultpath=fileDirPathAbs;
      
      % initialize the status table describing what required files exist
      [success,msg] = self.UpdateStatusTable();
      if ~success,
        error('JLabelData:unableToUpdateStatusTable',msg);
      end
    end  % method


    % ---------------------------------------------------------------------
    function newJabFile(obj,macguf,varargin)
      % Only called by ProjectSetup/new project creation. 
      % IMPORTANT: macguf has type Macguffin, but it is not a properly
      % initialized Macguffin object. It is semi-initialized object 
      % originating from ProjectSetup for the purposes of initialization, 
      % hence the various massaging here.
      
      if mod(numel(varargin),2) ~= 0,
        error('JLabelData:oddNumberOfOptionalArgsToNewJabFile',  ...
              'Optional inputs to JLabelData.newJabFile() should be p-v pairs.');
      end

      keys = varargin(1:2:end);
      values = varargin(2:2:end);     
      
      % If caller set the default path, set that now
      oldDefaultPath = obj.defaultpath;
      i = find(strcmpi(keys,'defaultpath'),1);
      if ~isempty(i),
        [success,msg] = obj.SetDefaultPath(values{i});
        if ~success,
          error('JLabelData:unableToSetDefaultPath',msg);
        end
      end
      
      obj.gtMode = false;
                     
      % Set the file data from the Macguffin object
      try
        obj.setMacguffin(macguf);
      catch excp
        % roll things back
        obj.defaultpath = oldDefaultPath;
        rethrow(excp);
      end
      
      % Make up filename
      try
        realbehnames = Labels.verifyBehaviorNames(macguf.behaviors.names);
        fileNameRel = [sprintf('%s_',realbehnames{1:end-1}) realbehnames{end} '.jab'];
      catch excp
        if isequal(excp.identifier,'Macguffin:mainBehaviorNotDefined')
          fileNameRel = 'untitled.jab';
        else
          rethrow(excp);
        end
      end  
      fileNameAbs = fullfile(obj.defaultpath,fileNameRel);

      % Set other file-related instance vars
      obj.thereIsAnOpenFile = true;
      obj.everythingFileNameAbs = fileNameAbs;
      obj.userHasSpecifiedEverythingFileName = false;
      obj.needsave = true; % b/c new file
      
      % initialize the status table describing what required files exist
      [success,msg] = obj.UpdateStatusTable();
      if ~success,
        error(msg);
      end      
    end

    
    % ---------------------------------------------------------------------
    function closeJabFile(self)
      % The list of things we want to be persistent
      listOfPersistentSlots={'defaultpath' ...
                             'expdefaultpath' ...
                             'setstatusfn' ...
                             'clearstatusfn' ...
                             'cacheSize' ...
                             'version' ...
                             'perframeGenerate' ...
                             'perframeOverwrite' ...
                             'isInteractive'}';
      
      % Save the things we want to persist after closing the file
      nPersistentSlots=length(listOfPersistentSlots);
      for i=1:1:nPersistentSlots
        thisSlot=listOfPersistentSlots{i};
        evalString=sprintf('%s=self.%s;',thisSlot,thisSlot);
        eval(evalString);
      end
      
      % Nuke the site from orbit.  It's the only way to be sure.
      self.initialize();
      
      % Re-load the things we want to persist
      for i=1:1:nPersistentSlots
        thisSlot=listOfPersistentSlots{i};
        evalString=sprintf('self.%s=%s;',thisSlot,thisSlot);
        eval(evalString);
      end
    end
    
    
    % ---------------------------------------------------------------------
    function delete(~)
    end
    
    
    % ---------------------------------------------------------------------
    function saveJabFile(self,fileNameAbs)
      fileNameRel=fileNameRelFromAbs(fileNameAbs);
      self.SetStatus(sprintf('Saving to %s...',fileNameRel));
      % Extract the structure that will be saved in the everything file
      macguffin=self.getMacguffin();
      % write the everything structure to disk
      try
        if exist(fileNameAbs,'file')
          backupFileNameAbs=[fileNameAbs,'~'];
          [success,message,identifier]=copyfile(fileNameAbs,backupFileNameAbs);  %#ok
          if ~success,
            backupFileNameRel=fileNameRelFromAbs(backupFileNameAbs);
            warning('JLabelData:unableToCreateBackup', ...
                  'Unable to create backup file %s.',backupFileNameRel);
          end
        end
        old=warning('query','MATLAB:structOnObject');
        warning('off','MATLAB:structOnObject');  % turn off annoying warning
        macguffinStruct = struct(macguffin);
        warning(old);  % restore annoying warning
        saveAnonymous(fileNameAbs,macguffinStruct);
      catch excp
        self.ClearStatus();
        rethrow(excp);
      end
      % Do follow-up book-keeping
      self.everythingFileNameAbs=fileNameAbs;
      self.userHasSpecifiedEverythingFileName=true;      
      self.needsave=false;
      fileDirPathAbs=fileparts(fileNameAbs);
      self.defaultpath=fileDirPathAbs;      
      self.ClearStatus();
    end  % method
    
    
    % ---------------------------------------------------------------------
    function importClassifier(self,fileNameAbs)
      %MERGEST SEEMSOK 
      
      macguffin = loadAnonymous(fileNameAbs);

      self.setScoreFeatures(macguffin.scoreFeatures);
      self.setFeatureSublexicon(macguffin.featureLexicon, ...
                                macguffin.featureLexiconName, ...
                                macguffin.sublexiconPFNames);
      self.setWindowFeaturesParams(macguffin.windowFeaturesParams);
      
%       % Generate the necessary files now, so that any problems occur now.
%       for iExp=1:self.nexps
%         [success,msg]=self.GenerateScoreFeaturePerframeFiles(iExp);
%         if ~success,
%           error('JLabelData:unableToGenerateScoreFeaturePerframeFile',msg);
%         end
%         self.UpdateStatusTable('perframedir',iExp);
%         allPerframeFilesExist=self.fileexists(iExp,whichstr('perframedir',self.filetypes));
%         if ~allPerframeFilesExist , 
%           [success,msg]=self.GeneratePerframeFilesExceptScoreFeatures(iExp);
%           if ~success,
%             error('JLabelData:unableToGeneratePerframeFile',msg);
%           end
%         end
%       end
      
      % Load the classifier proper, training params, etc.
      self.setClassifierStuff(macguffin.classifierStuff);

%       % do this to prompt loading of windowdata
%       force=true;
%       self.setCurrentTarget(self.expi,self.flies,force);
      
      self.needsave=true;
    end 
    
    
    % ---------------------------------------------------------------------
    function setToValue(self,jld)
      % Makes self into a clone of jld.  I.e. sets all the independent
      % properties of self to have the same _value_ as the corresponding
      % property of jld.
      mc=metaclass(self);
      propertyList=mc.PropertyList;
      for i=1:length(propertyList)
        property=propertyList(i);
        if ~property.Dependent
          self.(property.Name)=jld.(property.Name);
        end
      end
    end  % method
    
    
    % ---------------------------------------------------------------------
    function expdirs_removed = removeExperimentsWithNoLabels(self)
      self.StoreLabelsForCurrentAnimal();  % make sure labels are commited
      nExps=self.nexps;
      markedForRemoval=false(1,nExps);
      for i=1:nExps
        t0sThis=self.labels(i).t0s;
        % t0sThis is a cell array, with one element per labeled target.
        % Each element holds a double array, with the start frames of each
        % labelled bout for that target.
        nBoutsPerLabeledTarget=cellfun(@(a)length(a),t0sThis);
        nBouts=sum(nBoutsPerLabeledTarget);
        markedForRemoval(i)=(nBouts==0);
      end
      expIndicesToRemove=find(markedForRemoval);
      expdirs_removed = self.expdirs(expIndicesToRemove);
      self.RemoveExpDirs(expIndicesToRemove);  %#ok
    end  % method
    
    
    
    function isRandom = getColorAssignment(self)
      if isfield(self.trxGraphicParams,'assignment') && ...
          strcmp(self.trxGraphicParams.assignment,'static')
        isRandom = false;
      else
        isRandom = true;
      end
      
    end
    
    
    function setsavewindowdata(self,value)
      assert(numel(self.savewindowdata)==self.nclassifiers);
      assert(isscalar(value) || numel(value)==self.nclassifiers);
      self.savewindowdata(:) = value;
      self.needsave = true;      
    end


% Deprecated

    % ---------------------------------------------------------------------
    function MaybeStoreLabelsAndPreLoadWindowDataNow(self)
      % This is a hint to JLabelData that right now might be a good time to
      % write-back the currrent labels to the main store, and to pre-load the
      % window data.
      % This method is named as if it's a hint, but in the one place it's
      % currently called, it may well be required for proper behavior.
      % This method is deprecated b/c this the sort of book-keeping that
      % should be internal to JLabelData.  Callers shouldn't need to tell
      % JLabelData to get its house in order.
      self.StoreLabelsAndPreLoadWindowData();
    end  % method
    
  end  % End methods block

  methods (Access=private)
    function [scores,predictions] = GetScoresCore(obj,expi,flies,...
        fld,fldValid,fldPP,T0,T1)
      % scores: nclassifier-by-(T1-T0+1)
      % predictions: nclassifier-by-(T1-T0+1). fldPP only needed to compute
      % predictions.

      n = T1-T0+1;
      off = 1 - T0;

      pdArr = obj.predictdata{expi}{flies};
      nTL = obj.ntimelines;
      assert(numel(pdArr)==nTL);
      scores = zeros(nTL,n);
      predictions = zeros(nTL,n);
      for iTL = 1:nTL
        pd = pdArr(iTL);
        idxcurr = pd.(fldValid) & pd.t>=T0 & pd.t<=T1;
        scores(iTL,pd.t(idxcurr)+off) = pd.(fld)(idxcurr);
        predictions(iTL,pd.t(idxcurr)+off) = 2-pd.(fldPP)(idxcurr);
      end
    end
  end
  
  methods (Static,Access=private)
    
    function [tffound,filename,timestamp] = GetFileRaw(fileType,parentDir,fileNameLocal)
      % Look for a filename in a parent dir.
      % fileType: The fileType enum used here in JLabelData. This is used
      % only for a quirk regarding .lnk/.seq files
      % fileNameLocal: char, single short filename.
      %
      % tffound: scalar logical.
      %   - If true, filename is the full filename and timestamp is the filesystem timestamp.
      %   - If false, filename is the file-that-was-tried; and timestamp=-inf.
      
      assert(isscalar(parentDir));
      
      for j = 1:numel(parentDir),
        ddir = parentDir{j};
        
        filename = fullfile(ddir,fileNameLocal);
        if exist(filename,'file'),
          tmp = dir(filename);
          timestamp = tmp.datenum;
          tffound = true;
          return;
        end
        % check for lnk files
        if ispc && exist([filename,'.lnk'],'file'),
          isseq = ~isempty(regexp(fileNameLocal,'\.seq$','once'));
          % for seq file, just keep the soft link, get_readframe_fcn will
          % deal with it
          [actualfilename,didfind] = GetPCShortcutFileActualPath(filename);
          if didfind,
            tmp = dir(actualfilename);
            timestamp = tmp.datenum;
            if ~isseq || ~strcmpi(fileType,'movie'),
              filename = actualfilename;
            end
            tffound = true;
            return;
          end
        end
      end
      
      tffound = false;
      % filename is the file-that-was-tried
      timestamp = -inf;
    end

    function tf = AllPredictedScoresValid(predDataExp,nclassifier)
      % predDataExp: JLD.predictdata for one experiment, eg
      % obj.predictdata{expi}
      % tf: nclassifier x 1 logical. tf(i) is true if entire timeline for
      % all flies is predicted/valid for classifier i
      
      %MERGESTUPDATED
      
      nfly = numel(predDataExp);
      tf = true(nclassifier,1);
      for iCls = 1:nclassifier
        for fly = 1:nfly
          pd = predDataExp{fly};
          assert(numel(pd)==nclassifier);
          if ~all(pd(iCls).cur_valid)
            tf(iCls) = false;
            break;
          end
        end
      end
    end
    
  end

end % End class

